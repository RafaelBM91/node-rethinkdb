/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bluebird/js/main/any.js":
/*!**********************************************!*\
  !*** ./node_modules/bluebird/js/main/any.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/any.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/async.js":
/*!************************************************!*\
  !*** ./node_modules/bluebird/js/main/async.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = __webpack_require__(/*! ./schedule.js */ \"./node_modules/bluebird/js/main/schedule.js\");\nvar Queue = __webpack_require__(/*! ./queue.js */ \"./node_modules/bluebird/js/main/queue.js\");\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\n\nfunction Async() {\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._trampolineEnabled = true;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule =\n        schedule.isStatic ? schedule(this.drainQueues) : schedule;\n}\n\nAsync.prototype.disableTrampolineIfNecessary = function() {\n    if (util.hasDevTools) {\n        this._trampolineEnabled = false;\n    }\n};\n\nAsync.prototype.enableTrampoline = function() {\n    if (!this._trampolineEnabled) {\n        this._trampolineEnabled = true;\n        this._schedule = function(fn) {\n            setTimeout(fn, 0);\n        };\n    }\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._normalQueue.length() > 0;\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nif (!util.hasDevTools) {\n    Async.prototype.invokeLater = AsyncInvokeLater;\n    Async.prototype.invoke = AsyncInvoke;\n    Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n    if (schedule.isStatic) {\n        schedule = function(fn) { setTimeout(fn, 0); };\n    }\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                setTimeout(function() {\n                    fn.call(receiver, arg);\n                }, 100);\n            });\n        }\n    };\n\n    Async.prototype.invoke = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                fn.call(receiver, arg);\n            });\n        }\n    };\n\n    Async.prototype.settlePromises = function(promise) {\n        if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n        } else {\n            this._schedule(function() {\n                promise._settlePromises();\n            });\n        }\n    };\n}\n\nAsync.prototype.invokeFirst = function (fn, receiver, arg) {\n    this._normalQueue.unshift(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = new Async();\nmodule.exports.firstLineError = firstLineError;\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/async.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/bind.js":
/*!***********************************************!*\
  !*** ./node_modules/bluebird/js/main/bind.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise) {\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (this._isPending()) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, ret._progress, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, ret._progress, ret, context);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 131072;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~131072);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 131072) === 131072;\n};\n\nPromise.bind = function (thisArg, value) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        maybePromise._then(function() {\n            ret._resolveCallback(value);\n        }, ret._reject, ret._progress, ret, null);\n    } else {\n        ret._resolveCallback(value);\n    }\n    return ret;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/bind.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/bluebird.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/main/bluebird.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = __webpack_require__(/*! ./promise.js */ \"./node_modules/bluebird/js/main/promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/bluebird.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/call_get.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/main/call_get.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n    if (true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/call_get.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar errors = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\");\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar CancellationError = errors.CancellationError;\n\nPromise.prototype._cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    var parent;\n    var promiseToReject = this;\n    while ((parent = promiseToReject._cancellationParent) !== undefined &&\n        parent.isCancellable()) {\n        promiseToReject = parent;\n    }\n    this._unsetCancellable();\n    promiseToReject._target()._rejectCallback(reason, false, true);\n};\n\nPromise.prototype.cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    if (reason === undefined) reason = new CancellationError();\n    async.invokeLater(this._cancel, this, reason);\n    return this;\n};\n\nPromise.prototype.cancellable = function () {\n    if (this._cancellable()) return this;\n    async.enableTrampoline();\n    this._setCancellable();\n    this._cancellationParent = undefined;\n    return this;\n};\n\nPromise.prototype.uncancellable = function () {\n    var ret = this.then();\n    ret._unsetCancellable();\n    return ret;\n};\n\nPromise.prototype.fork = function (didFulfill, didReject, didProgress) {\n    var ret = this._then(didFulfill, didReject, didProgress,\n                         undefined, undefined);\n\n    ret._setCancellable();\n    ret._cancellationParent = undefined;\n    return ret;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/cancel.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/captured_trace.js":
/*!*********************************************************!*\
  !*** ./node_modules/bluebird/js/main/captured_trace.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function() {\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](main|debug|zalgo|instrumented)/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar warn;\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.parent = function() {\n    return this._parent;\n};\n\nCapturedTrace.prototype.hasParent = function() {\n    return this._parent !== undefined;\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = CapturedTrace.parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = stackFramePattern.test(line) ||\n            \"    (No stack trace)\" === line;\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0) {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nCapturedTrace.parseStackAndMessage = function(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: cleanStack(stack)\n    };\n};\n\nCapturedTrace.formatAndLogError = function(error, title) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (typeof error === \"object\" || typeof error === \"function\") {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof warn === \"function\") {\n            warn(message);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n};\n\nCapturedTrace.unhandledRejection = function (reason) {\n    CapturedTrace.formatAndLogError(reason, \"^--- With additional stack trace: \");\n};\n\nCapturedTrace.isSupported = function () {\n    return typeof captureStackTrace === \"function\";\n};\n\nCapturedTrace.fireRejectionEvent =\nfunction(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent(name, reason, promise);\n    } catch (e) {\n        globalEventFired = true;\n        async.throwLater(e);\n    }\n\n    var domEventFired = false;\n    if (fireDomEvent) {\n        try {\n            domEventFired = fireDomEvent(name.toLowerCase(), {\n                reason: reason,\n                promise: promise\n            });\n        } catch (e) {\n            domEventFired = true;\n            async.throwLater(e);\n        }\n    }\n\n    if (!globalEventFired && !localEventFired && !domEventFired &&\n        name === \"unhandledRejection\") {\n        CapturedTrace.formatAndLogError(reason, \"Unhandled rejection \");\n    }\n};\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj.toString();\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\nCapturedTrace.setBounds = function(firstLineError, lastLineError) {\n    if (!CapturedTrace.isSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit = Error.stackTraceLimit + 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nvar fireDomEvent;\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function(name, reason, promise) {\n            if (name === \"rejectionHandled\") {\n                return process.emit(name, promise);\n            } else {\n                return process.emit(name, reason, promise);\n            }\n        };\n    } else {\n        var customEventWorks = false;\n        var anyEventWorks = true;\n        try {\n            var ev = new self.CustomEvent(\"test\");\n            customEventWorks = ev instanceof CustomEvent;\n        } catch (e) {}\n        if (!customEventWorks) {\n            try {\n                var event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(\"testingtheevent\", false, true, {});\n                self.dispatchEvent(event);\n            } catch (e) {\n                anyEventWorks = false;\n            }\n        }\n        if (anyEventWorks) {\n            fireDomEvent = function(type, detail) {\n                var event;\n                if (customEventWorks) {\n                    event = new self.CustomEvent(type, {\n                        detail: detail,\n                        bubbles: false,\n                        cancelable: true\n                    });\n                } else if (self.dispatchEvent) {\n                    event = document.createEvent(\"CustomEvent\");\n                    event.initCustomEvent(type, false, true, detail);\n                }\n\n                return event ? !self.dispatchEvent(event) : false;\n            };\n        }\n\n        var toWindowMethodNameMap = {};\n        toWindowMethodNameMap[\"unhandledRejection\"] = (\"on\" +\n            \"unhandledRejection\").toLowerCase();\n        toWindowMethodNameMap[\"rejectionHandled\"] = (\"on\" +\n            \"rejectionHandled\").toLowerCase();\n\n        return function(name, reason, promise) {\n            var methodName = toWindowMethodNameMap[name];\n            var method = self[methodName];\n            if (!method) return false;\n            if (name === \"rejectionHandled\") {\n                method.call(self, promise);\n            } else {\n                method.call(self, reason, promise);\n            }\n            return true;\n        };\n    }\n})();\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    warn = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        warn = function(message) {\n            process.stderr.write(\"\\u001b[31m\" + message + \"\\u001b[39m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        warn = function(message) {\n            console.warn(\"%c\" + message, \"color: red\");\n        };\n    }\n}\n\nreturn CapturedTrace;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/captured_trace.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/catch_filter.js":
/*!*******************************************************!*\
  !*** ./node_modules/bluebird/js/main/catch_filter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar errors = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar keys = __webpack_require__(/*! ./es5.js */ \"./node_modules/bluebird/js/main/es5.js\").keys;\nvar TypeError = errors.TypeError;\n\nfunction CatchFilter(instances, callback, promise) {\n    this._instances = instances;\n    this._callback = callback;\n    this._promise = promise;\n}\n\nfunction safePredicate(predicate, e) {\n    var safeObject = {};\n    var retfilter = tryCatch(predicate).call(safeObject, e);\n\n    if (retfilter === errorObj) return retfilter;\n\n    var safeKeys = keys(safeObject);\n    if (safeKeys.length) {\n        errorObj.e = new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\");\n        return errorObj;\n    }\n    return retfilter;\n}\n\nCatchFilter.prototype.doFilter = function (e) {\n    var cb = this._callback;\n    var promise = this._promise;\n    var boundTo = promise._boundValue();\n    for (var i = 0, len = this._instances.length; i < len; ++i) {\n        var item = this._instances[i];\n        var itemIsErrorType = item === Error ||\n            (item != null && item.prototype instanceof Error);\n\n        if (itemIsErrorType && e instanceof item) {\n            var ret = tryCatch(cb).call(boundTo, e);\n            if (ret === errorObj) {\n                NEXT_FILTER.e = ret.e;\n                return NEXT_FILTER;\n            }\n            return ret;\n        } else if (typeof item === \"function\" && !itemIsErrorType) {\n            var shouldHandle = safePredicate(item, e);\n            if (shouldHandle === errorObj) {\n                e = errorObj.e;\n                break;\n            } else if (shouldHandle) {\n                var ret = tryCatch(cb).call(boundTo, e);\n                if (ret === errorObj) {\n                    NEXT_FILTER.e = ret.e;\n                    return NEXT_FILTER;\n                }\n                return ret;\n            }\n        }\n    }\n    NEXT_FILTER.e = e;\n    return NEXT_FILTER;\n};\n\nreturn CatchFilter;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/catch_filter.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/context.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/main/context.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, CapturedTrace, isDebugging) {\nvar contextStack = [];\nfunction Context() {\n    this._trace = new CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.pop();\n    }\n};\n\nfunction createContext() {\n    if (isDebugging()) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\n\nPromise.prototype._peekContext = peekContext;\nPromise.prototype._pushContext = Context.prototype._pushContext;\nPromise.prototype._popContext = Context.prototype._popContext;\n\nreturn createContext;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/context.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/debuggability.js":
/*!********************************************************!*\
  !*** ./node_modules/bluebird/js/main/debuggability.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, CapturedTrace) {\nvar getDomain = Promise._getDomain;\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar Warning = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\").Warning;\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar debugging = false || (util.isNode &&\n                    (!!process.env[\"BLUEBIRD_DEBUG\"] ||\n                     \"development\" === \"development\"));\n\nif (util.isNode && process.env[\"BLUEBIRD_DEBUG\"] == 0) debugging = false;\n\nif (debugging) {\n    async.disableTrampolineIfNecessary();\n}\n\nPromise.prototype._ignoreRejections = function() {\n    this._unsetRejectionIsUnhandled();\n    this._bitField = this._bitField | 16777216;\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 16777216) !== 0) return;\n    this._setRejectionIsUnhandled();\n    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    CapturedTrace.fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._getCarriedStackTrace() || this._settledValue;\n        this._setUnhandledRejectionIsNotified();\n        CapturedTrace.fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 524288;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~524288);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 524288) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 2097152;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~2097152);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 2097152) > 0;\n};\n\nPromise.prototype._setCarriedStackTrace = function (capturedTrace) {\n    this._bitField = this._bitField | 1048576;\n    this._fulfillmentHandler0 = capturedTrace;\n};\n\nPromise.prototype._isCarryingStackTrace = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._getCarriedStackTrace = function () {\n    return this._isCarryingStackTrace()\n        ? this._fulfillmentHandler0\n        : undefined;\n};\n\nPromise.prototype._captureStackTrace = function () {\n    if (debugging) {\n        this._trace = new CapturedTrace(this._peekContext());\n    }\n    return this;\n};\n\nPromise.prototype._attachExtraTrace = function (error, ignoreSelf) {\n    if (debugging && canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = CapturedTrace.parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n};\n\nPromise.prototype._warn = function(message) {\n    var warning = new Warning(message);\n    var ctx = this._peekContext();\n    if (ctx) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = CapturedTrace.parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n    CapturedTrace.formatAndLogError(warning, \"\");\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection =\n        typeof fn === \"function\" ? (domain === null ? fn : domain.bind(fn))\n                                 : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled =\n        typeof fn === \"function\" ? (domain === null ? fn : domain.bind(fn))\n                                 : undefined;\n};\n\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() &&\n        debugging === false\n   ) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/DT1qyG\\u000a\");\n    }\n    debugging = CapturedTrace.isSupported();\n    if (debugging) {\n        async.disableTrampolineIfNecessary();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return debugging && CapturedTrace.isSupported();\n};\n\nif (!CapturedTrace.isSupported()) {\n    Promise.longStackTraces = function(){};\n    debugging = false;\n}\n\nreturn function() {\n    return debugging;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/debuggability.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/direct_resolve.js":
/*!*********************************************************!*\
  !*** ./node_modules/bluebird/js/main/direct_resolve.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar isPrimitive = util.isPrimitive;\n\nmodule.exports = function(Promise) {\nvar returner = function () {\n    return this;\n};\nvar thrower = function () {\n    throw this;\n};\nvar returnUndefined = function() {};\nvar throwUndefined = function() {\n    throw undefined;\n};\n\nvar wrapper = function (value, action) {\n    if (action === 1) {\n        return function () {\n            throw value;\n        };\n    } else if (action === 2) {\n        return function () {\n            return value;\n        };\n    }\n};\n\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value === undefined) return this.then(returnUndefined);\n\n    if (isPrimitive(value)) {\n        return this._then(\n            wrapper(value, 2),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    } else if (value instanceof Promise) {\n        value._ignoreRejections();\n    }\n    return this._then(returner, undefined, undefined, value, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    if (reason === undefined) return this.then(throwUndefined);\n\n    if (isPrimitive(reason)) {\n        return this._then(\n            wrapper(reason, 1),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    }\n    return this._then(thrower, undefined, undefined, reason, undefined);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/direct_resolve.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/each.js":
/*!***********************************************!*\
  !*** ./node_modules/bluebird/js/main/each.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, null, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, null, INTERNAL);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/each.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/errors.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5.js */ \"./node_modules/bluebird/js/main/es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    notEnumerableProp(Error, \"__BluebirdErrorTypes__\", errorTypes);\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/errors.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/es5.js":
/*!**********************************************!*\
  !*** ./node_modules/bluebird/js/main/es5.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/es5.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/filter.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/filter.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/filter.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/finally.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/main/finally.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar isPrimitive = util.isPrimitive;\nvar thrower = util.thrower;\n\nfunction returnThis() {\n    return this;\n}\nfunction throwThis() {\n    throw this;\n}\nfunction return$(r) {\n    return function() {\n        return r;\n    };\n}\nfunction throw$(r) {\n    return function() {\n        throw r;\n    };\n}\nfunction promisedFinally(ret, reasonOrValue, isFulfilled) {\n    var then;\n    if (isPrimitive(reasonOrValue)) {\n        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n    } else {\n        then = isFulfilled ? returnThis : throwThis;\n    }\n    return ret._then(then, thrower, undefined, reasonOrValue, undefined);\n}\n\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundValue())\n                    : handler();\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, reasonOrValue,\n                                    promise.isFulfilled());\n        }\n    }\n\n    if (promise.isRejected()) {\n        NEXT_FILTER.e = reasonOrValue;\n        return NEXT_FILTER;\n    } else {\n        return reasonOrValue;\n    }\n}\n\nfunction tapHandler(value) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundValue(), value)\n                    : handler(value);\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, value, true);\n        }\n    }\n    return value;\n}\n\nPromise.prototype._passThroughHandler = function (handler, isFinally) {\n    if (typeof handler !== \"function\") return this.then();\n\n    var promiseAndHandler = {\n        promise: this,\n        handler: handler\n    };\n\n    return this._then(\n            isFinally ? finallyHandler : tapHandler,\n            isFinally ? finallyHandler : undefined, undefined,\n            promiseAndHandler, undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThroughHandler(handler, true);\n};\n\nPromise.prototype.tap = function (handler) {\n    return this._passThroughHandler(handler, false);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/finally.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/generators.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/main/generators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise) {\nvar errors = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\");\nvar TypeError = errors.TypeError;\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    var promise = this._promise = new Promise(INTERNAL);\n    promise._captureStackTrace();\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n}\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._next(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    if (result === errorObj) {\n        return this._promise._rejectCallback(result.e, false, true);\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._promise._resolveCallback(value);\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._throw(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/4Y4pDk\\u000a\\u000a\".replace(\"%s\", value) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise._then(\n            this._next,\n            this._throw,\n            undefined,\n            this,\n            null\n       );\n    }\n};\n\nPromiseSpawn.prototype._throw = function (reason) {\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._next = function (value) {\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        spawn._generator = generator;\n        spawn._next(undefined);\n        return spawn.promise();\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/generators.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/join.js":
/*!***********************************************!*\
  !*** ./node_modules/bluebird/js/main/join.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var caller = function(count) {\n        var values = [];\n        for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n        return new Function(\"holder\", \"                                      \\n\\\n            'use strict';                                                    \\n\\\n            var callback = holder.fn;                                        \\n\\\n            return callback(values);                                         \\n\\\n            \".replace(/values/g, values.join(\", \")));\n    };\n    var thenCallbacks = [];\n    var callers = [undefined];\n    for (var i = 1; i <= 5; ++i) {\n        thenCallbacks.push(thenCallback(i));\n        callers.push(caller(i));\n    }\n\n    var Holder = function(total, fn) {\n        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n        this.fn = fn;\n        this.total = total;\n        this.now = 0;\n    };\n\n    Holder.prototype.callers = callers;\n    Holder.prototype.checkFulfillment = function(promise) {\n        var now = this.now;\n        now++;\n        var total = this.total;\n        if (now >= total) {\n            var handler = this.callers[total];\n            promise._pushContext();\n            var ret = tryCatch(handler)(this);\n            promise._popContext();\n            if (ret === errorObj) {\n                promise._rejectCallback(ret.e, false, true);\n            } else {\n                promise._resolveCallback(ret);\n            }\n        } else {\n            this.now = now;\n        }\n    };\n\n    var reject = function (reason) {\n        this._reject(reason);\n    };\n}\n}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (true) {\n            if (last < 6 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var holder = new Holder(last, fn);\n                var callbacks = thenCallbacks;\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        if (maybePromise._isPending()) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                        } else if (maybePromise._isFulfilled()) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else {\n                            ret._reject(maybePromise._reason());\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/join.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/map.js":
/*!**********************************************!*\
  !*** ./node_modules/bluebird/js/main/map.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar getDomain = Promise._getDomain;\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar PENDING = {};\nvar EMPTY_ARRAY = [];\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : domain.bind(fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n    async.invoke(init, this, undefined);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\nfunction init() {this._init$(undefined, -2);}\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n    if (values[index] === PENDING) {\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var callback = this._callback;\n        var receiver = this._promise._boundValue();\n        this._promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        this._promise._popContext();\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = PENDING;\n                return maybePromise._proxyPromiseArray(this, index);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n\n    }\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    var limit = typeof options === \"object\" && options !== null\n        ? options.concurrency\n        : 0;\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter);\n}\n\nPromise.prototype.map = function (fn, options) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n    return map(this, fn, options, null).promise();\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    return map(promises, fn, options, _filter).promise();\n};\n\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/map.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/method.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/method.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        ret._popContext();\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn, args, ctx) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value = util.isArray(args)\n        ? tryCatch(fn).apply(ctx, args)\n        : tryCatch(fn).call(ctx, args);\n    ret._popContext();\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false, true);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/method.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/nodeify.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/main/nodeify.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var target = promise._target();\n        var newReason = target._getCarriedStackTrace();\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback =\nPromise.prototype.nodeify = function (nodeback, options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/nodeify.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/progress.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/main/progress.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, PromiseArray) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nPromise.prototype.progressed = function (handler) {\n    return this._then(undefined, undefined, handler, undefined, undefined);\n};\n\nPromise.prototype._progress = function (progressValue) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._target()._progressUnchecked(progressValue);\n\n};\n\nPromise.prototype._progressHandlerAt = function (index) {\n    return index === 0\n        ? this._progressHandler0\n        : this[(index << 2) + index - 5 + 2];\n};\n\nPromise.prototype._doProgressWith = function (progression) {\n    var progressValue = progression.value;\n    var handler = progression.handler;\n    var promise = progression.promise;\n    var receiver = progression.receiver;\n\n    var ret = tryCatch(handler).call(receiver, progressValue);\n    if (ret === errorObj) {\n        if (ret.e != null &&\n            ret.e.name !== \"StopProgressPropagation\") {\n            var trace = util.canAttachTrace(ret.e)\n                ? ret.e : new Error(util.toString(ret.e));\n            promise._attachExtraTrace(trace);\n            promise._progress(ret.e);\n        }\n    } else if (ret instanceof Promise) {\n        ret._then(promise._progress, null, null, promise, undefined);\n    } else {\n        promise._progress(ret);\n    }\n};\n\n\nPromise.prototype._progressUnchecked = function (progressValue) {\n    var len = this._length();\n    var progress = this._progress;\n    for (var i = 0; i < len; i++) {\n        var handler = this._progressHandlerAt(i);\n        var promise = this._promiseAt(i);\n        if (!(promise instanceof Promise)) {\n            var receiver = this._receiverAt(i);\n            if (typeof handler === \"function\") {\n                handler.call(receiver, progressValue, promise);\n            } else if (receiver instanceof PromiseArray &&\n                       !receiver._isResolved()) {\n                receiver._promiseProgressed(progressValue, promise);\n            }\n            continue;\n        }\n\n        if (typeof handler === \"function\") {\n            async.invoke(this._doProgressWith, this, {\n                handler: handler,\n                promise: promise,\n                receiver: this._receiverAt(i),\n                value: progressValue\n            });\n        } else {\n            async.invoke(progress, promise, progressValue);\n        }\n    }\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/progress.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/promise.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/main/promise.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/LhFpo0\\u000a\");\n};\nvar reflect = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\n\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\n\nvar getDomain;\nif (util.isNode) {\n    getDomain = function() {\n        var ret = process.domain;\n        if (ret === undefined) ret = null;\n        return ret;\n    };\n} else {\n    getDomain = function() {\n        return null;\n    };\n}\nutil.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\nvar UNDEFINED_BINDING = {};\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar errors = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nPromise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {e: null};\nvar tryConvertToPromise = __webpack_require__(/*! ./thenables.js */ \"./node_modules/bluebird/js/main/thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    __webpack_require__(/*! ./promise_array.js */ \"./node_modules/bluebird/js/main/promise_array.js\")(Promise, INTERNAL,\n                                    tryConvertToPromise, apiRejection);\nvar CapturedTrace = __webpack_require__(/*! ./captured_trace.js */ \"./node_modules/bluebird/js/main/captured_trace.js\")();\nvar isDebugging = __webpack_require__(/*! ./debuggability.js */ \"./node_modules/bluebird/js/main/debuggability.js\")(Promise, CapturedTrace);\n /*jshint unused:false*/\nvar createContext =\n    __webpack_require__(/*! ./context.js */ \"./node_modules/bluebird/js/main/context.js\")(Promise, CapturedTrace, isDebugging);\nvar CatchFilter = __webpack_require__(/*! ./catch_filter.js */ \"./node_modules/bluebird/js/main/catch_filter.js\")(NEXT_FILTER);\nvar PromiseResolver = __webpack_require__(/*! ./promise_resolver.js */ \"./node_modules/bluebird/js/main/promise_resolver.js\");\nvar nodebackForPromise = PromiseResolver._nodebackForPromise;\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction Promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"the promise constructor requires a resolver function\\u000a\\u000a    See http://goo.gl/EC22Yn\\u000a\");\n    }\n    if (this.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/KsIlge\\u000a\");\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._progressHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settledValue = undefined;\n    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (typeof item === \"function\") {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(\n                    new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\"));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        var catchFilter = new CatchFilter(catchInstances, fn, this);\n        return this._then(undefined, catchFilter.doFilter, undefined,\n            catchFilter, undefined);\n    }\n    return this._then(undefined, fn, undefined, undefined, undefined);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflect, reflect, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject, didProgress) {\n    if (isDebugging() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject, didProgress) {\n    var promise = this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (didFulfill, didReject) {\n    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);\n};\n\nPromise.prototype.isCancellable = function () {\n    return !this.isResolved() &&\n        this._cancellable();\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = function(fn) {\n    var ret = new Promise(INTERNAL);\n    var result = tryCatch(fn)(nodebackForPromise(ret));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true, true);\n    }\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.defer = Promise.pending = function () {\n    var promise = new Promise(INTERNAL);\n    return new PromiseResolver(promise);\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        var val = ret;\n        ret = new Promise(INTERNAL);\n        ret._fulfillUnchecked(val);\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var prev = async._schedule;\n    async._schedule = fn;\n    return prev;\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    didProgress,\n    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\n    if (!haveInternalData) {\n        ret._propagateFrom(this, 4 | 1);\n        ret._captureStackTrace();\n    }\n\n    var target = this._target();\n    if (target !== this) {\n        if (receiver === undefined) receiver = this._boundTo;\n        if (!haveInternalData) ret._setIsMigrated();\n    }\n\n    var callbackIndex = target._addCallbacks(didFulfill,\n                                             didReject,\n                                             didProgress,\n                                             ret,\n                                             receiver,\n                                             getDomain());\n\n    if (target._isResolved() && !target._isSettlePromisesQueued()) {\n        async.invoke(\n            target._settlePromiseAtPostResolution, target, callbackIndex);\n    }\n\n    return ret;\n};\n\nPromise.prototype._settlePromiseAtPostResolution = function (index) {\n    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n    this._settlePromiseAt(index);\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 131071;\n};\n\nPromise.prototype._isFollowingOrFulfilledOrRejected = function () {\n    return (this._bitField & 939524096) > 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 536870912) === 536870912;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -131072) |\n        (len & 131071);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 536870912;\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 33554432;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 33554432) > 0;\n};\n\nPromise.prototype._cancellable = function () {\n    return (this._bitField & 67108864) > 0;\n};\n\nPromise.prototype._setCancellable = function () {\n    this._bitField = this._bitField | 67108864;\n};\n\nPromise.prototype._unsetCancellable = function () {\n    this._bitField = this._bitField & (~67108864);\n};\n\nPromise.prototype._setIsMigrated = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._unsetIsMigrated = function () {\n    this._bitField = this._bitField & (~4194304);\n};\n\nPromise.prototype._isMigrated = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0\n        ? this._receiver0\n        : this[\n            index * 5 - 5 + 4];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return index === 0\n        ? this._promise0\n        : this[index * 5 - 5 + 3];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return index === 0\n        ? this._fulfillmentHandler0\n        : this[index * 5 - 5 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return index === 0\n        ? this._rejectionHandler0\n        : this[index * 5 - 5 + 1];\n};\n\nPromise.prototype._boundValue = function() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n};\n\nPromise.prototype._migrateCallbacks = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var progress = follower._progressHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (promise instanceof Promise) promise._setIsMigrated();\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    progress,\n    promise,\n    receiver,\n    domain\n) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        if (receiver !== undefined) this._receiver0 = receiver;\n        if (typeof fulfill === \"function\" && !this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 =\n                domain === null ? fulfill : domain.bind(fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 =\n                domain === null ? reject : domain.bind(reject);\n        }\n        if (typeof progress === \"function\") {\n            this._progressHandler0 =\n                domain === null ? progress : domain.bind(progress);\n        }\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promise;\n        this[base + 4] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                domain === null ? fulfill : domain.bind(fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                domain === null ? reject : domain.bind(reject);\n        }\n        if (typeof progress === \"function\") {\n            this[base + 2] =\n                domain === null ? progress : domain.bind(progress);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n    if (index === 0) {\n        this._promise0 = promiseSlotValue;\n        this._receiver0 = receiver;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promiseSlotValue;\n        this[base + 4] = receiver;\n    }\n    this._setLength(index + 1);\n};\n\nPromise.prototype._proxyPromiseArray = function (promiseArray, index) {\n    this._setProxyHandlers(promiseArray, index);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false, true);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    var propagationFlags = 1 | (shouldBind ? 4 : 0);\n    this._propagateFrom(maybePromise, propagationFlags);\n    var promise = maybePromise._target();\n    if (promise._isPending()) {\n        var len = this._length();\n        for (var i = 0; i < len; ++i) {\n            promise._migrateCallbacks(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (promise._isFulfilled()) {\n        this._fulfillUnchecked(promise._value());\n    } else {\n        this._rejectUnchecked(promise._reason(),\n            promise._getCarriedStackTrace());\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, shouldNotMarkOriginatingFromRejection) {\n    if (!shouldNotMarkOriginatingFromRejection) {\n        util.markAsOriginatingFromRejection(reason);\n    }\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason, hasStack ? undefined : trace);\n};\n\nPromise.prototype._resolveFromResolver = function (resolver) {\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = tryCatch(resolver)(function(value) {\n        if (promise === null) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }, function (reason) {\n        if (promise === null) return;\n        promise._rejectCallback(reason, synchronous);\n        promise = null;\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined && r === errorObj && promise !== null) {\n        promise._rejectCallback(r.e, true, true);\n        promise = null;\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    if (promise._isRejected()) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY && !this._isRejected()) {\n        x = tryCatch(handler).apply(this._boundValue(), value);\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    promise._popContext();\n\n    if (x === errorObj || x === promise || x === NEXT_FILTER) {\n        var err = x === promise ? makeSelfResolutionError() : x.e;\n        promise._rejectCallback(err, false, true);\n    } else {\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._cleanValues = function () {\n    if (this._cancellable()) {\n        this._cancellationParent = undefined;\n    }\n};\n\nPromise.prototype._propagateFrom = function (parent, flags) {\n    if ((flags & 1) > 0 && parent._cancellable()) {\n        this._setCancellable();\n        this._cancellationParent = parent;\n    }\n    if ((flags & 4) > 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n};\n\nPromise.prototype._fulfill = function (value) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._fulfillUnchecked(value);\n};\n\nPromise.prototype._reject = function (reason, carriedStackTrace) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._rejectUnchecked(reason, carriedStackTrace);\n};\n\nPromise.prototype._settlePromiseAt = function (index) {\n    var promise = this._promiseAt(index);\n    var isPromise = promise instanceof Promise;\n\n    if (isPromise && promise._isMigrated()) {\n        promise._unsetIsMigrated();\n        return async.invoke(this._settlePromiseAt, this, index);\n    }\n    var handler = this._isFulfilled()\n        ? this._fulfillmentHandlerAt(index)\n        : this._rejectionHandlerAt(index);\n\n    var carriedStackTrace =\n        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;\n    var value = this._settledValue;\n    var receiver = this._receiverAt(index);\n    this._clearCallbackDataAtIndex(index);\n\n    if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof PromiseArray) {\n        if (!receiver._isResolved()) {\n            if (this._isFulfilled()) {\n                receiver._promiseFulfilled(value, promise);\n            }\n            else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (this._isFulfilled()) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value, carriedStackTrace);\n        }\n    }\n\n    if (index >= 4 && (index & 31) === 4)\n        async.invokeLater(this._setLength, this, 0);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    if (index === 0) {\n        if (!this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 = undefined;\n        }\n        this._rejectionHandler0 =\n        this._progressHandler0 =\n        this._receiver0 =\n        this._promise0 = undefined;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] =\n        this[base + 4] =\n        this[base + 0] =\n        this[base + 1] =\n        this[base + 2] = undefined;\n    }\n};\n\nPromise.prototype._isSettlePromisesQueued = function () {\n    return (this._bitField &\n            -1073741824) === -1073741824;\n};\n\nPromise.prototype._setSettlePromisesQueued = function () {\n    this._bitField = this._bitField | -1073741824;\n};\n\nPromise.prototype._unsetSettlePromisesQueued = function () {\n    this._bitField = this._bitField & (~-1073741824);\n};\n\nPromise.prototype._queueSettlePromises = function() {\n    async.settlePromises(this);\n    this._setSettlePromisesQueued();\n};\n\nPromise.prototype._fulfillUnchecked = function (value) {\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err, undefined);\n    }\n    this._setFulfilled();\n    this._settledValue = value;\n    this._cleanValues();\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    }\n};\n\nPromise.prototype._rejectUncheckedCheckError = function (reason) {\n    var trace = util.ensureErrorObject(reason);\n    this._rejectUnchecked(reason, trace === reason ? undefined : trace);\n};\n\nPromise.prototype._rejectUnchecked = function (reason, trace) {\n    if (reason === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err);\n    }\n    this._setRejected();\n    this._settledValue = reason;\n    this._cleanValues();\n\n    if (this._isFinal()) {\n        async.throwLater(function(e) {\n            if (\"stack\" in e) {\n                async.invokeFirst(\n                    CapturedTrace.unhandledRejection, undefined, e);\n            }\n            throw e;\n        }, trace === undefined ? reason : trace);\n        return;\n    }\n\n    if (trace !== undefined && trace !== reason) {\n        this._setCarriedStackTrace(trace);\n    }\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    this._unsetSettlePromisesQueued();\n    var len = this._length();\n    for (var i = 0; i < len; i++) {\n        this._settlePromiseAt(i);\n    }\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\n__webpack_require__(/*! ./progress.js */ \"./node_modules/bluebird/js/main/progress.js\")(Promise, PromiseArray);\n__webpack_require__(/*! ./method.js */ \"./node_modules/bluebird/js/main/method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./bind.js */ \"./node_modules/bluebird/js/main/bind.js\")(Promise, INTERNAL, tryConvertToPromise);\n__webpack_require__(/*! ./finally.js */ \"./node_modules/bluebird/js/main/finally.js\")(Promise, NEXT_FILTER, tryConvertToPromise);\n__webpack_require__(/*! ./direct_resolve.js */ \"./node_modules/bluebird/js/main/direct_resolve.js\")(Promise);\n__webpack_require__(/*! ./synchronous_inspection.js */ \"./node_modules/bluebird/js/main/synchronous_inspection.js\")(Promise);\n__webpack_require__(/*! ./join.js */ \"./node_modules/bluebird/js/main/join.js\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);\nPromise.Promise = Promise;\n__webpack_require__(/*! ./map.js */ \"./node_modules/bluebird/js/main/map.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n__webpack_require__(/*! ./cancel.js */ \"./node_modules/bluebird/js/main/cancel.js\")(Promise);\n__webpack_require__(/*! ./using.js */ \"./node_modules/bluebird/js/main/using.js\")(Promise, apiRejection, tryConvertToPromise, createContext);\n__webpack_require__(/*! ./generators.js */ \"./node_modules/bluebird/js/main/generators.js\")(Promise, apiRejection, INTERNAL, tryConvertToPromise);\n__webpack_require__(/*! ./nodeify.js */ \"./node_modules/bluebird/js/main/nodeify.js\")(Promise);\n__webpack_require__(/*! ./call_get.js */ \"./node_modules/bluebird/js/main/call_get.js\")(Promise);\n__webpack_require__(/*! ./props.js */ \"./node_modules/bluebird/js/main/props.js\")(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./race.js */ \"./node_modules/bluebird/js/main/race.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./reduce.js */ \"./node_modules/bluebird/js/main/reduce.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n__webpack_require__(/*! ./settle.js */ \"./node_modules/bluebird/js/main/settle.js\")(Promise, PromiseArray);\n__webpack_require__(/*! ./some.js */ \"./node_modules/bluebird/js/main/some.js\")(Promise, PromiseArray, apiRejection);\n__webpack_require__(/*! ./promisify.js */ \"./node_modules/bluebird/js/main/promisify.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./any.js */ \"./node_modules/bluebird/js/main/any.js\")(Promise);\n__webpack_require__(/*! ./each.js */ \"./node_modules/bluebird/js/main/each.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./timers.js */ \"./node_modules/bluebird/js/main/timers.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./filter.js */ \"./node_modules/bluebird/js/main/filter.js\")(Promise, INTERNAL);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._progressHandler0 = value;                                         \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n        p._settledValue = value;                                             \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       \n    return Promise;                                                          \n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/promise.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/promise_array.js":
/*!********************************************************!*\
  !*** ./node_modules/bluebird/js/main/promise_array.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    var parent;\n    if (values instanceof Promise) {\n        parent = values;\n        promise._propagateFrom(parent, 1 | 4);\n    }\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        this._values = values;\n        if (values._isFulfilled()) {\n            values = values._value();\n            if (!isArray(values)) {\n                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n                this.__hardReject__(err);\n                return;\n            }\n        } else if (values._isPending()) {\n            values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n            return;\n        } else {\n            this._reject(values._reason());\n            return;\n        }\n    } else if (!isArray(values)) {\n        this._promise._reject(apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\")._reason());\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var promise = this._promise;\n    for (var i = 0; i < len; ++i) {\n        var isResolved = this._isResolved();\n        var maybePromise = tryConvertToPromise(values[i], promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (isResolved) {\n                maybePromise._ignoreRejections();\n            } else if (maybePromise._isPending()) {\n                maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                this._promiseFulfilled(maybePromise._value(), i);\n            } else {\n                this._promiseRejected(maybePromise._reason(), i);\n            }\n        } else if (!isResolved) {\n            this._promiseFulfilled(maybePromise, i);\n        }\n    }\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype.__hardReject__ =\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false, true);\n};\n\nPromiseArray.prototype._promiseProgressed = function (progressValue, index) {\n    this._promise._progress({\n        index: index,\n        value: progressValue\n    });\n};\n\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nPromiseArray.prototype._promiseRejected = function (reason, index) {\n    this._totalResolved++;\n    this._reject(reason);\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/promise_array.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/promise_resolver.js":
/*!***********************************************************!*\
  !*** ./node_modules/bluebird/js/main/promise_resolver.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\");\nvar TimeoutError = errors.TimeoutError;\nvar OperationalError = errors.OperationalError;\nvar haveGetters = util.haveGetters;\nvar es5 = __webpack_require__(/*! ./es5.js */ \"./node_modules/bluebird/js/main/es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise) {\n    return function(err, value) {\n        if (promise === null) return;\n\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (arguments.length > 2) {\n            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n            promise._fulfill(args);\n        } else {\n            promise._fulfill(value);\n        }\n\n        promise = null;\n    };\n}\n\n\nvar PromiseResolver;\nif (!haveGetters) {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n        this.asCallback = nodebackForPromise(promise);\n        this.callback = this.asCallback;\n    };\n}\nelse {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n    };\n}\nif (haveGetters) {\n    var prop = {\n        get: function() {\n            return nodebackForPromise(this.promise);\n        }\n    };\n    es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n    es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n}\n\nPromiseResolver._nodebackForPromise = nodebackForPromise;\n\nPromiseResolver.prototype.toString = function () {\n    return \"[object PromiseResolver]\";\n};\n\nPromiseResolver.prototype.resolve =\nPromiseResolver.prototype.fulfill = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._resolveCallback(value);\n};\n\nPromiseResolver.prototype.reject = function (reason) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._rejectCallback(reason);\n};\n\nPromiseResolver.prototype.progress = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._progress(value);\n};\n\nPromiseResolver.prototype.cancel = function (err) {\n    this.promise.cancel(err);\n};\n\nPromiseResolver.prototype.timeout = function () {\n    this.reject(new TimeoutError(\"timeout\"));\n};\n\nPromiseResolver.prototype.isResolved = function () {\n    return this.promise.isResolved();\n};\n\nPromiseResolver.prototype.toJSON = function () {\n    return this.promise.toJSON();\n};\n\nmodule.exports = PromiseResolver;\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/promise_resolver.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/promisify.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/main/promisify.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar nodebackForPromise = __webpack_require__(/*! ./promise_resolver.js */ \"./node_modules/bluebird/js/main/promise_resolver.js\")\n    ._nodebackForPromise;\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/main/errors.js\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/iWrZbw\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\"'use strict';                            \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise);                      \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n        \"\n        .replace(\"Parameters\", parameterDeclaration(newParameterCount))\n        .replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode))(\n            Promise,\n            fn,\n            receiver,\n            withAppended,\n            maybeWrapAsError,\n            nodebackForPromise,\n            util.tryCatch,\n            util.errorObj,\n            util.notEnumerableProp,\n            INTERNAL\n        );\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key, fn, suffix);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver) {\n    return makeNodePromisified(callback, receiver, undefined, callback);\n}\n\nPromise.promisify = function (fn, receiver) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/9ITlV0\\u000a\");\n    }\n    options = Object(options);\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/8FZo5V\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier);\n            promisifyAll(value, suffix, filter, promisifier);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier);\n};\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/promisify.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/props.js":
/*!************************************************!*\
  !*** ./node_modules/bluebird/js/main/props.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar isObject = util.isObject;\nvar es5 = __webpack_require__(/*! ./es5.js */ \"./node_modules/bluebird/js/main/es5.js\");\n\nfunction PropertiesPromiseArray(obj) {\n    var keys = es5.keys(obj);\n    var len = keys.length;\n    var values = new Array(len * 2);\n    for (var i = 0; i < len; ++i) {\n        var key = keys[i];\n        values[i] = obj[key];\n        values[i + len] = key;\n    }\n    this.constructor$(values);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {\n    this._init$(undefined, -3) ;\n};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val = {};\n        var keyOffset = this.length();\n        for (var i = 0, len = this.length(); i < len; ++i) {\n            val[this._values[i + keyOffset]] = this._values[i];\n        }\n        this._resolve(val);\n    }\n};\n\nPropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {\n    this._promise._progress({\n        key: this._values[index + this.length()],\n        value: value\n    });\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/OsFKC8\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 4);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/props.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/queue.js":
/*!************************************************!*\
  !*** ./node_modules/bluebird/js/main/queue.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype._unshiftOne = function(value) {\n    var capacity = this._capacity;\n    this._checkCapacity(this.length() + 1);\n    var front = this._front;\n    var i = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = value;\n    this._front = i;\n    this._length = this.length() + 1;\n};\n\nQueue.prototype.unshift = function(fn, receiver, arg) {\n    this._unshiftOne(arg);\n    this._unshiftOne(receiver);\n    this._unshiftOne(fn);\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/queue.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/race.js":
/*!***********************************************!*\
  !*** ./node_modules/bluebird/js/main/race.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar isArray = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\").isArray;\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else if (!isArray(promises)) {\n        return apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 4 | 1);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/race.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/reduce.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/reduce.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar getDomain = Promise._getDomain;\nvar async = __webpack_require__(/*! ./async.js */ \"./node_modules/bluebird/js/main/async.js\");\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nfunction ReductionPromiseArray(promises, fn, accum, _each) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    this._preservedValues = _each === INTERNAL ? [] : null;\n    this._zerothIsAccum = (accum === undefined);\n    this._gotAccum = false;\n    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);\n    this._valuesPhase = undefined;\n    var maybePromise = tryConvertToPromise(accum, this._promise);\n    var rejected = false;\n    var isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        maybePromise = maybePromise._target();\n        if (maybePromise._isPending()) {\n            maybePromise._proxyPromiseArray(this, -1);\n        } else if (maybePromise._isFulfilled()) {\n            accum = maybePromise._value();\n            this._gotAccum = true;\n        } else {\n            this._reject(maybePromise._reason());\n            rejected = true;\n        }\n    }\n    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n    var domain = getDomain();\n    this._callback = domain === null ? fn : domain.bind(fn);\n    this._accum = accum;\n    if (!rejected) async.invoke(init, this, undefined);\n}\nfunction init() {\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._init = function () {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function () {\n    if (this._gotAccum || this._zerothIsAccum) {\n        this._resolve(this._preservedValues !== null\n                        ? [] : this._accum);\n    }\n};\n\nReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    values[index] = value;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var isEach = preservedValues !== null;\n    var gotAccum = this._gotAccum;\n    var valuesPhase = this._valuesPhase;\n    var valuesPhaseIndex;\n    if (!valuesPhase) {\n        valuesPhase = this._valuesPhase = new Array(length);\n        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {\n            valuesPhase[valuesPhaseIndex] = 0;\n        }\n    }\n    valuesPhaseIndex = valuesPhase[index];\n\n    if (index === 0 && this._zerothIsAccum) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n        valuesPhase[index] = ((valuesPhaseIndex === 0)\n            ? 1 : 2);\n    } else if (index === -1) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n    } else {\n        if (valuesPhaseIndex === 0) {\n            valuesPhase[index] = 1;\n        } else {\n            valuesPhase[index] = 2;\n            this._accum = value;\n        }\n    }\n    if (!gotAccum) return;\n\n    var callback = this._callback;\n    var receiver = this._promise._boundValue();\n    var ret;\n\n    for (var i = this._reducingIndex; i < length; ++i) {\n        valuesPhaseIndex = valuesPhase[i];\n        if (valuesPhaseIndex === 2) {\n            this._reducingIndex = i + 1;\n            continue;\n        }\n        if (valuesPhaseIndex !== 1) return;\n        value = values[i];\n        this._promise._pushContext();\n        if (isEach) {\n            preservedValues.push(value);\n            ret = tryCatch(callback).call(receiver, value, i, length);\n        }\n        else {\n            ret = tryCatch(callback)\n                .call(receiver, this._accum, value, i, length);\n        }\n        this._promise._popContext();\n\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                valuesPhase[i] = 4;\n                return maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n\n        this._reducingIndex = i + 1;\n        this._accum = ret;\n    }\n\n    this._resolve(isEach ? preservedValues : this._accum);\n};\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/reduce.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/schedule.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/main/schedule.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar schedule;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/main/util.js\");\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n};\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            window.navigator.standalone)) {\n    schedule = function(fn) {\n        var div = document.createElement(\"div\");\n        var observer = new MutationObserver(fn);\n        observer.observe(div, {attributes: true});\n        return function() { div.classList.toggle(\"foo\"); };\n    };\n    schedule.isStatic = true;\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/schedule.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/settle.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/settle.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\n    function(Promise, PromiseArray) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 268435456;\n    ret._settledValue = value;\n    this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 134217728;\n    ret._settledValue = reason;\n    this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return new SettledPromiseArray(this).promise();\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/settle.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/some.js":
/*!***********************************************!*\
  !*** ./node_modules/bluebird/js/main/some.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar RangeError = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\").RangeError;\nvar AggregateError = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\").AggregateError;\nvar isArray = util.isArray;\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n    }\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            e.push(this._values[i]);\n        }\n        this._reject(e);\n    }\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/1wAmHx\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/some.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/synchronous_inspection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bluebird/js/main/synchronous_inspection.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValue = promise._settledValue;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValue = undefined;\n    }\n}\n\nPromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.isFulfilled =\nPromise.prototype._isFulfilled = function () {\n    return (this._bitField & 268435456) > 0;\n};\n\nPromiseInspection.prototype.isRejected =\nPromise.prototype._isRejected = function () {\n    return (this._bitField & 134217728) > 0;\n};\n\nPromiseInspection.prototype.isPending =\nPromise.prototype._isPending = function () {\n    return (this._bitField & 402653184) === 0;\n};\n\nPromiseInspection.prototype.isResolved =\nPromise.prototype._isResolved = function () {\n    return (this._bitField & 402653184) > 0;\n};\n\nPromise.prototype.isPending = function() {\n    return this._target()._isPending();\n};\n\nPromise.prototype.isRejected = function() {\n    return this._target()._isRejected();\n};\n\nPromise.prototype.isFulfilled = function() {\n    return this._target()._isFulfilled();\n};\n\nPromise.prototype.isResolved = function() {\n    return this._target()._isResolved();\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue;\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue;\n};\n\nPromise.prototype.value = function() {\n    var target = this._target();\n    if (!target.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return target._settledValue;\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    if (!target.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    target._unsetRejectionIsUnhandled();\n    return target._settledValue;\n};\n\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/synchronous_inspection.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/thenables.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/main/thenables.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) {\n            return obj;\n        }\n        else if (isAnyBluebirdPromise(obj)) {\n            var ret = new Promise(INTERNAL);\n            obj._then(\n                ret._fulfillUnchecked,\n                ret._rejectUncheckedCheckError,\n                ret._progressUnchecked,\n                ret,\n                null\n            );\n            return ret;\n        }\n        var then = util.tryCatch(getThen)(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction getThen(obj) {\n    return obj.then;\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    return hasProp.call(obj, \"_promise0\");\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x,\n                                        resolveFromThenable,\n                                        rejectFromThenable,\n                                        progressFromThenable);\n    synchronous = false;\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolveFromThenable(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function rejectFromThenable(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n\n    function progressFromThenable(value) {\n        if (!promise) return;\n        if (typeof promise._progress === \"function\") {\n            promise._progress(value);\n        }\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/thenables.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/timers.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/main/timers.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nvar afterTimeout = function (promise, message) {\n    if (!promise.isPending()) return;\n    \n    var err;\n    if(!util.isPrimitive(message) && (message instanceof Error)) {\n        err = message;\n    } else {\n        if (typeof message !== \"string\") {\n            message = \"operation timed out\";\n        }\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._cancel(err);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (value, ms) {\n    if (ms === undefined) {\n        ms = value;\n        value = undefined;\n        var ret = new Promise(INTERNAL);\n        setTimeout(function() { ret._fulfill(); }, ms);\n        return ret;\n    }\n    ms = +ms;\n    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(this, ms);\n};\n\nfunction successClear(value) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret = this.then().cancellable();\n    ret._cancellationParent = this;\n    var handle = setTimeout(function timeoutTimeout() {\n        afterTimeout(ret, message);\n    }, ms);\n    return ret._then(successClear, failureClear, undefined, handle, undefined);\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/timers.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/using.js":
/*!************************************************!*\
  !*** ./node_modules/bluebird/js/main/using.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext) {\n    var TypeError = __webpack_require__(/*! ./errors.js */ \"./node_modules/bluebird/js/main/errors.js\").TypeError;\n    var inherits = __webpack_require__(/*! ./util.js */ \"./node_modules/bluebird/js/main/util.js\").inherits;\n    var PromiseInspection = Promise.PromiseInspection;\n\n    function inspectionMapper(inspections) {\n        var len = inspections.length;\n        for (var i = 0; i < len; ++i) {\n            var inspection = inspections[i];\n            if (inspection.isRejected()) {\n                return Promise.reject(inspection.error());\n            }\n            inspections[i] = inspection._settledValue;\n        }\n        return inspections;\n    }\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = Promise.defer();\n        function iterator() {\n            if (i >= len) return ret.resolve();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret.promise;\n    }\n\n    function disposerSuccess(value) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = value;\n        inspection._bitField = 268435456;\n        return dispose(this, inspection).thenReturn(value);\n    }\n\n    function disposerFail(reason) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = reason;\n        inspection._bitField = 134217728;\n        return dispose(this, inspection).thenThrow(reason);\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return null;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== null\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var promise = Promise.settle(resources)\n            .then(inspectionMapper)\n            .then(function(vals) {\n                promise._pushContext();\n                var ret;\n                try {\n                    ret = spreadArgs\n                        ? fn.apply(undefined, vals) : fn.call(undefined,  vals);\n                } finally {\n                    promise._popContext();\n                }\n                return ret;\n            })\n            ._then(\n                disposerSuccess, disposerFail, undefined, resources, undefined);\n        resources.promise = promise;\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 262144;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 262144) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~262144);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/using.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/main/util.js":
/*!***********************************************!*\
  !*** ./node_modules/bluebird/js/main/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5.js */ \"./node_modules/bluebird/js/main/es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\nvar haveGetters = (function(){\n    try {\n        var o = {};\n        es5.defineProperty(o, \"f\", {\n            get: function () {\n                return 3;\n            }\n        });\n        return o.f === 3;\n    }\n    catch (e) {\n        return false;\n    }\n\n})();\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return !isPrimitive(value);\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function f() {}\n    f.prototype = obj;\n    var l = 8;\n    while (l--) new f();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return obj instanceof Error && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    haveGetters: haveGetters,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    hasDevTools: typeof chrome !== \"undefined\" && chrome &&\n                 typeof chrome.loadTimes === \"function\",\n    isNode: typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\"\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version = process.versions.node.split(\".\").map(Number);\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n\n\n//# sourceURL=webpack:///./node_modules/bluebird/js/main/util.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/connection.js":
/*!******************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/connection.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var net = __webpack_require__(/*! net */ \"net\");\nvar tls = __webpack_require__(/*! tls */ \"tls\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar Err = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/error.js */ \"./node_modules/rethinkdbdash/lib/error.js\");\nvar Cursor = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/cursor.js */ \"./node_modules/rethinkdbdash/lib/cursor.js\");\nvar ReadableStream = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/stream.js */ \"./node_modules/rethinkdbdash/lib/stream.js\");\nvar Metadata = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/metadata.js */ \"./node_modules/rethinkdbdash/lib/metadata.js\");\n\nvar protodef = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/protodef.js */ \"./node_modules/rethinkdbdash/lib/protodef.js\");\nvar responseTypes = protodef.Response.ResponseType;\n\n// We'll ping a connection using this special value.\nvar PING_VALUE = \"__rethinkdbdash_ping__\";\n\nvar PROTOCOL_VERSION = 0;\nvar AUTHENTIFICATION_METHOD = \"SCRAM-SHA-256\";\nvar KEY_LENGTH = 32; // Because we are currently using SHA 256\nvar NULL_BUFFER = new Buffer('\\0', \"binary\");\nvar CACHE_PBKDF2 = {};\n\nfunction Connection(r, options, resolve, reject) {\n  var self = this;\n  this.r = r;\n  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.\n\n  // Set default options - We have to save them in case the user tries to reconnect\n  if (!helper.isPlainObject(options)) options = {};\n  this.host = options.host || r._host;\n  this.port = options.port || r._port;\n  if (options.authKey != null) {\n    if (options.user != null || options.password != null) {\n      throw new Err.ReqlDriverError('Cannot use both authKey and password');\n    }\n    this.user = r._user;\n    this.password = options.authKey;\n  } else {\n    if (options.user === undefined) {\n      this.user = r._user;\n    } else {\n      this.user = options.user;\n    }\n    if (options.password === undefined) {\n      this.password = r._password;\n    } else {\n      this.password = options.password;\n    }\n  }\n\n  this.authKey = options.authKey || r._authKey;\n  // period in *seconds* for the connection to be opened\n  this.timeoutConnect = options.timeout || r._timeoutConnect;\n  // The connection will be pinged every <pingInterval> seconds\n  this.pingInterval = options.pingInterval || r._pingInterval;\n\n  if (options.db) this.db = options.db; // Pass to each query\n\n  this.token = 1;\n  this.buffer = new Buffer(0);\n\n  this.metadata = {}\n\n  this.open = false; // true only if the user can write on the socket\n  this.timeout = null;\n\n  if (options.connection) {\n    this.connection = options.connection;\n  }\n  else {\n    var family = 'IPv4';\n    if (net.isIPv6(self.host)) {\n      family = 'IPv6';\n    }\n\n    var connectionArgs = {\n      host: self.host,\n      port: self.port,\n      family: family\n    }\n\n    var tlsOptions = options.ssl || false;\n    if (tlsOptions === false) {\n      self.connection = net.connect(connectionArgs);\n    } else {\n      if (helper.isPlainObject(tlsOptions)) {\n        // Copy the TLS options in connectionArgs\n        helper.loopKeys(tlsOptions, function(tlsOptions, key) {\n          connectionArgs[key] = tlsOptions[key];\n        });\n      }\n      self.connection = tls.connect(connectionArgs);\n    }\n  }\n\n  self.connection.setKeepAlive(true);\n\n  self.timeoutOpen = setTimeout(function() {\n    self.connection.end(); // Send a FIN packet\n    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+self.timeoutConnect+'s').setOperational());\n  }, self.timeoutConnect*1000);\n\n  self.connection.on('end', function() {\n    self.open = false;\n    self.emit('end');\n    // We got a FIN packet, so we'll just flush\n    self._flush();\n  });\n  self.connection.on('close', function() {\n    // We emit end or close just once\n    clearTimeout(self.timeoutOpen)\n    clearInterval(self.pingIntervalId);\n    self.connection.removeAllListeners();\n    self.open = false;\n    self.emit('closed');\n    // The connection is fully closed, flush (in case 'end' was not triggered)\n    self._flush();\n  });\n  self.connection.setNoDelay();\n  self.connection.once('error', function(error) {\n    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\\nFull error:\\n'+JSON.stringify(error)).setOperational());\n  });\n  self.connection.on('connect', function() {\n    self.connection.removeAllListeners('error');\n    self.connection.on('error', function(error) {\n      self.emit('error', error);\n    });\n\n    var versionBuffer = new Buffer(4)\n    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)\n\n    self.randomString = new Buffer(crypto.randomBytes(18)).toString('base64')\n    var authBuffer = new Buffer(JSON.stringify({\n      protocol_version: PROTOCOL_VERSION,\n      authentication_method: AUTHENTIFICATION_METHOD,\n      authentication: \"n,,n=\" + self.user + \",r=\" + self.randomString\n    }));\n\n    helper.tryCatch(function() {\n      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));\n    }, function(err) {\n      // The TCP connection is open, but the ReQL connection wasn't established.\n      // We can just abort the whole thing\n      self.open = false;\n      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());\n    });\n  });\n  self.connection.once('end', function() {\n    self.open = false;\n  });\n\n  self.connection.on('data', function(buffer) {\n    if (self.state === -1) {\n      // This is an error state\n      return;\n    }\n    self.buffer = Buffer.concat([self.buffer, buffer]);\n\n    if (self.open == false) {\n      for(var i=0; i<self.buffer.length; i++) {\n        if (self.buffer[i] === 0) {\n          var messageServerStr = self.buffer.slice(0, i).toString();\n          self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte\n          try {\n            var messageServer = JSON.parse(messageServerStr);\n          } catch(error) {\n            self._abort();\n            reject(new Err.ReqlDriverError('Could not parse the message sent by the server : \\''+messageServerStr+'\\'').setOperational());\n            return;\n          }\n          if (messageServer.success !== true) {\n            self._abort();\n            reject(new Err.ReqlDriverError('Error '+messageServer.error_code+':'+messageServer.error).setOperational());\n            return;\n          }\n\n          if (self.state === 0) {\n            self._checkProtocolVersion(messageServer, reject);\n          } else if (self.state === 1) {\n            // Compute salt and send the proof\n            self._computeSaltedPassword(messageServer, reject);\n          } else if (self.state === 2) {\n            self._compareDigest(messageServer, resolve, reject);\n          }\n        }\n      }\n    }\n    else {\n      while(self.buffer.length >= 12) {\n        var token = self.buffer.readUInt32LE(0) + 0x100000000 * self.buffer.readUInt32LE(4);\n        var responseLength = self.buffer.readUInt32LE(8);\n\n        if (self.buffer.length < 12+responseLength) break;\n\n        var responseBuffer = self.buffer.slice(12, 12+responseLength);\n        var response = JSON.parse(responseBuffer);\n\n        self._processResponse(response, token);\n\n        self.buffer = self.buffer.slice(12+responseLength);\n      }\n    }\n  });\n\n  self.connection.on('timeout', function(buffer) {\n    self.connection.open = false;\n    self.emit('timeout');\n  })\n  self.connection.toJSON = function() { // We want people to be able to jsonify a cursor\n    return '\"A socket object cannot be converted to JSON due to circular references.\"'\n  }\n}\n\nutil.inherits(Connection, events.EventEmitter);\n\nConnection.prototype._checkProtocolVersion = function(messageServer, reject) {\n  // Expect max_protocol_version, min_protocol_version, server_version, success\n  var minVersion = messageServer.min_protocol_version\n  var maxVersion = messageServer.max_protocol_version\n\n  if (minVersion > PROTOCOL_VERSION || maxVersion < PROTOCOL_VERSION) {\n    this._abort();\n    reject(new Err.ReqlDriverError('Unsupported protocol version: '+PROTOCOL_VERSION+', expected between '+minVersion+' and '+ maxVersion).setOperational());\n  }\n  this.state = 1;\n};\n\nConnection.prototype._computeSaltedPassword = function(messageServer, reject) {\n  var self = this;\n  var authentication = helper.splitCommaEqual(messageServer.authentication);\n\n  var randomNonce = authentication.r\n  var salt = new Buffer(authentication.s, 'base64')\n  var iterations = parseInt(authentication.i)\n\n  if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {\n    self._abort();\n    reject(new Err.ReqlDriverError('Invalid nonce from server').setOperational());\n  }\n\n  // The salt is constant, so we can cache the salted password.\n  var cacheKey = self.password.toString(\"base64\")+','+salt.toString(\"base64\")+','+iterations;\n  if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {\n    helper.tryCatch(function() {\n      self._sendProof(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);\n    }, function(err) {\n      // The TCP connection is open, but the ReQL connection wasn't established.\n      // We can just abort the whole thing\n      self.open = false;\n      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());\n    });\n  } else {\n    crypto.pbkdf2(self.password, salt, iterations, KEY_LENGTH, \"sha256\", function(error, saltedPassword) {\n      if (error != null) {\n        self._abort();\n        reject(new Err.ReqlDriverError('Could not derive the key. Error:' + error.toString()).setOperational());\n      }\n      CACHE_PBKDF2[cacheKey] = saltedPassword;\n      helper.tryCatch(function() {\n        self._sendProof(messageServer.authentication, randomNonce, saltedPassword);\n      }, function(err) {\n        // The TCP connection is open, but the ReQL connection wasn't established.\n        // We can just abort the whole thing\n        self.open = false;\n        reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());\n      });\n    })\n  }\n}\n\nConnection.prototype._sendProof = function(authentication, randomNonce, saltedPassword) {\n  var clientFinalMessageWithoutProof = \"c=biws,r=\" + randomNonce;\n  var clientKey = crypto.createHmac(\"sha256\", saltedPassword).update(\"Client Key\").digest()\n  var storedKey = crypto.createHash(\"sha256\").update(clientKey).digest()\n\n  var authMessage =\n      \"n=\" + this.user + \",r=\" + this.randomString + \",\" +\n      authentication + \",\" +\n      clientFinalMessageWithoutProof\n\n  var clientSignature = crypto.createHmac(\"sha256\", storedKey).update(authMessage).digest()\n  var clientProof = helper.xorBuffer(clientKey, clientSignature)\n\n  var serverKey = crypto.createHmac(\"sha256\", saltedPassword).update(\"Server Key\").digest()\n  this.serverSignature = crypto.createHmac(\"sha256\", serverKey).update(authMessage).digest()\n\n  this.state = 2\n  var message = JSON.stringify({\n    authentication: clientFinalMessageWithoutProof + \",p=\" + clientProof.toString(\"base64\")\n  })\n  this.connection.write(Buffer.concat([new Buffer(message.toString()), NULL_BUFFER]))\n}\n\nConnection.prototype._compareDigest = function(messageServer, resolve, reject) {\n  var self = this;\n  var firstEquals = messageServer.authentication.indexOf('=')\n  var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)\n\n  if (!helper.compareDigest(serverSignatureValue, self.serverSignature.toString(\"base64\"))) {\n    reject(new Err.ReqlDriverError('Invalid server signature').setOperational());\n  }\n\n  self.state = 4\n  self.connection.removeAllListeners('error');\n  self.open = true;\n  self.connection.on('error', function(e) {\n    self.open = false;\n  });\n  clearTimeout(self.timeoutOpen)\n  resolve(self);\n  if (self.pingInterval > 0) {\n    self.pingIntervalId = setInterval(function() {\n      self.pendingPing = true;\n      self.r.error(PING_VALUE).run(self).error(function(error) {\n        self.pendingPing = false;\n        if (error.message !== PING_VALUE) {\n          self.emit('error', new Err.ReqlDriverError(\n                'Could not ping the connection').setOperational());\n          self.open = false;\n          self.connection.end();\n        } else {\n        }\n      });\n    }, self.pingInterval*1000);\n  }\n}\n\nConnection.prototype._abort = function() {\n  this.state = -1;\n  this.removeAllListeners();\n  this.close();\n}\n\nConnection.prototype._processResponse = function(response, token) {\n  //console.log('Connection.prototype._processResponse: '+token);\n  //console.log(JSON.stringify(response, null, 2));\n  var self = this;\n\n  var type = response.t;\n  var result;\n  var cursor;\n  var stream;\n  var currentResolve, currentReject;\n  var datum;\n  var options;\n\n  if (type === responseTypes.COMPILE_ERROR) {\n    self.emit('release');\n    if (typeof self.metadata[token].reject === 'function') {\n      self.metadata[token].reject(new Err.ReqlCompileError(helper.makeAtom(response), self.metadata[token].query, response));\n    }\n\n    delete self.metadata[token]\n  }\n  else if (type === responseTypes.CLIENT_ERROR) {\n    self.emit('release');\n\n    if (typeof self.metadata[token].reject === 'function') {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n      self.metadata[token].removeCallbacks();\n      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));\n      if (typeof self.metadata[token].endReject !== 'function') {\n        // No pending STOP query, we can delete\n        delete self.metadata[token]\n      }\n    }\n    else if (typeof self.metadata[token].endResolve === 'function') {\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      self.metadata[token].removeEndCallbacks();\n      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));\n      delete self.metadata[token]\n    }\n    else if (token === -1) { // This should not happen now since 1.13 took the token out of the query\n      var error = new Err.ReqlClientError(helper.makeAtom(response)+'\\nClosing all outstanding queries...');\n      self.emit('error', error);\n      // We don't want a function to yield forever, so we just reject everything\n      helper.loopKeys(self.rejectMap, function(rejectMap, key) {\n        rejectMap[key](error);\n      });\n      self.close();\n      delete self.metadata[token]\n    }\n  }\n  else if (type === responseTypes.RUNTIME_ERROR) {\n    var errorValue = helper.makeAtom(response);\n    var error;\n    // We don't want to release a connection if we just pinged it.\n    if (self.pendingPing === false || (errorValue !== PING_VALUE)) {\n      self.emit('release');\n      error = new Err.ReqlRuntimeError(errorValue, self.metadata[token].query, response);\n    } else {\n      error = new Err.ReqlRuntimeError(errorValue);\n    }\n\n    if (typeof self.metadata[token].reject === 'function') {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n      self.metadata[token].removeCallbacks();\n      error.setName(response.e);\n      currentReject(error);\n      if (typeof self.metadata[token].endReject !== 'function') {\n        // No pending STOP query, we can delete\n        delete self.metadata[token]\n      }\n    }\n    else if (typeof self.metadata[token].endResolve === 'function') {\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      self.metadata[token].removeEndCallbacks();\n      delete self.metadata[token]\n    }\n  }\n  else if (type === responseTypes.SUCCESS_ATOM) {\n    self.emit('release');\n    // self.metadata[token].resolve is always a function\n    datum = helper.makeAtom(response, self.metadata[token].options);\n\n    if ((Array.isArray(datum)) &&\n        ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true)))) {\n      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');\n      if (self.metadata[token].options.profile === true) {\n        self.metadata[token].resolve({\n          profile: response.p,\n          result: cursor\n        });\n      }\n      else {\n        self.metadata[token].resolve(cursor);\n      }\n\n      cursor._push({done: true, response: { r: datum }});\n    }\n    else if ((Array.isArray(datum)) &&\n        ((self.metadata[token].options.stream === true || self.r._options.stream === true))) {\n      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');\n      stream = new ReadableStream({}, cursor);\n      if (self.metadata[token].options.profile === true) {\n        self.metadata[token].resolve({\n          profile: response.p,\n          result: stream \n        });\n      }\n      else {\n        self.metadata[token].resolve(stream);\n      }\n      cursor._push({done: true, response: { r: datum }});\n    }\n    else {\n      if (self.metadata[token].options.profile === true) {\n        result = {\n          profile: response.p,\n          result: cursor || datum\n        }\n      }\n      else {\n        result = datum;\n      }\n      self.metadata[token].resolve(result);\n    }\n\n    delete self.metadata[token];\n  }\n  else if (type === responseTypes.SUCCESS_PARTIAL) {\n    // We save the current resolve function because we are going to call cursor._fetch before resuming the user's yield\n    var done = false;\n    if (typeof self.metadata[token].resolve !== 'function') {\n      // According to issues/190, we can get a SUCESS_COMPLETE followed by a\n      // SUCCESS_PARTIAL when closing an feed. So resolve/reject will be undefined\n      // in this case.\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      if (typeof currentResolve === 'function') {\n        done = true;\n      }\n    }\n    else {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n    }\n\n    // We need to delete before calling cursor._push\n    self.metadata[token].removeCallbacks();\n\n    if (!self.metadata[token].cursor) { //No cursor, let's create one\n      self.metadata[token].cursor = true;\n\n      var typeResult = 'Cursor';\n      var includesStates = false;;\n      if (Array.isArray(response.n)) {\n        for(var i=0; i<response.n.length; i++) {\n          if (response.n[i] === protodef.Response.ResponseNote.SEQUENCE_FEED) {\n            typeResult = 'Feed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.ATOM_FEED) {\n            typeResult = 'AtomFeed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.ORDER_BY_LIMIT_FEED) {\n            typeResult = 'OrderByLimitFeed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.UNIONED_FEED) {\n            typeResult = 'UnionedFeed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.INCLUDES_STATES) {\n            includesStates = true;\n          }\n          else {\n            currentReject(new Err.ReqlDriverError('Unknown ResponseNote '+response.n[i]+', the driver is probably out of date.').setOperational());\n            return;\n          }\n        }\n      }\n      cursor = new Cursor(self, token, self.metadata[token].options, typeResult);\n      if (includesStates === true) {\n        cursor.setIncludesStates();\n      }\n      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {\n        // Return a cursor\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: cursor\n          });\n        }\n        else {\n          currentResolve(cursor);\n        }\n      }\n      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {\n        stream = new ReadableStream({}, cursor);\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: stream \n          });\n        }\n        else {\n          currentResolve(stream);\n        }\n      }\n      else if (typeResult !== 'Cursor') {\n        // Return a feed\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: cursor\n          });\n        }\n        else {\n          currentResolve(cursor);\n        }\n      }\n      else {\n        // When we get SUCCESS_SEQUENCE, we will delete self.metadata[token].options\n        // So we keep a reference of it here\n        options = self.metadata[token].options;\n\n        // Fetch everything and return an array\n        cursor.toArray().then(function(result) {\n          if (options.profile === true) {\n            currentResolve({\n              profile: response.p,\n              result: result\n            });\n          }\n          else {\n            currentResolve(result);\n          }\n        }).error(currentReject)\n      }\n      cursor._push({done: false, response: response});\n    }\n    else { // That was a continue query\n      currentResolve({done: done, response: response});\n    }\n  }\n  else if (type === responseTypes.SUCCESS_SEQUENCE) {\n    self.emit('release');\n\n    if (typeof self.metadata[token].resolve === 'function') {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n      self.metadata[token].removeCallbacks();\n    }\n    else if (typeof self.metadata[token].endResolve === 'function') {\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      self.metadata[token].removeEndCallbacks();\n    }\n\n    if (!self.metadata[token].cursor) { // No cursor, let's create one\n      cursor = new Cursor(self, token, self.metadata[token].options, 'Cursor');\n\n      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: cursor\n          });\n        }\n        else {\n          currentResolve(cursor);\n        }\n\n        // We need to keep the options in the else statement, so we clean it inside the if/else blocks\n        if (typeof self.metadata[token].endResolve !== 'function') {\n          delete self.metadata[token];\n        }\n      }\n      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {\n        stream = new ReadableStream({}, cursor);\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: stream\n          });\n        }\n        else {\n          currentResolve(stream);\n        }\n\n        // We need to keep the options in the else statement,\n        // so we clean it inside the if/else blocks (the one looking \n        // if a cursor was already created)\n        if (typeof self.metadata[token].endResolve !== 'function') {\n          // We do not want to delete the metadata if there is an END query waiting\n          delete self.metadata[token];\n        }\n\n      }\n      else {\n        cursor.toArray().then(function(result) {\n          if (self.metadata[token].options.profile === true) {\n            currentResolve({\n              profile: response.p,\n              result: result\n            });\n          }\n          else {\n            currentResolve(result);\n          }\n          if (typeof self.metadata[token].endResolve !== 'function') {\n            delete self.metadata[token];\n          }\n\n        }).error(currentReject)\n      }\n      done = true;\n      cursor._push({done: true, response: response});\n    }\n    else { // That was a continue query\n      // If there is a pending STOP query we do not want to close the cursor yet\n      done = true;\n      if (typeof self.metadata[token].endResolve === 'function') {\n        done = false;\n      }\n      currentResolve({done: done, response: response});\n    }\n  }\n  else if (type === responseTypes.WAIT_COMPLETE) {\n    self.emit('release');\n    self.metadata[token].resolve();\n\n    delete self.metadata[token];\n  }\n  else if (type === responseTypes.SERVER_INFO) {\n    self.emit('release');\n    datum = helper.makeAtom(response, self.metadata[token].options);\n    self.metadata[token].resolve(datum);\n    delete self.metadata[token];\n  }\n}\n\nConnection.prototype.reconnect = function(options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (!helper.isPlainObject(options)) options = {};\n\n  if (options.noreplyWait === true) {\n    var p = new Promise(function(resolve, reject) {\n      self.close(options).then(function() {\n        self.r.connect({\n          host: self.host,\n          port: self.port,\n          authKey: self.authKey,\n          db: self.db\n        }).then(function(c) {\n          resolve(c);\n        }).error(function(e) {\n          reject(e);\n        });\n      }).error(function(e) {\n        reject(e)\n      })\n    }).nodeify(callback);\n  }\n  else {\n    return self.r.connect({\n      host: self.host,\n      port: self.port,\n      authKey: self.authKey,\n      db: self.db\n    }, callback);\n  }\n\n  return p;\n}\n\nConnection.prototype._send = function(query, token, resolve, reject, originalQuery, options, end) {\n  //console.log('Connection.prototype._send: '+token);\n  //console.log(JSON.stringify(query, null, 2));\n\n  var self = this;\n  if (self.open === false) {\n    var err = new Err.ReqlDriverError('The connection was closed by the other party');\n    err.setOperational();\n    reject(err);\n    return;\n  }\n\n  var queryStr = JSON.stringify(query);\n  var querySize = Buffer.byteLength(queryStr);\n\n  var buffer = new Buffer(8+4+querySize);\n  buffer.writeUInt32LE(token & 0xFFFFFFFF, 0)\n  buffer.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)\n\n  buffer.writeUInt32LE(querySize, 8);\n\n  buffer.write(queryStr, 12);\n\n  // noreply instead of noReply because the otpions are translated for the server\n  if ((!helper.isPlainObject(options)) || (options.noreply != true)) {\n    if (!self.metadata[token]) {\n      self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);\n    }\n    else if (end === true) {\n      self.metadata[token].setEnd(resolve, reject);\n    }\n    else {\n      self.metadata[token].setCallbacks(resolve, reject);\n    }\n  }\n  else {\n    if (typeof resolve === 'function') resolve();\n    this.emit('release');\n  }\n\n  // This will emit an error if the connection is closed\n  helper.tryCatch(function() {\n    self.connection.write(buffer);\n  }, function(err) {\n    self.metadata[token].reject(err);\n    delete self.metadata[token]\n  });\n\n};\n\nConnection.prototype._continue = function(token, resolve, reject) {\n  var query = [protodef.Query.QueryType.CONTINUE];\n  this._send(query, token, resolve, reject);\n}\nConnection.prototype._end = function(token, resolve, reject) {\n  var query = [protodef.Query.QueryType.STOP];\n  this._send(query, token, resolve, reject, undefined, undefined, true);\n}\n\n\nConnection.prototype.use = function(db) {\n  if (typeof db !== 'string') throw new Err.ReqlDriverError('First argument of `use` must be a string')\n  this.db = db;\n}\n\nConnection.prototype.server = function(callback) {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var query = [protodef.Query.QueryType.SERVER_INFO];\n    self._send(query, self._getToken(), resolve, reject, undefined, undefined, true);\n  }).nodeify(callback);\n}\n\n// Return the next token and update it.\nConnection.prototype._getToken = function() {\n  return this.token++;\n}\n\nConnection.prototype.close = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n\n  var p = new Promise(function(resolve, reject) {\n    if (!helper.isPlainObject(options)) options = {};\n    if (options.noreplyWait === true) {\n      self.noreplyWait().then(function(r) {\n        self.open = false;\n        self.connection.end()\n        resolve(r);\n      }).error(function(e) {\n        reject(e)\n      });\n    }\n    else{\n      self.open = false;\n      self.connection.end();\n      resolve();\n    }\n  }).nodeify(callback);\n  return p;\n};\n\n\nConnection.prototype.noReplyWait = function() {\n  throw new Err.ReqlDriverError('Did you mean to use `noreplyWait` instead of `noReplyWait`?')\n}\nConnection.prototype.noreplyWait = function(callback) {\n  var self = this;\n  var token = self._getToken();\n\n  var p = new Promise(function(resolve, reject) {\n    var query = [protodef.Query.QueryType.NOREPLY_WAIT];\n\n    self._send(query, token, resolve, reject);\n  }).nodeify(callback);\n  return p;\n}\nConnection.prototype._isConnection = function() {\n  return true;\n}\nConnection.prototype._isOpen = function() {\n  return this.open;\n}\n\nConnection.prototype._flush = function() {\n  helper.loopKeys(this.metadata, function(metadata, key) {\n    if (typeof metadata[key].reject === 'function') {\n      metadata[key].reject(new Err.ReqlServerError(\n            'The connection was closed before the query could be completed.',\n            metadata[key].query));\n    }\n    if (typeof metadata[key].endReject === 'function') {\n      metadata[key].endReject(new Err.ReqlServerError(\n            'The connection was closed before the query could be completed.',\n            metadata[key].query));\n    }\n  });\n  this.metadata = {};\n}\n\nmodule.exports = Connection\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/connection.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/cursor.js":
/*!**************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/cursor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js\");\nvar Err = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/error.js */ \"./node_modules/rethinkdbdash/lib/error.js\");\nvar helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nvar MAX_CALL_STACK = 1000;\n\nfunction Cursor(connection, token, options, type) {\n  this.connection = connection;\n  this.token = token;\n\n  this._stackSize = 0; // Estimation of our call stack.\n  this._index = 0; // Position in this._data[0]\n  this._data = []; // Array of non empty arrays\n  this._fetching = false; // Are we fetching data\n  this._canFetch = true; // Can we fetch more data?\n  this._pendingPromises = []; // Pending promises' resolve/reject\n  this.options = options || {};\n  this._closed = false;\n  this._closingPromise = null; // Promise returned by close\n  this._type = type;\n  this._setIncludesStates = false;\n  if ((type === 'feed') || (type === 'atomFeed')) {\n    this.toArray = _unsupportedToArray;\n  }\n  this._emittedEnd = false;\n}\n\nCursor.prototype.toString = function() {\n  return '[object '+this._type+']';\n}\nCursor.prototype.setIncludesStates = function() {\n  this._setIncludesStates = true;\n}\nCursor.prototype.includesStates = function() {\n  return this._setIncludesStates;\n}\nCursor.prototype.getType = function() {\n  return this._type;\n}\n\nCursor.prototype.toJSON = function() {\n  if (this._type === 'Cursor') {\n    throw new Err.ReqlDriverError('You cannot serialize a Cursor to JSON. Retrieve data from the cursor with `toArray` or `next`');\n  }\n  else {\n    throw new Err.ReqlDriverError('You cannot serialize a '+this._type+' to JSON. Retrieve data from the cursor with `each` or `next`');\n  }\n}\n\nCursor.prototype._next = function(callback) {\n  var self = this;\n  if (self._closed === true) {\n    return Promise.reject(new Err.ReqlDriverError(\n      'You cannot call `next` on a closed '+self._type).setOperational()\n    ).nodeify(callback);\n  }\n  else if ((self._data.length === 0) && (self._canFetch === false)) {\n    return Promise.reject(new Err.ReqlDriverError(\n      'No more rows in the '+self._type.toLowerCase()).setOperational()\n    ).nodeify(callback);\n  }\n  else {\n    if ((self._data.length > 0) && (self._data[0].length > self._index)) {\n      var result = self._data[0][self._index++];\n      if (result instanceof Error) {\n        return Promise.reject(result).nodeify(callback);\n      }\n      else {\n        // This could be possible if we get back batch with just one document?\n        if (self._data[0].length === self._index) {\n          self._index = 0;\n          self._data.shift();\n          if ((self._data.length === 1)\n            && (self._canFetch === true)\n            && (self._closed === false)\n            && (self._fetching === false)) {\n              self._fetch();\n          }\n        }\n        return Promise.resolve(result).nodeify(callback);\n      }\n    }\n    else {\n      return new Promise(function(resolve, reject) {\n        self._pendingPromises.push({resolve: resolve, reject: reject});\n      }).nodeify(callback);\n    }\n  }\n}\nCursor.prototype.hasNext = function() {\n  throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')\n}\nCursor.prototype.toArray = function(callback) {\n  var self = this;\n  var p = new Promise(function(resolve, reject) {\n    var result = [];\n    var i =0;\n    self._each(function(err, data) {\n      if (err) {\n        reject(err);\n      }\n      else {\n        result.push(data);\n      }\n    }, function() {\n      resolve(result);\n    });\n  }).nodeify(callback);\n  return p;\n}\n\nCursor.prototype._fetch = function() {\n  var self = this;\n  this._fetching = true;\n\n  var p = new Promise(function(resolve, reject) {\n    self.connection._continue(self.token, resolve, reject);\n  }).then(function(response) {\n    self._push(response);\n    return null;\n  }).error(function(error) {\n    self._fetching = false;\n    self._canFetch = false;\n    self._pushError(error);\n  })\n}\n\nCursor.prototype._push = function(data) {\n  var couldfetch = this._canFetch;\n  if (data.done) this._done();\n  var response = data.response;\n  this._fetching = false;\n  // If the cursor was closed, we ignore all following response\n  if ((response.r.length > 0) && (couldfetch === true)) {\n    this._data.push(helper.makeSequence(response, this.options));\n  }\n  // this._fetching = false\n  if ((this._closed === false) && (this._canFetch) && (this._data.length <= 1)) this._fetch();\n  this._flush();\n}\n// Try to solve as many pending promises as possible\nCursor.prototype._flush = function() {\n  while ((this._pendingPromises.length > 0) && ((this._data.length > 0) || ((this._fetching === false) && (this._canFetch === false)))) {\n    var fullfiller = this._pendingPromises.shift();\n    var resolve = fullfiller.resolve;\n    var reject = fullfiller.reject;\n\n    if (this._data.length > 0) {\n      var result = this._data[0][this._index++];\n      if (result instanceof Error) {\n        reject(result);\n      }\n      else {\n        resolve(result);\n      }\n\n      if (this._data[0].length === this._index) {\n        this._index = 0;\n        this._data.shift();\n        if ((this._data.length <= 1)\n          && (this._canFetch === true)\n          && (this._closed === false)\n          && (this._fetching === false)) {\n            this._fetch();\n        }\n      }\n    }\n    else {\n      reject(new Err.ReqlDriverError('No more rows in the '+this._type.toLowerCase()).setOperational())\n    }\n  }\n}\nCursor.prototype._pushError = function(error) {\n  this._data.push([error]);\n  this._flush();\n}\n\nCursor.prototype._done = function() {\n  this._canFetch = false;\n  if (this._eventEmitter) {\n    this._eventEmitter.emit('end');\n  }\n}\n\nCursor.prototype._set = function(ar) {\n  this._fetching = false;\n  this._canFetch = false;\n  if (ar.length > 0) {\n    this._data.push(ar);\n  }\n  this._flush();\n}\n\nCursor.prototype.close = function(callback) {\n  var self = this;\n  if (self._closed === true) {\n    return self._closingPromise.nodeify(callback);\n  }\n  self._closed = true;\n\n  self._closingPromise = new Promise(function(resolve, reject) {\n    if ((self._canFetch === false) && (self._fetching === false)) {\n      resolve()\n    }\n    else { // since v0_4 (RethinkDB 2.0) we can (must) force a STOP request even if a CONTINUE query is pending\n      var endCallback = function() {\n        if (self._eventEmitter && (self._emittedEnd === false)) {\n          self._emittedEnd = true;\n          self._eventEmitter.emit('end');\n        }\n        resolve();\n      }\n      self.connection._end(self.token, endCallback, reject);\n    }\n  }).nodeify(callback);\n  return self._closingPromise;\n}\nCursor.prototype._each = function(callback, onFinish) {\n  if (this._closed === true) {\n    return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());\n  }\n  var self = this;\n\n  var reject = function(err) {\n    if (err.message === 'No more rows in the '+self._type.toLowerCase()+'.') {\n      if (typeof onFinish === 'function') {\n        onFinish();\n      }\n    }\n    else {\n      callback(err);\n    }\n    return null;\n  }\n  var resolve = function(data) {\n    self._stackSize++;\n    var keepGoing = callback(null, data);\n    if (keepGoing === false) {\n      if (typeof onFinish === 'function') {\n        onFinish();\n      }\n    }\n    else {\n      if (self._closed === false) {\n        if (self._stackSize <= MAX_CALL_STACK) {\n          self._next().then(resolve).error(function(error) {\n            if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&\n                (error.message.match(/You cannot call `next` on a closed/) === null)) {\n              reject(error);\n            }\n          });\n        }\n        else {\n          setTimeout(function() {\n            self._stackSize = 0;\n            self._next().then(resolve).error(function(error) {\n              if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&\n                  (error.message.match(/You cannot call `next` on a closed/) === null)) {\n                reject(error);\n              }\n            });\n          }, 0);\n        }\n      }\n    }\n    return null;\n  }\n\n  self._next().then(resolve).error(function(error) {\n    // We can silence error when the cursor is closed as this\n    if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&\n        (error.message.match(/You cannot call `next` on a closed/) === null)) {\n      reject(error);\n    }\n  });\n  return null;\n}\nCursor.prototype._eachAsync = function(callback) {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    self._eachAsyncInternal(callback, resolve, reject)\n  });\n}\nCursor.prototype._eachAsyncInternal = function(callback, finalResolve, finalReject) {\n  if (this._closed === true) {\n    finalReject(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());\n    return;\n  }\n  var self = this;\n\n  var nextCb = function() {\n    self._stackSize++;\n    self._next().then(function(row) {\n      if (self._stackSize <= MAX_CALL_STACK) {\n        if (callback.length <= 1) {\n          Promise.resolve(callback(row)).then(nextCb)\n          return null;\n        }\n        else {\n          new Promise(function(resolve, reject) {\n            return callback(row, resolve)\n          }).then(nextCb);\n          return null;\n        }\n      }\n      else {\n        new Promise(function(resolve, reject) {\n          setTimeout(function() {\n            self._stackSize = 0;\n            if (callback.length <= 1) {\n              Promise.resolve(callback(row)).then(resolve).catch(reject);\n            }\n            else {\n              new Promise(function(resolve, reject) {\n                return callback(row, resolve)\n              }).then(resolve).catch(reject);\n              return null;\n            }\n          }, 0)\n        }).then(nextCb);\n        return null;\n      }\n    }).error(function(error) {\n      if ((error.message === 'No more rows in the '+self._type.toLowerCase()+'.') ||\n          (error.message === 'You cannot retrieve data from a cursor that is closed.') ||\n          (error.message.match(/You cannot call `next` on a closed/) !== null)) {\n        return finalResolve();\n      }\n      return finalReject(Err.setOperational(error));\n    });\n  }\n  nextCb();\n}\nCursor.prototype.eachAsync = Cursor.prototype._eachAsync;\nCursor.prototype.next = Cursor.prototype._next;\nCursor.prototype.each = Cursor.prototype._each;\nCursor.prototype._unsupportedToArray = function() {\n  throw new Error('The `toArray` method is not available on feeds.')\n}\n\nCursor.prototype._makeEmitter = function() {\n  this.next = function() {\n    throw new Err.ReqlDriverError('You cannot call `next` once you have bound listeners on the '+this._type)\n  }\n  this.each = function() {\n    throw new Err.ReqlDriverError('You cannot call `each` once you have bound listeners on the '+this._type)\n  }\n  this.eachAsync = function() {\n    throw new Err.ReqlDriverError('You cannot call `eachAsync` once you have bound listeners on the '+this._type)\n  }\n  this.toArray = function() {\n    throw new Err.ReqlDriverError('You cannot call `toArray` once you have bound listeners on the '+this._type)\n  }\n  this._eventEmitter = new EventEmitter();\n}\nCursor.prototype._eachCb = function(err, data) {\n  // We should silent things if the cursor/feed is closed\n  if (this._closed === false) {\n    if (err) {\n      this._eventEmitter.emit('error', err);\n    }\n    else {\n      this._eventEmitter.emit('data', data);\n    }\n  }\n}\n\nvar methods = [\n  'addListener',\n  'on',\n  'once',\n  'removeListener',\n  'removeAllListeners',\n  'setMaxListeners',\n  'listeners',\n  'emit'\n];\n\nfor(var i=0; i<methods.length; i++) {\n  (function(n) {\n    var method = methods[n];\n    Cursor.prototype[method] = function() {\n      var self = this;\n      if (self._eventEmitter == null) {\n        self._makeEmitter();\n        setImmediate(function() {\n          self._each(self._eachCb.bind(self), function() {\n            if (self._emittedEnd === false) {\n              self._emittedEnd = true;\n              self._eventEmitter.emit('end');\n            }\n          });\n        });\n      }\n      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n      self._eventEmitter[method].apply(self._eventEmitter, _args);\n    };\n  })(i);\n}\n\nmodule.exports = Cursor;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/cursor.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/dequeue.js":
/*!***************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/dequeue.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Implement a dequeue with a circular buffer\n// The buffer can expand but currently doesn't automatically shrink\n// as it is not a desired behavior. We may want to explicitly resize it though.\nfunction Dequeue(size) {\n  this.start = 0;\n  this.end = 0;\n\n  size = size || 50;\n  this.buffer = new Array(size);\n}\nDequeue.prototype.get = function(index) {\n  if (this.start+index > this.buffer.length) {\n    return this.buffer[this.start+index-this.buffer.length]\n  }\n  else {\n    return this.buffer[this.start+index]\n  }\n}\n\nDequeue.prototype.toArray = function(index) {\n  var result = [];\n  for(var i=0; i<this.getLength(); i++) {\n    result.push(this.get(i));\n  }\n  return result;\n}\n\nDequeue.prototype.delete = function(index) {\n  var current, next;\n  if (this.start+index >= this.buffer.length) {\n    current = this.start+index-this.buffer.length;\n    next = this.start+index-this.buffer.length+1;\n  }\n  else {\n    current = this.start+index;\n    next = this.start+index+1;\n  }\n\n  for(var i=index; i<(this.buffer.length-index); i++) {\n    if (next === this.buffer.length) next = 0;\n    if (current === this.buffer.length) current = 0;\n\n    this.buffer[current] = this.buffer[next];\n    current++;\n    next++;\n  }\n\n  this.end--;\n  if (this.end < 0) this.end = this.buffer.length-1\n}\n\nDequeue.prototype.push = function(element) {\n  // push on this.end and then increase this.end\n  // this.end should NEVER be equal to this.buffer.length\n  this.buffer[this.end] = element;\n  this.end++;\n  if (this.end === this.buffer.length) this.end = 0;\n\n  if (this.start === this.end) {\n    // Resize\n    var previousBuffer = this.buffer;\n\n    this.buffer = new Array(previousBuffer.length*2);\n\n    var i, k = 0;\n    for(i=this.start; i<previousBuffer.length; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    for(i=0; i<this.start; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    this.start = 0;\n    this.end = previousBuffer.length;\n  }\n}\n\nDequeue.prototype.pop = function(element) {\n  //TODO: Decrease size when possible/needed? This may not be\n  //something we really need/want\n  // Return the element in this.end-1\n  if (this.getLength() > 0) {\n    var pos = this.end-1;\n    if (pos < 0) pos = this.buffer.length-1;\n    this.end = pos;\n    var result = this.buffer[pos];\n    this.buffer[pos] = undefined;\n    return result;\n  }\n  else {\n    return undefined\n  }\n}\n\nDequeue.prototype.unshift = function(element) {\n  // push on this.start-1 and then decrease this.start.\n  // this.end should NEVER be equal to this.buffer.length\n\n  var pos = this.start-1;\n  if (pos < 0) pos = this.buffer.length-1;\n\n  this.buffer[pos] = element;\n  this.start = pos;\n\n  if (this.start === this.end) {\n    //Resize\n    var previousBuffer = this.buffer;\n\n    this.buffer = new Array(previousBuffer.length*2);\n\n    var i, k = 0;\n    for(i=this.start; i<previousBuffer.length; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    for(i=0; i<this.start; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    this.start = 0;\n    this.end = previousBuffer.length;\n  }\n}\n\nDequeue.prototype.shift = function() {\n  // Return the element in this.start\n\n  if (this.getLength() > 0) {\n    var result = this.buffer[this.start];\n    this.buffer[this.start] = undefined;\n    this.start++;\n    if (this.start === this.buffer.length) this.start = 0;\n    return result;\n  }\n}\n\nDequeue.prototype.getLength = function() {\n  if (this.start <= this.end) {\n    return this.end-this.start;\n  }\n  else {\n    return this.buffer.length-(this.start-this.end);\n  }\n}\n\nmodule.exports = Dequeue;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/dequeue.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/error.js":
/*!*************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/error.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar INDENT = 4;\nvar LIMIT = 80;\nvar IS_OPERATIONAL = 'isOperational';\n\nvar protodef = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/protodef.js */ \"./node_modules/rethinkdbdash/lib/protodef.js\");\nvar responseTypes = protodef.Response.ResponseType;\nvar protoErrorType = protodef.Response.ErrorType;\nvar termTypes = protodef.Term.TermType;\nvar datumTypes = protodef.Datum.DatumType;\nvar frameTypes = protodef.Frame.FrameType;\n\n\nfunction ReqlDriverError(message, query, secondMessage) {\n  this.message = this.msg = message;\n  Error.captureStackTrace(this, ReqlDriverError);\n\n  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n    \n    this.message += ' after:\\n';\n\n    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});\n\n    this.message += backtrace.str;\n  }\n  else {\n    if (this.message[this.message.length-1] !== '?') this.message += '.';\n  }\n  if (secondMessage) this.message += '\\n'+secondMessage;\n};\nReqlDriverError.prototype = new Error();\nReqlDriverError.prototype.name = 'ReqlDriverError';\nReqlDriverError.prototype.setOperational = function() {\n  this[IS_OPERATIONAL] = true;\n  return this;\n};\n\nmodule.exports.ReqlDriverError = ReqlDriverError;\n\n\nfunction ReqlServerError(message, query) {\n  this.message = this.msg = message;\n  Error.captureStackTrace(this, ReqlServerError);\n\n  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n    \n    this.message += ' for:\\n';\n\n    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});\n\n    this.message += backtrace.str;\n  }\n  else {\n    if (this.message[this.message.length-1] !== '?') this.message += '.';\n  }\n};\nReqlServerError.prototype = new Error();\nReqlServerError.prototype.name = 'ReqlServerError';\nReqlServerError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlServerError = ReqlServerError;\n\n\nfunction ReqlRuntimeError(message, query, frames) {\n  this.message = this.msg = message;\n  Error.captureStackTrace(this, ReqlRuntimeError);\n\n  if ((query != null) && (frames)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n    \n    this.message += ' in:\\n';\n\n    frames = frames.b;\n    if (frames) this.frames = frames.slice(0);\n    //this.frames = JSON.stringify(frames, null, 2);\n\n    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});\n\n    var queryLines = backtrace.str.split('\\n');\n    var carrotLines = backtrace.car.split('\\n');\n\n    for(var i=0; i<queryLines.length; i++) {\n      this.message += queryLines[i]+'\\n';\n      if (carrotLines[i].match(/\\^/)) {\n        var pos = queryLines[i].match(/[^\\s]/);\n        if ((pos) && (pos.index)) {\n          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\\n';\n        }\n        else {\n          this.message += carrotLines[i]+'\\n';\n        }\n      }\n    }\n  }\n  //this.query = JSON.stringify(query, null, 2);\n};\nReqlRuntimeError.prototype = new Error();\nReqlRuntimeError.prototype.name = 'ReqlRuntimeError';\nReqlRuntimeError.prototype.setName = function(type) {\n  switch(type) {\n    case protoErrorType.INTERNAL:\n      this.name = 'ReqlInternalError';\n      break;\n    case protoErrorType.RESOURCE_LIMIT:\n      this.name = 'ReqlResourceError';\n      break;\n    case protoErrorType.QUERY_LOGIC:\n      this.name = 'ReqlLogicError';\n      break;\n    case protoErrorType.OP_FAILED:\n      this.name = 'ReqlOpFailedError';\n      break;\n    case protoErrorType.OP_INDETERMINATE:\n      this.name = 'ReqlOpIndeterminateError';\n      break;\n    case protoErrorType.USER:\n      this.name = 'ReqlUserError';\n      break;\n    //default: // Do nothing\n  }\n}\nReqlRuntimeError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlRuntimeError = ReqlRuntimeError;\n\n\nfunction ReqlCompileError(message, query, frames) {\n  this.message = message;\n  Error.captureStackTrace(this, ReqlCompileError);\n\n  if ((query != null) && (frames)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n\n    this.message += ' in:\\n';\n\n    frames = frames.b;\n    if (frames) this.frames = frames.slice(0);\n    //this.frames = JSON.stringify(frames, null, 2);\n\n    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});\n\n    var queryLines = backtrace.str.split('\\n');\n    var carrotLines = backtrace.car.split('\\n');\n\n    for(var i=0; i<queryLines.length; i++) {\n      this.message += queryLines[i]+'\\n';\n      if (carrotLines[i].match(/\\^/)) {\n        var pos = queryLines[i].match(/[^\\s]/);\n        if ((pos) && (pos.index)) {\n          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\\n';\n        }\n        else {\n          this.message += carrotLines[i]+'\\n';\n        }\n      }\n    }\n  }\n};\nReqlCompileError.prototype = new Error();\nReqlCompileError.prototype.name = 'ReqlCompileError';\nReqlCompileError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlCompileError = ReqlCompileError;\n\n\nfunction ReqlClientError(message) {\n  this.message = message;\n  Error.captureStackTrace(this, ReqlClientError);\n};\nReqlClientError.prototype = new Error();\nReqlClientError.prototype.name = 'ReqlClientError';\nReqlClientError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlClientError = ReqlClientError;\n\n\n\nvar _constants = {\n  MONDAY: true,\n  TUESDAY: true,\n  WEDNESDAY: true,\n  THURSDAY: true,\n  FRIDAY: true,\n  SATURDAY: true,\n  SUNDAY: true,\n  JANUARY: true,\n  FEBRUARY: true,\n  MARCH: true,\n  APRIL: true,\n  MAY: true,\n  JUNE: true,\n  JULY: true,\n  AUGUST: true,\n  SEPTEMBER: true,\n  OCTOBER: true,\n  NOVEMBER: true,\n  DECEMBER: true,\n  MINVAL: true,\n  MAXVAL: true,\n}\nvar constants = {};\nfor(var key in _constants) {\n  constants[termTypes[key]] = true;\n}\n\n\nvar _nonPrefix = {\n  DB: true,\n  DB_CREATE: true,\n  DB_LIST: true,\n  DB_DROP: true,\n  JS: true,\n  NOW: true,\n  TIME: true,\n  EPOCH_TIME: true,\n  ISO8601: true,\n  BRANCH: true,\n  JAVASCRIPT: true,\n  ERROR: true,\n  MAKE_ARRAY: true,\n  JSON: true,\n  ARGS: true,\n  HTTP: true,\n  RANDOM: true,\n  BINARY: true,\n  OBJECT: true,\n  CIRCLE: true,\n  GEOJSON: true,\n  POINT: true,\n  LINE: true,\n  POLYGON: true,\n  UUID: true,\n  DESC: true,\n  ASC: true,\n  RANGE: true,\n  LITERAL: 'true'\n}\nvar nonPrefix = {};\nfor(var key in _nonPrefix) {\n  nonPrefix[termTypes[key]] = true;\n}\n// Constants are also in nonPrefix\nfor(var key in _constants) {\n  nonPrefix[termTypes[key]] = true;\n}\n\n\nvar _typeToString = {\n  DB: 'db',\n  DB_CREATE: 'dbCreate',\n  DB_LIST: 'dbList',\n  DB_DROP: 'dbDrop',\n  TABLE_CREATE: 'tableCreate',\n  TABLE_LIST: 'tableList',\n  TABLE_DROP: 'tableDrop',\n  TABLE: 'table',\n  INDEX_CREATE: 'indexCreate',\n  INDEX_DROP: 'indexDrop',\n  INDEX_LIST: 'indexList',\n  INDEX_WAIT: 'indexWait',\n  INDEX_STATUS: 'indexStatus',\n  INSERT: 'insert',\n  UPDATE: 'update',\n  REPLACE: 'replace',\n  DELETE: 'delete',\n  SYNC: 'sync',\n  GET: 'get',\n  GET_ALL: 'getAll',\n  BETWEEN: 'between',\n  FILTER: 'filter',\n  INNER_JOIN: 'innerJoin',\n  OUTER_JOIN: 'outerJoin',\n  EQ_JOIN: 'eqJoin',\n  ZIP: 'zip',\n  MAP: 'map',\n  WITH_FIELDS: 'withFields',\n  CONCAT_MAP: 'concatMap',\n  ORDER_BY: 'orderBy',\n  DESC: 'desc',\n  ASC: 'asc',\n  SKIP: 'skip',\n  LIMIT: 'limit',\n  SLICE: 'slice',\n  NTH: 'nth',\n  OFFSETS_OF: 'offsetsOf',\n  IS_EMPTY: 'isEmpty',\n  UNION: 'union',\n  SAMPLE: 'sample',\n  REDUCE: 'reduce',\n  COUNT: 'count',\n  SUM: 'sum',\n  AVG: 'avg',\n  MIN: 'min',\n  MAX: 'max',\n  FOLD: 'fold',\n  OBJECT: 'object',\n  DISTINCT: 'distinct',\n  GROUP: 'group',\n  UNGROUP: 'ungroup',\n  CONTAINS: 'contains',\n  IMPLICIT_VAR: 'row',\n  PLUCK: 'pluck',\n  WITHOUT: 'without',\n  MERGE: 'merge',\n  APPEND: 'append',\n  PREPEND: 'prepend',\n  DIFFERENCE: 'difference',\n  SET_INSERT: 'setInsert',\n  SET_UNION: 'setUnion',\n  SET_INTERSECTION: 'setIntersection',\n  SET_DIFFERENCE: 'setDifference',\n  HAS_FIELDS: 'hasFields',\n  INSERT_AT: 'insertAt',\n  SPLICE_AT: 'spliceAt',\n  DELETE_AT: 'deleteAt',\n  CHANGE_AT: 'changeAt',\n  KEYS: 'keys',\n  VALUES: 'values',\n  MATCH: 'match',\n  UPCASE: 'upcase',\n  DOWNCASE: 'downcase',\n  ADD: 'add',\n  SUB: 'sub',\n  MUL: 'mul',\n  DIV: 'div',\n  MOD: 'mod',\n  AND: 'and',\n  OR: 'or',\n  EQ: 'eq',\n  NE: 'ne',\n  GT: 'gt',\n  GE: 'ge',\n  LT: 'lt',\n  LE: 'le',\n  NOT: 'not',\n  FLOOR: 'floor',\n  CEIL: 'ceil',\n  ROUND: 'round',\n  NOW: 'now',\n  TIME: 'time',\n  EPOCH_TIME: 'epochTime',\n  ISO8601: 'ISO8601',\n  IN_TIMEZONE: 'inTimezone',\n  TIMEZONE: 'timezone',\n  DURING: 'during',\n  DATE: 'date',\n  TIME_OF_DAY: 'timeOfDay',\n  YEAR: 'year',\n  MONTH: 'month',\n  DAY: 'day',\n  DAY_OF_WEEK: 'dayOfWeek',\n  DAY_OF_YEAR: 'dayOfYear',\n  HOURS: 'hours',\n  MINUTES: 'minutes',\n  SECONDS: 'seconds',\n  TO_ISO8601: 'toISO8601',\n  TO_EPOCH_TIME: 'toEpochTime',\n  FUNCALL: 'do',\n  BRANCH: 'branch',\n  FOR_EACH: 'forEach',\n  ERROR: 'error',\n  DEFAULT: 'default',\n  JAVASCRIPT: 'js',\n  COERCE_TO: 'coerceTo',\n  TYPE_OF: 'typeOf',\n  INFO: 'info',\n  JSON: 'json',\n  ARGS: 'args',\n  HTTP: 'http',\n  RANDOM: 'random',\n  CHANGES: 'changes',\n  BINARY: 'binary',\n  INDEX_RENAME: 'indexRename',\n  CIRCLE: 'circle',\n  DISTANCE: 'distance',\n  FILL: 'fill',\n  GEOJSON: 'geojson',\n  TO_GEOJSON: 'toGeojson',\n  GET_INTERSECTING: 'getIntersecting',\n  GET_NEAREST: 'getNearest',\n  INCLUDES: 'includes',\n  INTERSECTS: 'intersects',\n  LINE: 'line',\n  POINT: 'point',\n  POLYGON: 'polygon',\n  POLYGON_SUB: 'polygonSub',\n  UUID: 'uuid',\n  RANGE: 'range',\n  TO_JSON_STRING: 'toJSON',\n  CONFIG: 'config',\n  STATUS: 'status',\n  WAIT: 'wait',\n  RECONFIGURE: 'reconfigure',\n  REBALANCE: 'rebalance',\n  GRANT: 'grant',\n  SPLIT: 'split',\n  LITERAL: 'literal',\n  MONDAY: 'monday',\n  TUESDAY: 'tuesday',\n  WEDNESDAY: 'wednesday',\n  THURSDAY: 'thursday',\n  FRIDAY: 'friday',\n  SATURDAY: 'saturday',\n  SUNDAY: 'sunday',\n  JANUARY: 'january',\n  FEBRUARY: 'february',\n  MARCH: 'march',\n  APRIL: 'april',\n  MAY: 'may',\n  JUNE: 'june',\n  JULY: 'july',\n  AUGUST: 'august',\n  SEPTEMBER: 'september',\n  OCTOBER: 'october',\n  NOVEMBER: 'november',\n  DECEMBER: 'december' ,\n  MINVAL: 'minval',\n  MAXVAL: 'maxval',\n}\nvar typeToString = {};\nfor(var key in _typeToString) {\n  typeToString[termTypes[key]] = _typeToString[key];\n}\n\nvar _noPrefixOptargs = {\n  ISO8601: true,\n}\nvar noPrefixOptargs = {};\nfor(var key in _noPrefixOptargs) {\n  noPrefixOptargs[termTypes[key]] = true;\n}\n\nvar _specialType = {\n  DATUM: function(term, index, father, frames, options, optarg) {\n    optarg = optarg || false;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    var currentFrame, backtrace;\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    var result = {\n      str: '',\n      car: ''\n    }\n\n    if ((helper.isPlainObject(term)) && (term.$reql_type$ === 'BINARY')) {\n      carify(result, 'r.binary(<Buffer>)', underline);\n      return result;\n    }\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)\n\n    if (typeof term === 'string' ) {\n      carify(result, '\"'+term+'\"', underline);\n    }\n    else if (helper.isPlainObject(term)) {\n      var totalKeys = Object.keys(term).length;\n      if (totalKeys === 0) {\n        carify(result, '{}', underline);\n      }\n      else {\n        carify(result, '{\\n', underline);\n        var countKeys = 0;\n        var extraToRemove = options.extra;\n        options.indent += INDENT+options.extra;\n        options.extra = 0;\n        for(var key in term) {\n          countKeys++;\n          //if (!((father) && (Array.isArray(father[2])) && (Object.keys(father[2]).length > 0))) options.extra = 0;\n\n          if (optarg) {\n            carify(result, space(options.indent)+camelCase(key)+': ', underline);\n          }\n          else {\n            carify(result, space(options.indent)+key+': ', underline);\n          }\n          if ((currentFrame != null) && (currentFrame === key)) {\n            backtrace = generateBacktrace(term[key], i, term, frames, options);\n          }\n          else {\n            backtrace = generateBacktrace(term[key], i, term, null, options);\n          }\n          result.str += backtrace.str;\n          result.car += backtrace.car;\n          \n          if (countKeys !== totalKeys) { \n            carify(result, ',\\n', underline);\n          }\n\n        }\n        options.indent -= INDENT+extraToRemove;\n        carify(result, '\\n'+space(options.indent+extraToRemove)+'}', underline);\n      }\n    }\n    else if (Array.isArray(term)) {\n      carify(result, '[', underline);\n      for(var i=0; i<term.length; i++) {\n        if ((currentFrame != null) && (currentFrame === i)) {\n          backtrace = generateBacktrace(term[i], i, term, frames, options);\n        }\n        else {\n          backtrace = generateBacktrace(term[i], i, term, null, options);\n        }\n        result.str += backtrace.str;\n        result.car += backtrace.car;\n      }\n      carify(result, ']', underline);\n    }\n    else {\n      carify(result, ''+term, underline);\n    }\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, ')', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  TABLE: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n\n    if ((term.length === 1) || (term[1].length === 0) || (term[1][0][0] !== termTypes.DB)) {\n      var underline = Array.isArray(frames) && (frames.length === 0);\n      if (Array.isArray(frames)) currentFrame = frames.shift();\n\n      carify(result, 'r.'+typeToString[term[0]]+'(', underline);\n      if (Array.isArray(term[1])) {\n        for(var i=0; i<term[1].length; i++) {\n          if (i !==0) result.str += ', ';\n\n\n          if ((currentFrame != null) && (currentFrame === 1)) {\n            // +1 for index because it's like if there was a r.db(...) before .table(...)\n            backtrace = generateBacktrace(term[1][i], i+1, term, frames, options)\n          }\n          else {\n            backtrace = generateBacktrace(term[1][i], i+1, term, null, options)\n          }\n          result.str += backtrace.str;\n          result.car += backtrace.car\n        }\n      }\n\n      backtrace = makeOptargs(term, i, term, frames, options, currentFrame)\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n\n      carify(result, ')', underline);\n\n      if (underline) result.car = result.str.replace(/./g, '^');\n    }\n    else {\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n\n    return result;\n  },\n  GET_FIELD: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((currentFrame != null) && (currentFrame === 0)) {\n      backtrace = generateBacktrace(term[1][0], 0, term, frames, options)\n    }\n    else {\n      backtrace = generateBacktrace(term[1][0], 0, term, null, options)\n    }\n    result.str = backtrace.str;\n    result.car = backtrace.car;\n\n    carify(result, '(', underline);\n\n    if ((currentFrame != null) && (currentFrame === 1)) {\n      backtrace = generateBacktrace(term[1][1], 1, term, frames, options)\n    }\n    else {\n      backtrace = generateBacktrace(term[1][1], 1, term, null, options)\n    }\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    carify(result, ')', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  MAKE_ARRAY: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    };\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)\n\n    if (!((options) && (options.noBracket))) {\n      carify(result, '[', underline);\n    }\n    for(var i=0; i<term[1].length; i++) {\n      if (i !== 0) {\n        carify(result, ', ', underline);\n      }\n\n      if ((currentFrame != null) && (currentFrame  === i)) {\n        backtrace = generateBacktrace(term[1][i], i, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][i], i, term, null, options);\n      }\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n\n    }\n\n    if (!((options) && (options.noBracket))) {\n      carify(result, ']', underline);\n    }\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) {\n      carify(result, ')', underline);\n    }\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  FUNC: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    };\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((term[1][0][1].length === 1) && (helper.hasImplicit(term[1][1]))) {\n      if ((currentFrame != null) && (currentFrame === 1)) {\n        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][1], 1, term, null, options);\n      }\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else {\n      carify(result, 'function(', underline);\n\n      for(var i=0; i<term[1][0][1].length; i++) {\n        if (i !== 0) {\n          carify(result, ', ', underline);\n        }\n        carify(result, 'var_'+term[1][0][1][i], underline);\n      }\n\n      options.indent += INDENT+options.extra;\n      var extraToRemove = options.extra;\n      options.extra = 0;\n      //if (!((Array.isArray(term[2])) && (term[2].length > 0))) options.extra = 0;\n\n      carify(result, ') {\\n'+space(options.indent)+'return ', underline);\n\n      if ((currentFrame != null) && (currentFrame === 1)) {\n        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][1], 1, term, null, options);\n      }\n\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n\n      options.indent -= INDENT+extraToRemove;\n      options.extra = extraToRemove;\n\n      carify(result, '\\n'+space(options.indent+extraToRemove)+'}', underline);\n\n    }\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  VAR: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    carify(result, 'var_'+term[1][0], underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n    return result;\n  },\n  FUNCALL: function(term, index, father, frames, options) {\n    // The syntax is args[1].do(args[0])\n    var result = {\n      str: '',\n      car: ''\n    };\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if (term[1].length === 2) {\n      if ((currentFrame != null) && (currentFrame === 1)) {\n        backtrace = generateBacktrace(term[1][1], 0, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][1], 0, term, null, options);\n      }\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n\n      carify(result, '.do(', underline);\n    }\n    else {\n      carify(result, 'r.do(', underline);\n\n      for(var i=1; i<term[1].length; i++) {\n        if ((currentFrame != null) && (currentFrame === i)) {\n          backtrace = generateBacktrace(term[1][i], i, term, frames, options);\n        }\n        else {\n          backtrace = generateBacktrace(term[1][i], i, term, null, options);\n        }\n        result.str += backtrace.str;\n        result.car += backtrace.car;\n\n        if (i !== term[1].length) {\n          carify(result, ', ' , underline);\n        }\n      }\n    }\n\n    if ((currentFrame != null) && (currentFrame === 0)) {\n      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);\n    }\n    else {\n      backtrace = generateBacktrace(term[1][0], 0, term, null, options);\n    }\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    carify(result, ')', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  IMPLICIT_VAR: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    carify(result, 'r.row', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n    return result;\n  },\n  WAIT: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    if (term.length === 1 || term[1].length === 0) {\n      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else {\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    return result;\n  },\n  MAP: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    if (term.length > 1 && term[1].length > 2) {\n      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else {\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    return result;\n  },\n}\n_specialType.TABLE_CREATE = _specialType.TABLE;\n_specialType.TABLE_DROP = _specialType.TABLE;\n_specialType.TABLE_LIST = _specialType.TABLE;\n_specialType.RECONFIGURE = _specialType.WAIT;\n_specialType.REBALANCE = _specialType.WAIT;\n_specialType.BRACKET = _specialType.GET_FIELD;\n\nvar specialType = {};\nfor(var key in _specialType) {\n  specialType[termTypes[key]] = _specialType[key];\n}\n\n\nfunction space(n) {\n  return new Array(n+1).join(' ');\n}\nfunction carify(result, str, underline) {\n  if (underline === true) {\n    result.str += str;\n    result.car += str.replace(/[^\\n]/g, '^');\n  }\n  else {\n    result.str += str;\n    result.car += str.replace(/[^\\n]/g, ' ');\n  }\n}\nfunction makeOptargs(term, index, father, frames, options, currentFrame) {\n  var result = {\n    str: '',\n    car: ''\n  }\n  var backtrace, currentFrame, underline;\n\n  if (helper.isPlainObject(term[2])) {\n    //if ((currentFrame != null) && (frames != null)) frames.unshift(currentFrame);\n\n    //underline = Array.isArray(frames) && (frames.length === 0);\n    var underline = false;\n    //if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    // This works before there is no prefix term than can be called with no normal argument but with an optarg\n    if (Array.isArray(term[1]) && (term[1].length > 1)) {\n      carify(result, ', ' , underline);\n    }\n    else if (Array.isArray(term[1]) && (term[1].length > 0) && (noPrefixOptargs[term[0]])) {\n      carify(result, ', ' , underline);\n    }\n\n    backtrace = specialType[termTypes.DATUM](term[2], index, term[2], frames, options, true);\n\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n  }\n\n  return result;\n}\nfunction generateNormalBacktrace(term, index, father, frames, options) {\n  var result = {\n    str: '',\n    car: ''\n  }\n  var backtrace, currentFrame, underline;\n\n  //if (term[1]) {\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((currentFrame != null) && (currentFrame === 0)) {\n      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);\n    }\n    else {\n      backtrace = generateBacktrace(term[1][0], 0, term, null, options);\n    }\n    result.str = backtrace.str;\n    result.car = backtrace.car;\n\n    var lines = backtrace.str.split('\\n');\n    var line = lines[lines.length-1];\n    var pos = line.match(/[^\\s]/);\n    pos = (pos) ? pos.index : 0;\n\n    if (line.length-pos > LIMIT) {\n      if (options.extra === 0) options.extra += INDENT;\n      carify(result, '\\n'+space(options.indent+options.extra) , underline);\n    }\n\n    carify(result, '.'+typeToString[term[0]]+'(' , underline);\n    options.indent += options.extra;\n    var extraToRemove = options.extra;\n    options.extra = 0;\n\n    for(var i=1; i<term[1].length; i++) {\n      if (i !== 1) {\n        carify(result, ', ' , underline);\n      }\n      if ((currentFrame != null) && (currentFrame === i)) {\n        backtrace = generateBacktrace(term[1][i], i, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][i], i, term, null, options);\n      }\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n    }\n\n    backtrace = makeOptargs(term, i, term, frames, options, currentFrame)\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    options.indent -= extraToRemove;\n    options.extra = extraToRemove;\n\n    carify(result, ')' , underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n  /*\n  }\n  else {\n    throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 1 --\\n'+JSON.stringify(term, null, 2))\n  }\n  */\n\n\n  return result;\n}\n\nfunction generateWithoutPrefixBacktrace(term, index, father, frames, options) {\n  var result = {\n    str: '',\n    car: ''\n  }\n\n  var backtrace, currentFrame, underline;\n\n  var underline = Array.isArray(frames) && (frames.length === 0);\n  if (Array.isArray(frames)) currentFrame = frames.shift();\n\n  if (constants[term[0]]) {\n    carify(result, 'r.'+typeToString[term[0]], underline); \n    return result;\n  }\n\n  carify(result, 'r.'+typeToString[term[0]]+'(', underline); \n\n  if (Array.isArray(term[1])) {\n    for(var i=0; i<term[1].length; i++) {\n      if (i !== 0) carify(result, ', ', underline)\n\n      if ((currentFrame != null) && (currentFrame === i)) {\n        backtrace = generateBacktrace(term[1][i], i, term, frames, options)\n      }\n      else {\n        backtrace = generateBacktrace(term[1][i], i, term, null, options)\n      }\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n    }\n  }\n\n  backtrace = makeOptargs(term, i, term, frames, options, currentFrame)\n  result.str += backtrace.str;\n  result.car += backtrace.car;\n\n  carify(result, ')', underline);\n\n  if (underline) result.car = result.str.replace(/./g, '^');\n\n  return result;\n}\n\nfunction generateBacktrace(term, index, father, frames, options) {\n  var result = {\n    str: '',\n    car: ''\n  }\n  var backtrace, currentFrame, underline;\n\n  // frames = null -> do not underline\n  // frames = [] -> underline\n\n  if (Array.isArray(term)) {\n    if (term.length === 0) {\n      var underline = Array.isArray(frames) && (frames.length === 0);\n      carify(result, 'undefined', underline);\n    }\n    else if (specialType[term[0]]) {\n      backtrace = specialType[term[0]](term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else if (nonPrefix[term[0]]) {\n      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else { // normal type -- this.<method>( this.args... )\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n  }\n  else if (term !== undefined) {\n    backtrace = specialType[termTypes.DATUM](term, index, father, frames, options);\n\n    result.str = backtrace.str;\n    result.car = backtrace.car;\n  }\n  else {\n    //throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 2')\n  }\n  return result;\n}\n\nfunction camelCase(str) {\n  return str.replace(/_(.)/g, function (m, char) { return char.toUpperCase() });\n}\nmodule.exports.generateBacktrace = generateBacktrace;\n\nmodule.exports.setOperational = function(error) {\n  error[IS_OPERATIONAL] = true;\n  return error;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/error.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/helper.js":
/*!**************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/helper.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var protodef = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/protodef.js */ \"./node_modules/rethinkdbdash/lib/protodef.js\");\nvar termTypes = protodef.Term.TermType;\nvar datumTypes = protodef.Datum.DatumType;\nvar net = __webpack_require__(/*! net */ \"net\");\n\n\nfunction createLogger(poolMaster, silent) {\n  return function(message) {\n    if (silent !== true) {\n      console.error(message);\n    }\n    poolMaster.emit('log', message);\n  }\n}\nmodule.exports.createLogger = createLogger;\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\nmodule.exports.isPlainObject = isPlainObject;\n\nfunction toArray(args) {\n  return Array.prototype.slice.call(args);\n}\nmodule.exports.toArray = toArray;\n\nfunction hasImplicit(arg) {\n  if (Array.isArray(arg)) {\n    if (arg[0] === termTypes.IMPLICIT_VAR) return true;\n\n    if (Array.isArray(arg[1])) {\n      for(var i=0; i<arg[1].length; i++) {\n        if (hasImplicit(arg[1][i])) return true;\n      }\n    }\n    if (isPlainObject(arg[2])) {\n      for(var key in arg[2]) {\n        if (hasImplicit(arg[2][key])) return true;\n      }\n    }\n  }\n  else if (isPlainObject(arg)) {\n    for(var key in arg) {\n      if (hasImplicit(arg[key])) return true;\n    }\n  }\n  return false;\n}\nmodule.exports.hasImplicit = hasImplicit;\n\nfunction loopKeys(obj, fn) {\n  var keys = Object.keys(obj);\n  var result;\n  var keysLength = keys.length;\n  for(var i=0; i<keysLength; i++) {\n    result = fn(obj, keys[i]);\n    if (result === false) return;\n  }\n}\nmodule.exports.loopKeys = loopKeys;\n\nfunction convertPseudotype(obj, options) {\n  var reqlType = obj['$reql_type$'];\n  if (reqlType === 'TIME' && options['timeFormat'] !== 'raw') {\n    return new Date(obj['epoch_time'] * 1000);\n  }\n  else if (reqlType === 'GROUPED_DATA' && options['groupFormat'] !== 'raw') {\n    var result = [];\n    for (var i = 0, len = obj['data'].length, ref; i < len; i++) {\n      ref = obj.data[i];\n      result.push({\n        group: ref[0],\n        reduction: ref[1]\n      });\n    }\n    return result;\n  }\n  else if (reqlType === 'BINARY' && options['binaryFormat'] !== 'raw') {\n    return new Buffer(obj['data'], 'base64');\n  }\n  return obj;\n}\nfunction recursivelyConvertPseudotype(obj, options) {\n  var i, value, len, key;\n  if (Array.isArray(obj)) {\n    for (i = 0, len = obj.length; i < len; i++) {\n      value = obj[i];\n      obj[i] = recursivelyConvertPseudotype(value, options);\n    }\n  }\n  else if (obj && typeof obj === 'object') {\n    for (key in obj) {\n      value = obj[key];\n      obj[key] = recursivelyConvertPseudotype(value, options);\n    }\n    obj = convertPseudotype(obj, options);\n  }\n  return obj;\n}\nfunction makeAtom(response, options) {\n  options = options || {};\n  return recursivelyConvertPseudotype(response.r[0], options);\n}\nmodule.exports.makeAtom = makeAtom;\n\nfunction makeSequence(response, options) {\n  options = options || {};\n  return recursivelyConvertPseudotype(response.r, options);\n}\n\nmodule.exports.makeSequence = makeSequence;\n\nfunction changeProto(object, other) {\n  object.__proto__ = other.__proto__;\n}\nmodule.exports.changeProto = changeProto;\n\n// Try to extract the most global address\n// Note: Mutate the input\nfunction getCanonicalAddress(addresses) {\n  // We suppose that the addresses are all valid, and therefore use loose regex\n  for(var i=0; i<addresses.length; i++) {\n    var addresse = addresses[i];\n    if ((/^127(\\.\\d{1,3}){3}$/.test(addresse.host)) || (/0?:?0?:?0?:?0?:?0?:?0?:0?:1/.test(addresse.host))) {\n      addresse.value = 0;\n    }\n    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[eE]80:.*\\:.*\\:/.test(addresse.host))) {\n      addresse.value = 1;\n    }\n    else if (/^169\\.254\\.\\d{1,3}\\.\\d{1,3}$/.test(addresse.host)) {\n      addresse.value = 2;\n    }\n    else if (/^192\\.168\\.\\d{1,3}\\.\\d{1,3}$/.test(addresse.host)) {\n      addresse.value = 3;\n    }\n    else if (/^172\\.(1\\d|2\\d|30|31)\\.\\d{1,3}\\.\\d{1,3}$/.test(addresse.host)) {\n      addresse.value = 4;\n    }\n    else if (/^10(\\.\\d{1,3}){3}$/.test(addresse.host)) {\n      addresse.value = 5;\n    }\n    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[cCdD].*\\:.*\\:/.test('addresse.host'))) {\n      addresse.value = 6;\n    }\n    else {\n      addresse.value = 7;\n    }\n  }\n  var result = addresses[0];\n  var max = addresses[0].value;\n  for(var i=0; i<addresses.length; i++) {\n    if (addresses[i].value > max) {\n      result = addresses[i];\n      max = addresses[i].value;\n    }\n  }\n  return result;\n}\nmodule.exports.getCanonicalAddress = getCanonicalAddress;\n\n\nmodule.exports.localhostAliases = {\n  'localhost': true,\n  '127.0.0.1': true,\n  '::1': true\n}\n\nmodule.exports.tryCatch = function tryCatch(toTry, handleError) {\n  try{\n  toTry()\n  }\n  catch(err) {\n  handleError(err)\n  }\n}\n\nfunction splitCommaEqual(message) {\n  var result = {};\n  var messageParts = message.split(',');\n  for(var i=0; i<messageParts.length; i++) {\n    var equalPosition = messageParts[i].indexOf(\"=\")\n    result[messageParts[i].slice(0, equalPosition)] = messageParts[i].slice(equalPosition+1);\n  }\n  return result;\n}\nmodule.exports.splitCommaEqual = splitCommaEqual;\n\nfunction xorBuffer(a, b) {\n  var result = [];\n  var len = Math.min(a.length, b.length)\n  for(var i=0; i<len; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return new Buffer(result);\n}\nmodule.exports.xorBuffer = xorBuffer;\n\nfunction compareDigest(a, b) {\n  var left = undefined\n  var right = b\n  var result = undefined\n  if (a.length === b.length) {\n    left = a\n    result = 0\n  } else {\n    left = b\n    result = 1\n  }\n  var len = Math.min(a.length, b.length);\n  for(var i=0; i<len; i++) {\n    result |= a[i] ^b[i]\n  }\n  return result === 0\n}\nmodule.exports.compareDigest = compareDigest;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/helper.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js\");\n\nvar helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar Connection = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/connection.js */ \"./node_modules/rethinkdbdash/lib/connection.js\");\nvar Term = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/term.js */ \"./node_modules/rethinkdbdash/lib/term.js\");\nvar Error = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/error.js */ \"./node_modules/rethinkdbdash/lib/error.js\");\nvar PoolMaster = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/pool_master.js */ \"./node_modules/rethinkdbdash/lib/pool_master.js\");\nvar termTypes = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/protodef.js */ \"./node_modules/rethinkdbdash/lib/protodef.js\").Term.TermType;\n\nfunction r() {\n  var self = this;\n  var _r = function(x) {\n    return new Term(_r).expr(x);\n  }\n  helper.changeProto(_r, self);\n\n  Term.prototype._setNestingLevel(r.prototype.nestingLevel);\n  Term.prototype._setArrayLimit(r.prototype.arrayLimit);\n\n  _r.row = new Term(_r).row();\n\n  _r.monday = new Term(_r).monday();\n  _r.tuesday = new Term(_r).tuesday();\n  _r.wednesday = new Term(_r).wednesday();\n  _r.thursday = new Term(_r).thursday();\n  _r.friday = new Term(_r).friday();\n  _r.saturday = new Term(_r).saturday();\n  _r.sunday =  new Term(_r).sunday();\n\n  _r.january = new Term(_r).january();\n  _r.february = new Term(_r).february();\n  _r.march = new Term(_r).march();\n  _r.april = new Term(_r).april();\n  _r.may = new Term(_r).may();\n  _r.june = new Term(_r).june();\n  _r.july = new Term(_r).july();\n  _r.august = new Term(_r).august();\n  _r.september = new Term(_r).september();\n  _r.october = new Term(_r).october();\n  _r.november = new Term(_r).november();\n  _r.december = new Term(_r).december();\n  _r.minval = new Term(_r).minval();\n  _r.maxval = new Term(_r).maxval();\n\n  _r.nextVarId = 1;\n  _r._Term = Term;\n  return _r;\n};\nr.prototype._host = 'localhost';\nr.prototype._port = 28015;\nr.prototype._authKey = '';\nr.prototype._user = 'admin';\nr.prototype._password = '';\nr.prototype._timeoutConnect = 20; // seconds\nr.prototype._pingInterval = -1; // seconds\n\nr.prototype._nestingLevel = 100;\nr.prototype._arrayLimit = 100000;\nr.prototype._db = 'test';\nr.prototype._useOutdated = false;\nr.prototype._timeFormat = 'native';\nr.prototype._profile = false;\n\n\nr.prototype.setNestingLevel = function(nestingLevel) {\n  if (typeof nestingLevel !== 'number') throw new Error.ReqlDriverError('The first argument of `setNestingLevel` must be a number.')\n  this.nestingLevel = nestingLevel;\n}\nr.prototype.setArrayLimit = function(arrayLimit) {\n  if (typeof arrayLimit !== 'number') throw new Error.ReqlDriverError('The first argument of `setArrayLimit` must be a number.')\n  this.arrayLimit = arrayLimit;\n}\n\nr.prototype.connect = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n\n  var p = new Promise(function(resolve, reject) {\n    new Connection(self, options, resolve, reject);\n  }).nodeify(callback);\n  return p;\n};\n\nr.prototype.createPools = function(options) {\n  this._poolMaster = new PoolMaster(this, options);\n  return this;\n}\n\nr.prototype.getPoolMaster = function() {\n  return this._poolMaster;\n}\nr.prototype.getPool = function(i) {\n  if (i === undefined) {\n    if (this.getPoolMaster().getPools().length === 1) {\n      return this.getPoolMaster().getPools()[0];\n    }\n    else {\n      throw new Error('You have multiple pools. Use `getPool(index)` or `getPools()`');\n    }\n  }\n  else {\n    return this.getPoolMaster().getPools()[i];\n  }\n}\n\nr.prototype.expr = function(expression, nestingLevel) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'expr', this);\n  }\n  var _nestingLevel = nestingLevel || this.nestingLevel;\n  return new Term(this).expr(expression, _nestingLevel);\n};\nr.prototype.db = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.db', this);\n  }\n  return new Term(this).db(db);\n};\nr.prototype.table = function(table, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'table', this);\n  }\n  return new Term(this).table(table, options);\n};\nr.prototype.js = function(jsString, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.js', this);\n  }\n  return new Term(this).js(jsString, options);\n};\nr.prototype.tableCreate = function(table, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.tableCreate', this);\n  }\n  return new Term(this).tableCreate(table, options);\n};\nr.prototype.tableDrop = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.tableDrop', this);\n  }\n  return new Term(this).tableDrop(db);\n};\nr.prototype.tableList = function() {\n  if (Term.prototype._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 0, 'r.tableList', this);\n  }\n  return new Term(this).tableList();\n};\nr.prototype.dbCreate = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'dbCreate', this);\n  }\n  return new Term(this).dbCreate(db);\n};\nr.prototype.dbDrop = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'dbDrop', this);\n  }\n  return new Term(this).dbDrop(db);\n};\nr.prototype.dbList = function() {\n  if (Term.prototype._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 0, 'dbList', this);\n  }\n  return new Term(this).dbList();\n};\nr.prototype.literal = function(obj) {\n  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.literal', this);\n  }\n  if (obj === undefined) {\n    return new Term(this).literal();\n  }\n  else {\n    return new Term(this).literal(obj);\n  }\n};\nr.prototype.desc = function(field) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.desc', this);\n  }\n  return new Term(this).desc(field);\n};\nr.prototype.asc = function(field) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.asc', this);\n  }\n  return new Term(this).asc(field);\n};\nr.prototype.union = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this).expr(_args[0]);\n  return term.union.apply(term, _args.slice(1));\n};\nr.prototype.add = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.add', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.add.apply(term, _args.slice(1));\n};\nr.prototype.sub = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.sub', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.sub.apply(term, _args.slice(1));\n};\nr.prototype.div = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.div', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.div.apply(term, _args.slice(1));\n};\nr.prototype.mul = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.mul', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.mul.apply(term, _args.slice(1));\n};\nr.prototype.mod = function(a, b) {\n  if (Term.prototype._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 2, 'r.mod', this);\n  }\n\n  return new Term(this).expr(a).mod(b);\n};\nr.prototype.and = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this);\n  return term.and.apply(term, _args);\n};\nr.prototype.or = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this);\n  return term.or.apply(term, _args);\n};\nr.prototype.eq = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.eq', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.eq.apply(term, _args.slice(1));\n};\nr.prototype.ne = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.ne', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.ne.apply(term, _args.slice(1));\n};\nr.prototype.gt = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.gt', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.gt.apply(term, _args.slice(1));\n};\nr.prototype.ge = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.ge', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.ge.apply(term, _args.slice(1));\n};\nr.prototype.lt = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.lt', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.lt.apply(term, _args.slice(1));\n};\nr.prototype.le = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.le', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.le.apply(term, _args.slice(1));\n};\nr.prototype.not = function(bool) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.not', this);\n  }\n  return new Term(this).expr(bool).not();\n}\nr.prototype.floor = function(num) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.floor', this);\n  }\n  return new Term(this).expr(num).floor();\n}\nr.prototype.ceil = function(num) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.ceil', this);\n  }\n  return new Term(this).expr(num).ceil();\n}\nr.prototype.round = function(num) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.round', this);\n  }\n  return new Term(this).expr(num).round();\n}\n\n\nr.prototype.now = function() {\n  if (Term.prototype._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 0, 'now', this);\n  }\n  return new Term(this).now();\n}\nr.prototype.time = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.time.apply(term, _args);\n}\nr.prototype.epochTime = function(epochTime) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.epochTime', this);\n  }\n  return new Term(this).epochTime(epochTime);\n}\nr.prototype.ISO8601 = function(isoTime, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.ISO8601', this);\n  }\n  return new Term(this).ISO8601(isoTime, options);\n}\nr.prototype.branch = function(predicate, trueBranch, falseBranch) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 3, Infinity, 'r.branch', this);\n\n  var term = new Term(this).expr(predicate);\n  return term.branch.apply(term, _args.slice(1));\n}\nr.prototype.error = function(errorStr) {\n  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 0, 1, 'r.error', this);\n  }\n  var term = new Term(this);\n  term._query.push(termTypes.ERROR);\n  if (errorStr !== undefined) {\n    term._query.push([new Term(this).expr(errorStr)._query]);\n  }\n  return term;\n\n}\nr.prototype.json = function(json) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.json', this);\n  }\n  return new Term(this).json(json);\n}\n\nr.prototype.object = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.object.apply(term, _args);\n}\nr.prototype.args = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.args.apply(term, _args);\n}\nr.prototype.random = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.random.apply(term, _args);\n}\nr.prototype.http = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.http.apply(term, _args);\n}\nr.prototype.do = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.do', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.do.apply(term, _args.slice(1));\n}\nr.prototype.binary = function(bin) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.binary', this);\n  }\n  var term = new Term(this);\n  return term.binary(bin);\n}\nr.prototype.uuid = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 0, 1, 'r.uuid', this);\n  var term = new Term(this);\n  return term.uuid(_args[0]);\n}\n\nr.prototype.line = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.line', this);\n\n  var term = new Term(this);\n  return term.line.apply(term, _args);\n}\nr.prototype.point = function(longitude, latitude) {\n  if (Term.prototype._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 2, 'r.point', this);\n  }\n  return new Term(this).point(longitude, latitude);\n}\nr.prototype.polygon = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 3, Infinity, 'r.polygon', this);\n\n  var term = new Term(this);\n  return term.polygon.apply(term, _args);\n}\nr.prototype.circle = function(center, radius, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 2, 3, 'r.circle', this);\n  }\n  var term = new Term(this);\n  if (options !== undefined) {\n    return term.circle(center, radius, options);\n  }\n  else {\n    return term.circle(center, radius);\n  }\n}\nr.prototype.geojson = function(value) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.geojson', this);\n  }\n  var term = new Term(this);\n  return term.geojson(value);\n}\nr.prototype.distance = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, 3, 'r.add', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.distance.apply(term, _args.slice(1));\n};\n\nr.prototype.range = function(start, end) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, 2, 'r.range', this);\n\n  var term = new Term(this);\n  if (end !== undefined) {\n    return term.range(start, end);\n  }\n  else {\n    return term.range(start);\n  }\n}\nr.prototype.wait = function() {\n  // `wait` on the top level has been removed in 2.3.\n  throw new Error.ReqlDriverError('`wait` can only be called on a table or a database since 2.3');\n}\nr.prototype.reconfigure = function(config) {\n  // `reconfigure` on the top level has been removed in 2.3.\n  throw new Error.ReqlDriverError('`reconfigure` can only be called on a table or a database since 2.3');\n}\nr.prototype.rebalance = function(config) {\n  // `rebalance` on the top level has been removed in 2.3.\n  throw new Error.ReqlDriverError('`rebalance` can only be called on a table or a database since 2.3');\n}\nr.prototype.map = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.map', this);\n\n  var term = new Term(this);\n  return term.map.apply(term, _args);\n};\nr.prototype.typeOf = function(value) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.typeOf', this);\n  }\n  var term = new Term(this);\n  return term.expr(value).typeOf();\n}\nr.prototype.min = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.min', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.min.apply(term, _args.slice(1));\n}\nr.prototype.max = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.max', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.max.apply(term, _args.slice(1));\n}\nr.prototype.sum = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.sum', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.sum.apply(term, _args.slice(1));\n}\nr.prototype.avg = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.avg', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.avg.apply(term, _args.slice(1));\n}\nr.prototype.distinct = function(value) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.distinct', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.distinct.apply(term, _args.slice(1));\n}\n\n\nr.prototype.Error = Error;\n\n\nfunction main(options) {\n  var _r = new r();\n\n  if (!helper.isPlainObject(options)) options = {};\n  if (options.pool !== false) _r.createPools(options);\n  _r._options = {};\n  if (options.cursor === true) _r._options.cursor = true;\n  if (options.stream === true) _r._options.stream = true;\n  if (options.optionalRun === false) {\n    delete _r._Term.prototype.then\n    delete _r._Term.prototype.error\n    delete _r._Term.prototype.catch\n    delete _r._Term.prototype.finally\n  }\n  return _r;\n}\nmodule.exports = main;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/index.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/metadata.js":
/*!****************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/metadata.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Metadata we keep per query\nfunction Metadata(resolve, reject, query, options) {\n  this.resolve = resolve;\n  this.reject = reject;\n  this.query = query; // The query in case we have to build a backtrace\n  this.options = options || {};\n  this.cursor = false;\n}\n\nMetadata.prototype.setCursor = function() {\n  this.cursor = true;\n}\n\nMetadata.prototype.setEnd = function(resolve, reject) {\n  this.endResolve = resolve;\n  this.endReject = reject;\n}\n\nMetadata.prototype.setCallbacks = function(resolve, reject) {\n  this.resolve = resolve;\n  this.reject = reject;\n}\nMetadata.prototype.removeCallbacks = function() {\n  this.resolve = null;\n  this.reject = null;\n}\nMetadata.prototype.removeEndCallbacks = function() {\n  this.endResolve = null;\n  this.endReject = null;\n}\n\nmodule.exports = Metadata;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/metadata.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/pool.js":
/*!************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/pool.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js\");\nvar Dequeue = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/dequeue.js */ \"./node_modules/rethinkdbdash/lib/dequeue.js\");\nvar helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar Err = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/error.js */ \"./node_modules/rethinkdbdash/lib/error.js\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction Pool(r, options) {\n  this._r = r;\n\n  if (!helper.isPlainObject(options)) options = {};\n  this.options = {};\n  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take\n  var buffer = (typeof options.buffer === 'number') ? options.buffer : 50;\n  this.options.buffer = (buffer < this.options.max) ? buffer : this.options.max;\n  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?\n  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out after one hour.\n  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError\n\n  this.options.silent = options.silent || false;\n\n  this.options.connection = {\n    host: options.host || this._r._host,\n    port: options.port || this._r._port,\n    db: options.db || this._r._db,\n    timeout: options.timeout || this._r._timeoutConnect,\n    authKey: options.authKey,\n    user: options.user,\n    password: options.password,\n    cursor: options.cursor || false,\n    stream: options.stream || false,\n    ssl: options.ssl || false,\n    pingInterval: options.pingInterval || this._r._pingInterval\n  }\n  this._log = options._log;\n\n  this._pool = new Dequeue(this.options.buffer+1);\n  this._draining = false;\n  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called\n  this._localhostToDrain = 0; // number of connections to \"localhost\" to remove\n  this._connectionToReplace = 0; // number of connections to \"localhost\" to remove\n\n  this._numConnections = 0;\n  this._openingConnections = 0; // Number of connections being opened\n  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection\n  this._slowGrowth = false;     // Opening one connection at a time\n  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode\n  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close\n\n  this._empty = true;\n\n  var self = this;\n  // So we can let the pool master bind listeners\n  setTimeout(function() {\n    if (self._draining === false) {\n      for(var i=0; i<self.options.buffer; i++) {\n        if (self.getLength() < self.options.max) {\n          self.createConnection();\n        }\n      }\n    }\n  }, 0);\n  this.id = Math.floor(Math.random()*100000);\n  this._log('Creating a pool connected to '+this.getAddress());\n}\n\nutil.inherits(Pool, events.EventEmitter);\n/*\n * Events:\n *  - draining // when `drain` is called\n *  - queueing(size of the queue) // the number of queries being beffered changed\n *  - size(number of connections) // the size of the pool changed\n *  - available-size(available size) // the number of AVAILABLE conncetions of the pool changed\n */\n\nPool.prototype.getConnection = function() {\n  var self = this;\n  var p = new Promise(function(resolve, reject) {\n    if (self._draining === true) {\n      return reject(new Err.ReqlDriverError('The pool is being drained').setOperational());\n    }\n\n    var connection = self._pool.pop();\n    self.emit('available-size', self._pool.getLength());\n    self.emit('available-size-diff', -1);\n\n    if (connection) {\n      clearTimeout(connection.timeout);\n      resolve(connection);\n    }\n    else {\n      if ((self._numConnections === 0) && (self._slowGrowth === true)) {\n        // If the server is down we do not want to buffer the queries\n        return reject(new Err.ReqlDriverError('The pool does not have any opened connections and failed to open a new one').setOperational());\n      }\n    }\n\n    if (self._slowGrowth === false) {\n      self._expandBuffer();\n    }\n\n  });\n  return p;\n};\n\nPool.prototype._decreaseNumConnections = function() {\n  this._numConnections--;\n  this.emit('size', this._numConnections)\n  this.emit('size-diff', -1)\n  if ((this._drainingHandlers !== null) && (this._numConnections === 0)) {\n    this._drainingHandlers.resolve();\n  }\n  // We do not check for this._empty === false because we want to emit empty if the pool\n  // tries to connect to an unavailable server (such that the master can remove it from the\n  // healthy pool\n  if (this._numConnections === 0) {\n    this._empty = true;\n    this.emit('empty');\n  }\n}\nPool.prototype._increaseNumConnections = function() {\n  this._numConnections++;\n  this.emit('size', this._numConnections)\n  this.emit('size-diff', 1)\n}\n\n\nPool.prototype.putConnection = function(connection) {\n  var self = this;\n  if (connection.end === false) {\n    // Temporary attempt to fix #192 - this should not happen.\n    return;\n  }\n  if (self._empty === true) {\n    self._empty = false;\n    // We emit not-empty only we have at least one opened connection\n    self.emit('not-empty');\n  }\n  if ((self._localhostToDrain > 0) && (helper.localhostAliases.hasOwnProperty(connection.host))) {\n    self._localhostToDrain--;\n    connection.close();\n    clearTimeout(connection.timeout);\n    self.createConnection();\n  }\n  else if (self._drainingHandlers !== null) {\n    connection.close();\n    clearTimeout(connection.timeout);\n    if (self.getLength() === 0) {\n      self._drainingHandlers.resolve();\n    }\n  }\n  else if (self._extraConnections > 0) {\n    self._extraConnections--;\n    connection.close().error(function(error) {\n      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));\n    });\n    clearTimeout(connection.timeout);\n  }\n  /*\n  // We let the pool garbage collect these connections\n  else if (self.getAvailableLength()+1 > self.options.buffer) { // +1 for the connection we may put back\n    // Note that because we have available connections here, the pool master has no pending\n    // queries.\n    connection.close().error(function(error) {\n      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));\n    });\n    clearTimeout(connection.timeout);\n  }\n  */\n  else {\n    self._pool.push(connection);\n    self.emit('available-size', self._pool.getLength());\n    self.emit('available-size-diff', 1);\n    self.emit('new-connection', connection);\n\n    clearTimeout(connection.timeout);\n    var timeoutCb = function() {\n      if (self._pool.get(0) === connection) {\n        if (self._pool.getLength() > self.options.buffer) {\n          self._pool.shift().close();\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n        }\n        else {\n          connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);\n        }\n      }\n      else {\n        // This should technically never happens\n        connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);\n      }\n    }\n    connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);\n  }\n};\n\nPool.prototype.createConnection = function() {\n  var self = this;\n  self._increaseNumConnections();\n  self._openingConnections++;\n\n  self.emit('creating-connection', self);\n  if (self._draining === true) {\n    return; // Do not create a new connection if we are draining the pool.\n  }\n\n  return self._r.connect(self.options.connection).then(function(connection) {\n    self.emit('created-connection', self);\n\n    self._openingConnections--;\n\n    if ((self._slowlyGrowing === false) && (self._slowGrowth === true) && (self._openingConnections === 0)) {\n      self._consecutiveFails++;\n      self._slowlyGrowing = true;\n      self.timeoutReconnect = setTimeout(function() {\n        self.createConnection();\n        //self._expandBuffer();\n      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);\n    }\n    // Need another flag\n    else if ((self._slowlyGrowing === true) && (self._slowGrowth === true) && (self._consecutiveFails > 0)) {\n      self._log('Exiting slow growth mode');\n      self._consecutiveFails = 0;\n      self._slowGrowth = false;\n      self._slowlyGrowing = false;\n      self._aggressivelyExpandBuffer();\n    }\n\n\n\n    connection.on('error', function(error) {\n      // We are going to close connection, but we don't want another process to use it before\n      // So we remove it from the pool now (if it's inside)\n      self._log('Error emitted by a connection: '+JSON.stringify(error));\n      for(var i=0; i<self.getAvailableLength(); i++) {\n        if (self._pool.get(i) === this) {\n          self._pool.delete(i);\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n          break;\n        }\n      }\n      // We want to make sure that it's not going to try to reconnect\n      clearTimeout(connection.timeout);\n\n      // Not sure what happened here, so let's be safe and close this connection.\n      connection.close().then(function() {\n        return self._expandBuffer();\n      }).error(function(e) {\n        // We failed to close this connection, but we removed it from the pool... so err, let's just ignore that.\n        self._expandBuffer();\n      });\n    });\n    connection.on('end', function(e) {\n      // The connection was closed by the server, let's clean...\n      for(var i=0; i<self.getAvailableLength(); i++) {\n        if (self._pool.get(i) === this) {\n          self._pool.delete(i);\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n          break;\n        }\n      }\n\n      clearTimeout(connection.timeout);\n      self._decreaseNumConnections();\n      self._expandBuffer();\n    });\n    connection.on('timeout', function() {\n      for(var i=0; i<self.getAvailableLength(); i++) {\n        if (self._pool.get(i) === this) {\n          self._pool.delete(i);\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n          break;\n        }\n      }\n\n      clearTimeout(connection.timeout);\n      self._decreaseNumConnections();\n      self._expandBuffer();\n    });\n    connection.on('release', function() {\n      if (this._isOpen()) self.putConnection(this);\n    });\n    self.putConnection(connection);\n    return null;\n  }).error(function(error) {\n    // We failed to create a connection, we are now going to create connections one by one\n    self._openingConnections--;\n    self._decreaseNumConnections();\n\n    self._slowGrowth = true;\n    if (self._slowlyGrowing === false) {\n      self._log('Entering slow growth mode');\n    }\n    self._slowlyGrowing = true;\n\n    // Log an error\n    self._log('Fail to create a new connection for the connection pool. Error:'+JSON.stringify(error));\n\n    if (self._openingConnections === 0) {\n      self._consecutiveFails++;\n      self.timeoutReconnect = setTimeout(function() {\n        //self._expandBuffer();\n        self.createConnection();\n      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);\n    }\n  })\n};\n\nPool.prototype._aggressivelyExpandBuffer = function() {\n  for(var i=0; i<this.options.buffer; i++) {\n    this._expandBuffer();\n  }\n}\nPool.prototype._expandBuffer = function() {\n  if ((this._draining === false) &&\n      (this._pool.getLength() < this.options.buffer+this._localhostToDrain) &&\n      (this._numConnections < this.options.max+this._localhostToDrain)) {\n    this.createConnection();\n  }\n}\n\nPool.prototype.getLength = function() {\n  return this._numConnections;\n}\nPool.prototype.getAvailableLength = function() {\n  return this._pool.getLength();\n}\n\nPool.prototype.setOptions = function(options) {\n  if (helper.isPlainObject(options)) {\n    for(var key in options) {\n      this.options[key] = options[key];\n    }\n  }\n  return this.options;\n}\nPool.prototype.drainLocalhost = function() {\n  var self = this;\n  // All the connections are to localhost, let's create new ones (not to localhost)\n  self._connectionToReplace = self._numConnections;\n  ;\n  for(var i=0, numConnections=self._numConnections; i<numConnections; i++) {\n    self.createConnection().finally(function() {\n      self._localhostToDrain++;\n      self._connectionToReplace--;\n      if ((self._connectionToReplace === 0) && (self._localhostToDrain > 0)) {\n        var len = self._pool.getLength();\n        for(var j=0; j<len; j++) {\n          if (self._localhostToDrain === 0) {\n            break;\n          }\n          var _connection = self._pool.shift();\n          if (helper.localhostAliases.hasOwnProperty(_connection.host)) {\n            self._localhostToDrain--;\n            _connection.close();\n            clearTimeout(_connection.timeout);\n          }\n          else {\n            self._pool.push(_connection);\n          }\n        }\n      }\n\n    });\n  }\n}\n\nPool.prototype.drain = function() {\n  var self = this;\n  self._draining = true;\n  self._log('Draining the pool connected to '+this.getAddress());\n  self.emit('draining');\n  var p = new Promise(function(resolve, reject) {\n    var connection = self._pool.pop();\n    self.emit('available-size', self._pool.getLength());\n    self.emit('available-size-diff', -1);\n    while(connection) {\n      connection.close();\n      clearTimeout(connection.timeout);\n      connection = self._pool.pop();\n    }\n    if (self.timeoutReconnect !== undefined) {\n      clearTimeout(self.timeoutReconnect);\n      self.timeoutReconnect = null;\n    }\n    if (self.getLength() === 0) {\n      resolve();\n    }\n    else {\n      self._drainingHandlers = {\n        resolve: resolve,\n        reject: reject\n      }\n    }\n  });\n  return p;\n}\n\n\nPool.prototype.getAddress = function() {\n  return this.options.connection.host+':'+this.options.connection.port;\n}\nmodule.exports = Pool;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/pool.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/pool_master.js":
/*!*******************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/pool_master.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! util */ \"util\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js\");\nvar Dequeue = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/dequeue.js */ \"./node_modules/rethinkdbdash/lib/dequeue.js\");\nvar Pool = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/pool.js */ \"./node_modules/rethinkdbdash/lib/pool.js\");\nvar helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar Err = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/error.js */ \"./node_modules/rethinkdbdash/lib/error.js\");\nvar UNKNOWN_POOLS = 'unknownPools';\nvar SEPARATOR = 'feedSeparator';\nfunction PoolMaster(r, options) {\n  var self = this;\n  var options = options || {};\n  var lineLength = options.buffer || 50;\n\n  self._r = r;\n  self._line = new Dequeue(lineLength);\n  self._pools = {};\n  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server'id\n  self._healthyPools = [];\n  self._healthy = false;\n  self._init = false;\n  self._index = 0; // next pool to used\n  self._indexUnknown =  0 // next unknown pool to used\n  self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in discovery mode or not\n  //self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of servers\n  self._options = options;\n  self._options.buffer = options.buffer || 50;\n  self._options.max = options.max || 1000;\n  self._log = helper.createLogger(self, options.silent || false);\n  if (typeof options.log == 'function') {\n    self.on('log', options.log);\n  }\n  self._draining = false;\n  self._numConnections = 0;\n  self._numAvailableConnections = 0;\n  self._hasPrintWarningLocalhost = false;\n  self._feed = null;\n  self._consecutiveFails = -1;\n  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?\n  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError\n\n  //TODO\n  //self._usingPool = true; // If we have used the pool\n  self._seed = 0;\n\n  var pool;\n  if (Array.isArray(options.servers)) {\n    if (options.servers.length > 0) {\n      self._servers = options.servers;\n      for(var i=0; i<options.servers.length; i++) {\n        var settings = self.createPoolSettings(options, options.servers[i], self._log);\n        pool = new Pool(self._r, settings);\n        self._pools[UNKNOWN_POOLS].push(pool);\n        // A pool is considered healthy by default such that people can do\n        // var = require(...)(); query.run();\n        self._healthyPools.push(pool);\n        self.emitStatus()\n      }\n    }\n    else {\n      throw new Err.ReqlDriverError(\"If `servers` is an array, it must contain at least one server\")\n    }\n  }\n  else {\n    self._servers = [{\n      host: options.host || 'localhost',\n      port: options.port || 28015\n    }]\n    var settings = self.createPoolSettings(options, {}, self._log);\n    pool = new Pool(self._r, settings);\n    self._pools[UNKNOWN_POOLS].push(pool);\n    self._healthyPools.push(pool);\n    self.emitStatus()\n  }\n\n  // Initialize all the pools - bind listeners\n  for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {\n    self.initPool(self._pools[UNKNOWN_POOLS][i]);\n  }\n  if ((self._discovery === true)) {\n    self._timeout = setTimeout(function() { self.fetchServers() }, 0);\n  }\n}\nutil.inherits(PoolMaster, events.EventEmitter);\n\nPoolMaster.prototype.getPools = function() {\n  var result = [];\n  helper.loopKeys(this._pools, function(pools, key) {\n    if (key === UNKNOWN_POOLS) {\n      for(var i=0;i<pools[key].length; i++) {\n        result.push(pools[key][i]);\n      }\n    }\n    else {\n      result.push(pools[key]);\n    }\n  });\n  return result;\n}\n\n// Reject all promises in this._line\nPoolMaster.prototype._flushErrors = function() {\n  while(this._line.getLength() > 0) {\n    this._line.shift().reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());\n    this.emit('queueing', this._line.getLength())\n  }\n}\n\nPoolMaster.prototype.getConnection = function() {\n  var self = this;\n  // Find a pool with available connections\n  var result;\n  for(var i=0; i<self._healthyPools.length; i++) {\n    if (self._index >= self._healthyPools.length) {\n      self._index = 0;\n    }\n    if (self._healthyPools[self._index].getAvailableLength() > 0) {\n      result = self._healthyPools[self._index].getConnection();\n    }\n    self._index++;\n    if (self._index === self._healthyPools.length) {\n      self._index = 0;\n    }\n    if (result) {\n      return result;\n    }\n  }\n  if (self._healthyPools.length === 0) {\n    return new Promise(function(resolve, reject) {\n      reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());\n    });\n  }\n  else {\n    // All pool are busy, buffer the request\n    return new Promise(function(resolve, reject) {\n      self._line.push({\n        resolve: resolve,\n        reject: reject\n      });\n\n      self.emit('queueing', self._line.getLength())\n      // We could add a condition to be less greedy (for early start)\n      self._expandAll();\n    });\n\n  }\n}\nPoolMaster.prototype._expandAll = function() {\n  for(var i=0; i<this._healthyPools.length; i++) {\n    this._healthyPools[i]._expandBuffer();\n  }\n}\n\n// Fetch all the servers once\nPoolMaster.prototype.handleAllServersResponse = function(servers) {\n  var self = this;\n  if (self._draining === true) {\n    return;\n  }\n  // Fill all the known server from RethinkDB\n  var knownServer = {};\n  for(var i=0; i<servers.length; i++) {\n    var server = servers[i];\n    knownServer[server.id] = {count: 0, server: server};\n    if (self._pools[server.id] === undefined) {\n      // We potentially have a new server in the cluster, or we already have a pool for this server\n      // in one of the UNKNOWN_POOLS\n      var found = false;\n      for(var j=0; j<self._pools[UNKNOWN_POOLS].length; j++) {\n        if (found) break;\n        var pool = self._pools[UNKNOWN_POOLS][j]; \n        // If a pool is created with localhost, it will probably match the first server even though it may not the the one\n        // So it gets an id\n        for(var k=0; k<server.network.canonical_addresses.length; k++) {\n          // Check for the same host (or if they are both localhost) and port\n          if (((server.network.canonical_addresses[k].host === pool.options.connection.host) ||\n               (server.network.hostname === pool.options.connection.host) ||\n            (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &&\n            helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &&\n            (server.network.reql_port === pool.options.connection.port)) {\n\n            self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];\n            // We may assign the wrong pool to this server if it's maching on localhost\n            if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {\n              self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host;\n              self._pools[server.id].drainLocalhost();\n            }\n            found = true;\n            break;\n          }\n        }\n      }\n      if (found === false) {\n        // We just found a new server, let's extract the canonical address and connect to it\n        self.createPool(server);\n      }\n    }\n  } // Each server know has a pool\n\n  // Check if we need to remove pools\n  helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id\n    if (key !== UNKNOWN_POOLS) {\n      if (knownServer.hasOwnProperty(key) === false) {\n        self.deletePool(key); // We just found a pool that doesn't map to any known RethinkDB server\n      }\n      else {\n        knownServer[key].count++;\n      }\n    }\n  });\n  for(var i=0;i<self._pools[UNKNOWN_POOLS].length; i++) {\n    // These pools does not match any server returned by RethinkDB.\n    var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];\n    self._log('Removing pool connected to: '+pool.getAddress())\n    pool.drain().then(function() {\n      pool.removeAllListeners();\n    }).error(function(error) {\n      self._log('Pool connected to: '+self._pools[UNKNOWN_POOLS][i].getAddress()+' could not be properly drained.')\n      self._log(error.message);\n      self._log(error.stack);\n    });\n  }\n}\n\n// Create the settings for a given pool. Merge the global options + the servers's one.\nPoolMaster.prototype.createPoolSettings = function(globalOptions, serverOptions, log) {\n  var settings = {};\n  var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;\n  helper.loopKeys(globalOptions, function(options, key) {\n    if ((key === 'buffer') || (key === 'max')) {\n      settings[key] = Math.ceil(options[key]/numServers);\n      settings[key] = Math.ceil(options[key]/numServers);\n    }\n    else if (key !== 'servers') {\n      settings[key] = options[key];\n    }\n  });\n  if (serverOptions) {\n    helper.loopKeys(serverOptions, function(options, key) {\n      settings[key] = options[key];\n    });\n  }\n  settings._log = log;\n  return settings;\n}\n\n// Create a new pool\nPoolMaster.prototype.createPool = function(server) {\n  var self = this;\n  var address = helper.getCanonicalAddress(server.network.canonical_addresses);\n  var settings = self.createPoolSettings(self._options, {\n    port: server.network.reql_port,\n    host: address.host\n  }, self._log);\n  var pool = new Pool(self._r, settings);\n  self._pools[server.id] = pool\n  self.initPool(pool);\n  self._healthyPools.push(pool);\n  self.emitStatus()\n  self.resetBufferParameters();\n}\n\n// Delete a known pool\nPoolMaster.prototype.deletePool = function(key) {\n  var self = this;\n  var pool = self._pools[key];\n  self._log('Removing pool connected to: '+pool.getAddress())\n  pool.drain().then(function() {\n    pool.removeAllListeners();\n  }).error(function(error) {\n    self._log('Pool connected to: '+self._pools[key].getAddress()+' could not be properly drained.')\n    self._log(error.message);\n    self._log(error.stack);\n  });\n  delete self._pools[key];\n  self.resetBufferParameters();\n}\n\n//  Create the feed on server_status and bind the listener to the feed\nPoolMaster.prototype.fetchServers = function(useSeeds) {\n  var self = this;\n  var query = self._r.db('rethinkdb').table('server_status')\n      .union([SEPARATOR])\n      .union(self._r.db('rethinkdb').table('server_status').changes())\n  // In case useSeeds is true, we rotate through all the seeds + the pool master\n  if (!useSeeds || self._seed === self._servers.length) {\n    if (useSeeds && self._seed === self._servers.length) {\n      // We increase the back off only when we went through all the seeds\n      self._consecutiveFails++;\n    }\n\n    self._seed = 0;\n    var promise = query.run({cursor: true})\n  }\n  else {\n    var settings = self._servers[self._seed];\n    self._seed++;\n    var promise = self._r.connect(settings).then(function(connection) {\n      return query.run(connection, {cursor: true})\n    });\n  }\n  promise.then(function(feed) {\n    if (self._draining === true) {\n      // There is no need to close the feed here as we'll close the connections\n      return feed.close();\n    }\n    self._feed = feed;\n    var initializing = true;\n    var servers = [];\n    feed.each(function(err, change) {\n      if (err) {\n        self._log('The changefeed on server_status returned an error: '+err.toString());\n        // We have to refetch everything as the server that was serving the feed may\n        // have died.\n        if (!self._draining) {\n          setTimeout(function() {\n            self.fetchServers();\n          }, 0); // Give a timeout to let the driver clean the pools\n        }\n        return;\n      }\n      if (initializing === true) {\n        if (change === SEPARATOR) {\n          initializing = false;\n          self.handleAllServersResponse(servers);\n          // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long\n          // as RethinkDB does not provide initial results\n          setTimeout(function() {\n            self._r.db('rethinkdb').table('server_status').run({cursor: false}).then(function(servers) {\n              self.handleAllServersResponse(servers);\n            }).error(function(error) {\n              self._log('Fail to retrieve a second copy of server_status');\n              //TODO Retry\n            });\n          }, 1000);\n        }\n        else {\n          servers.push(change);\n        }\n        return;\n      }\n\n      if (change.new_val !== null && change.old_val === null) {\n        // New server\n        self.createPool(change.new_val);\n      }\n      else if (change.new_val === null && change.old_val !== null) {\n        // A server was removed\n        var server = change.old_val;\n        if (self._pools[server.id] != null) {\n          self.deletePool(server.id);\n        }\n        else {\n          var found = false;\n          for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {\n            if (((server.network.canonical_addresses[k].host === self._pools[UNKNOWN_POOLS][i].options.connection.host) ||\n              (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) && (helper.localhostAliases.hasOwnProperty(self._pools[UNKNOWN_POOLS][i].options.connection.host)))) &&\n              (server.network.reql_port === self._pools[UNKNOWN_POOLS][i].options.connection.port)) {\n              found = true;\n\n              (function (pool) {\n                self._log('Removing pool connected to: '+pool.getAddress())\n                var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];\n                pool.drain().then(function() {\n                  pool.removeAllListeners();\n                }).error(function(error) {\n                  if (self._options.silent !== true) {\n                    self._log('Pool connected to: '+pool.getAddress()+' could not be properly drained.')\n                    self._log(error.message);\n                    self._log(error.stack);\n                  }\n                });\n              })(self._pools[UNKNOWN_POOLS][i]);\n              break;\n            }\n          }\n        }\n        if (found === false) {\n          self._log('A server was removed but no pool for this server exists...')\n        }\n      }\n      // We ignore this change since this it doesn't affect whether the server\n      // is available or not.\n      // else if (change.new_val !== null && change.old_val !== null) {}\n    });\n    return null;\n  }).error(function(error) {\n    self._log('Could not retrieve the data from server_status: '+JSON.stringify(error));\n    \n    var timeout;\n    if (self._consecutiveFails === -1) {\n      timeout = 0;\n    }\n    else {\n      timeout = (1<<Math.min(self._maxExponent, self._consecutiveFails))*self._timeoutError;\n    }\n    setTimeout(function() {\n      self.fetchServers(true);\n    }, timeout);\n  });\n}\n\n// Bind listeners on the pools\nPoolMaster.prototype.initPool = function(pool) {\n  var self = this;\n\n  pool.on('size-diff', function(diff) {\n    self._numConnections += diff;\n    self.emit('size', self._numConnections)\n  });\n  pool.on('available-size-diff', function(diff) {\n    self._numAvailableConnections += diff;\n    self.emit('available-size', self._numAvailableConnections)\n  });\n\n  pool.on('new-connection', function() {\n    if (self._line.getLength() > 0) {\n      var p = self._line.shift();\n      this.getConnection().then(p.resolve).error(p.reject);\n      self.emit('queueing', self._line.getLength())\n    }\n  });\n  pool.on('not-empty', function() {\n    if (self._draining === false) {\n      var found = false;\n      for(var i=0; i<self._healthyPools.length; i++) {\n        if (self._healthyPools[i] === this) {\n          self._healthyPools.length;\n          found = true;\n          break;\n        }\n      }\n      if (found === false) {\n        self._healthyPools.push(this);\n        self.emitStatus()\n        self.resetBufferParameters();\n      }\n    }\n  });\n  pool.on('empty', function() {\n    // A pool that become empty is considered unhealthy\n    for(var i=0; i<self._healthyPools.length; i++) {\n      if (self._healthyPools[i] === this) {\n        self._healthyPools.splice(i, 1);\n        self.emitStatus()\n        break;\n      }\n    }\n    if (self._healthyPools.length === 0) {\n      self._flushErrors();\n    }\n\n    self.resetBufferParameters();\n  });\n  pool.on('draining', function() {\n    for(var i=0; i<self._healthyPools.length; i++) {\n      if (self._healthyPools[i] === this) {\n        self._healthyPools.splice(i, 1);\n        self.emitStatus()\n        break;\n      }\n    }\n\n    if (self._healthyPools === 0) {\n      self._flushErrors();\n    }\n  });\n}\n\nPoolMaster.prototype.getNumConnections = function() {\n  var sum = 0;\n  for(var i=0; i<this._healthyPools.length; i++) {\n    sum += this._healthyPools[i].getLength();\n  }\n  return sum;\n}\nPoolMaster.prototype.getNumAvailableConnections = function() {\n  var sum = 0;\n  for(var i=0; i<this._healthyPools.length; i++) {\n    sum += this._healthyPools[i].getAvailableLength();\n  }\n  return sum;\n}\n\n// Reset buffer and max for each pool\nPoolMaster.prototype.resetBufferParameters = function() {\n  var max = Math.floor(this._options.max/this._healthyPools.length)\n  var buffer = Math.floor(this._options.buffer/this._healthyPools.length)\n  for(var i=0; i<this._healthyPools.length; i++) {\n    if (this._healthyPools[i].getLength() > max) {\n      this._healthyPools[i]._extraConnections = this._healthyPools[i].getLength()-max;\n    }\n    else {\n      this._healthyPools[i]._extraConnections = 0;\n    }\n    this._healthyPools[i].options.max = max\n    this._healthyPools[i].options.buffer = buffer;\n  }\n}\n\nPoolMaster.prototype.getLength = function() {\n  return this._numConnections;\n}\nPoolMaster.prototype.getAvailableLength = function() {\n  return this._numAvailableConnections;\n}\n\nPoolMaster.prototype.drain = function() {\n  this.emit('draining');\n  if (this._discovery === true) {\n    this._discovery = false;\n    if (this._feed != null) {\n      this._feed.close();\n    }\n  }\n  this._draining = true;\n  var promises = [];\n  var pools = this.getPools();\n  for(var i=0; i<pools.length; i++) {\n    promises.push(pools[i].drain());\n  }\n  this._healthyPools = [];\n  var self = this;\n  return Promise.all(promises).then(function() {\n    for(var i=0; i<pools.length; i++) {\n      pools[i].removeAllListeners();\n    }\n  }).error(function(error) {\n    if (self._options.silent !== true) {\n      self._log('Failed to drain all the pools:');\n      self._log(error.message);\n      self._log(error.stack);\n    }\n  });\n}\n\n// Emit the healthy event with a boolean indicating whether the pool master\n// is healthy or not\nPoolMaster.prototype.emitStatus = function() {\n  var healthy = this._healthyPools.length !== 0;\n  if (this._healthy !== healthy) {\n    this._healthy = healthy;\n    this.emit('healthy', healthy)\n  }\n}\n\nmodule.exports = PoolMaster;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/pool_master.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/protodef.js":
/*!****************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/protodef.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// DO NOT EDIT\n// Autogenerated by convert_protofile\n\nmodule.exports = {\n\tVersionDummy: {\n\t\tVersion: {\n\t\t\tV0_1: 1063369270,\n\t\t\tV0_2: 1915781601,\n\t\t\tV0_3: 1601562686,\n\t\t\tV0_4: 1074539808,\n\t\t\tV1_0: 885177795\n\t\t},\n\t\t\n\t\tProtocol: {\n\t\t\tPROTOBUF: 656407617,\n\t\t\tJSON: 2120839367\n\t\t}\n\t},\n\t\n\tQuery: {\n\t\tQueryType: {\n\t\t\tSTART: 1,\n\t\t\tCONTINUE: 2,\n\t\t\tSTOP: 3,\n\t\t\tNOREPLY_WAIT: 4,\n\t\t\tSERVER_INFO: 5\n\t\t},\n\t\t\n\t\tAssocPair: {}\n\t},\n\t\n\tFrame: {\n\t\tFrameType: {\n\t\t\tPOS: 1,\n\t\t\tOPT: 2\n\t\t}\n\t},\n\t\n\tBacktrace: {},\n\t\n\tResponse: {\n\t\tResponseType: {\n\t\t\tSUCCESS_ATOM: 1,\n\t\t\tSUCCESS_SEQUENCE: 2,\n\t\t\tSUCCESS_PARTIAL: 3,\n\t\t\tWAIT_COMPLETE: 4,\n\t\t\tSERVER_INFO: 5,\n\t\t\tCLIENT_ERROR: 16,\n\t\t\tCOMPILE_ERROR: 17,\n\t\t\tRUNTIME_ERROR: 18\n\t\t},\n\t\t\n\t\tErrorType: {\n\t\t\tINTERNAL: 1000000,\n\t\t\tRESOURCE_LIMIT: 2000000,\n\t\t\tQUERY_LOGIC: 3000000,\n\t\t\tNON_EXISTENCE: 3100000,\n\t\t\tOP_FAILED: 4100000,\n\t\t\tOP_INDETERMINATE: 4200000,\n\t\t\tUSER: 5000000,\n\t\t\tPERMISSION_ERROR: 6000000\n\t\t},\n\t\t\n\t\tResponseNote: {\n\t\t\tSEQUENCE_FEED: 1,\n\t\t\tATOM_FEED: 2,\n\t\t\tORDER_BY_LIMIT_FEED: 3,\n\t\t\tUNIONED_FEED: 4,\n\t\t\tINCLUDES_STATES: 5\n\t\t}\n\t},\n\t\n\tDatum: {\n\t\tDatumType: {\n\t\t\tR_NULL: 1,\n\t\t\tR_BOOL: 2,\n\t\t\tR_NUM: 3,\n\t\t\tR_STR: 4,\n\t\t\tR_ARRAY: 5,\n\t\t\tR_OBJECT: 6,\n\t\t\tR_JSON: 7\n\t\t},\n\t\t\n\t\tAssocPair: {}\n\t},\n\t\n\tTerm: {\n\t\tTermType: {\n\t\t\tDATUM: 1,\n\t\t\tMAKE_ARRAY: 2,\n\t\t\tMAKE_OBJ: 3,\n\t\t\tVAR: 10,\n\t\t\tJAVASCRIPT: 11,\n\t\t\tUUID: 169,\n\t\t\tHTTP: 153,\n\t\t\tERROR: 12,\n\t\t\tIMPLICIT_VAR: 13,\n\t\t\tDB: 14,\n\t\t\tTABLE: 15,\n\t\t\tGET: 16,\n\t\t\tGET_ALL: 78,\n\t\t\tEQ: 17,\n\t\t\tNE: 18,\n\t\t\tLT: 19,\n\t\t\tLE: 20,\n\t\t\tGT: 21,\n\t\t\tGE: 22,\n\t\t\tNOT: 23,\n\t\t\tADD: 24,\n\t\t\tSUB: 25,\n\t\t\tMUL: 26,\n\t\t\tDIV: 27,\n\t\t\tMOD: 28,\n\t\t\tFLOOR: 183,\n\t\t\tCEIL: 184,\n\t\t\tROUND: 185,\n\t\t\tAPPEND: 29,\n\t\t\tPREPEND: 80,\n\t\t\tDIFFERENCE: 95,\n\t\t\tSET_INSERT: 88,\n\t\t\tSET_INTERSECTION: 89,\n\t\t\tSET_UNION: 90,\n\t\t\tSET_DIFFERENCE: 91,\n\t\t\tSLICE: 30,\n\t\t\tSKIP: 70,\n\t\t\tLIMIT: 71,\n\t\t\tOFFSETS_OF: 87,\n\t\t\tCONTAINS: 93,\n\t\t\tGET_FIELD: 31,\n\t\t\tKEYS: 94,\n\t\t\tVALUES: 186,\n\t\t\tOBJECT: 143,\n\t\t\tHAS_FIELDS: 32,\n\t\t\tWITH_FIELDS: 96,\n\t\t\tPLUCK: 33,\n\t\t\tWITHOUT: 34,\n\t\t\tMERGE: 35,\n\t\t\tBETWEEN_DEPRECATED: 36,\n\t\t\tBETWEEN: 182,\n\t\t\tREDUCE: 37,\n\t\t\tMAP: 38,\n\t\t\tFOLD: 187,\n\t\t\tFILTER: 39,\n\t\t\tCONCAT_MAP: 40,\n\t\t\tORDER_BY: 41,\n\t\t\tDISTINCT: 42,\n\t\t\tCOUNT: 43,\n\t\t\tIS_EMPTY: 86,\n\t\t\tUNION: 44,\n\t\t\tNTH: 45,\n\t\t\tBRACKET: 170,\n\t\t\tINNER_JOIN: 48,\n\t\t\tOUTER_JOIN: 49,\n\t\t\tEQ_JOIN: 50,\n\t\t\tZIP: 72,\n\t\t\tRANGE: 173,\n\t\t\tINSERT_AT: 82,\n\t\t\tDELETE_AT: 83,\n\t\t\tCHANGE_AT: 84,\n\t\t\tSPLICE_AT: 85,\n\t\t\tCOERCE_TO: 51,\n\t\t\tTYPE_OF: 52,\n\t\t\tUPDATE: 53,\n\t\t\tDELETE: 54,\n\t\t\tREPLACE: 55,\n\t\t\tINSERT: 56,\n\t\t\tDB_CREATE: 57,\n\t\t\tDB_DROP: 58,\n\t\t\tDB_LIST: 59,\n\t\t\tTABLE_CREATE: 60,\n\t\t\tTABLE_DROP: 61,\n\t\t\tTABLE_LIST: 62,\n\t\t\tCONFIG: 174,\n\t\t\tSTATUS: 175,\n\t\t\tWAIT: 177,\n\t\t\tRECONFIGURE: 176,\n\t\t\tREBALANCE: 179,\n\t\t\tSYNC: 138,\n\t\t\tGRANT: 188,\n\t\t\tINDEX_CREATE: 75,\n\t\t\tINDEX_DROP: 76,\n\t\t\tINDEX_LIST: 77,\n\t\t\tINDEX_STATUS: 139,\n\t\t\tINDEX_WAIT: 140,\n\t\t\tINDEX_RENAME: 156,\n\t\t\tFUNCALL: 64,\n\t\t\tBRANCH: 65,\n\t\t\tOR: 66,\n\t\t\tAND: 67,\n\t\t\tFOR_EACH: 68,\n\t\t\tFUNC: 69,\n\t\t\tASC: 73,\n\t\t\tDESC: 74,\n\t\t\tINFO: 79,\n\t\t\tMATCH: 97,\n\t\t\tUPCASE: 141,\n\t\t\tDOWNCASE: 142,\n\t\t\tSAMPLE: 81,\n\t\t\tDEFAULT: 92,\n\t\t\tJSON: 98,\n\t\t\tTO_JSON_STRING: 172,\n\t\t\tISO8601: 99,\n\t\t\tTO_ISO8601: 100,\n\t\t\tEPOCH_TIME: 101,\n\t\t\tTO_EPOCH_TIME: 102,\n\t\t\tNOW: 103,\n\t\t\tIN_TIMEZONE: 104,\n\t\t\tDURING: 105,\n\t\t\tDATE: 106,\n\t\t\tTIME_OF_DAY: 126,\n\t\t\tTIMEZONE: 127,\n\t\t\tYEAR: 128,\n\t\t\tMONTH: 129,\n\t\t\tDAY: 130,\n\t\t\tDAY_OF_WEEK: 131,\n\t\t\tDAY_OF_YEAR: 132,\n\t\t\tHOURS: 133,\n\t\t\tMINUTES: 134,\n\t\t\tSECONDS: 135,\n\t\t\tTIME: 136,\n\t\t\tMONDAY: 107,\n\t\t\tTUESDAY: 108,\n\t\t\tWEDNESDAY: 109,\n\t\t\tTHURSDAY: 110,\n\t\t\tFRIDAY: 111,\n\t\t\tSATURDAY: 112,\n\t\t\tSUNDAY: 113,\n\t\t\tJANUARY: 114,\n\t\t\tFEBRUARY: 115,\n\t\t\tMARCH: 116,\n\t\t\tAPRIL: 117,\n\t\t\tMAY: 118,\n\t\t\tJUNE: 119,\n\t\t\tJULY: 120,\n\t\t\tAUGUST: 121,\n\t\t\tSEPTEMBER: 122,\n\t\t\tOCTOBER: 123,\n\t\t\tNOVEMBER: 124,\n\t\t\tDECEMBER: 125,\n\t\t\tLITERAL: 137,\n\t\t\tGROUP: 144,\n\t\t\tSUM: 145,\n\t\t\tAVG: 146,\n\t\t\tMIN: 147,\n\t\t\tMAX: 148,\n\t\t\tSPLIT: 149,\n\t\t\tUNGROUP: 150,\n\t\t\tRANDOM: 151,\n\t\t\tCHANGES: 152,\n\t\t\tARGS: 154,\n\t\t\tBINARY: 155,\n\t\t\tGEOJSON: 157,\n\t\t\tTO_GEOJSON: 158,\n\t\t\tPOINT: 159,\n\t\t\tLINE: 160,\n\t\t\tPOLYGON: 161,\n\t\t\tDISTANCE: 162,\n\t\t\tINTERSECTS: 163,\n\t\t\tINCLUDES: 164,\n\t\t\tCIRCLE: 165,\n\t\t\tGET_INTERSECTING: 166,\n\t\t\tFILL: 167,\n\t\t\tGET_NEAREST: 168,\n\t\t\tPOLYGON_SUB: 171,\n\t\t\tMINVAL: 180,\n\t\t\tMAXVAL: 181\n\t\t},\n\t\t\n\t\tAssocPair: {}\n\t}\n}\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/protodef.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/stream.js":
/*!**************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/stream.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Readable = __webpack_require__(/*! stream */ \"stream\").Readable;\nvar Cursor = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/cursor.js */ \"./node_modules/rethinkdbdash/lib/cursor.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n// Experimental, but should work fine.\nfunction ReadableStream(options, cursor) {\n  if (cursor) this._cursor = cursor;\n  this._pending = 0; // How many time we called _read while no cursor was available\n  this._index = 0;\n  this._maxRecursion = 1000; // Hardcoded\n  this._highWaterMark = options.highWaterMark;\n  this._closed = false;\n\n  Readable.call(this, {\n    objectMode: true,\n    highWaterMark: this._highWaterMark\n  });\n};\nutil.inherits(ReadableStream, Readable);\n\n\nReadableStream.prototype._setCursor = function(cursor) {\n  if (cursor instanceof Cursor === false) {\n    this.emit('error', new Error('Cannot create a stream on a single value.'));\n    this.push(null);\n    return this;\n  }\n  this._cursor = cursor;\n  this._fetchAndDecrement();\n}\nReadableStream.prototype._read = function(size) {\n  this._count++;\n  if (this._cursor === undefined) {\n    this._pending++;\n    return;\n  }\n\n  this._recursion = 0;\n  this._fetch();\n}\n\n//TODO: Refactor with _fetch?\nReadableStream.prototype._fetchAndDecrement = function() {\n  var self = this;\n  self._pending--;\n  if (self._pending < 0 || self._closed === true) {\n    return;\n  }\n\n  if (self._cursor._closed === true) {\n    self.push(null);\n  }\n  else {\n    self._cursor._next().then(function(data) {\n      // Silently drop null values for now\n      if (data === null) {\n        if (self._recursion++ === self._maxRecursion) {\n          //Avoid maximum call stack errors\n          process.nextTick(function() {\n            self._fetchAndDecrement();\n          });\n        }\n        else {\n          self._fetchAndDecrement();\n        }\n      }\n      else {\n        if (self.push(data) !== false) {\n          if (self._recursion++ === self._maxRecursion) {\n            process.nextTick(function() {\n              self._fetchAndDecrement();\n            });\n          }\n          else {\n            self._fetchAndDecrement();\n          }\n        }\n      }\n      return null;\n    }).error(function(error) {\n      if (error.message.match(/No more rows in the/)) {\n        self.push(null);\n      }\n      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {\n        // if the user call `close`, the cursor may reject pending requests. We just\n        // ignore them here.\n      }\n      else {\n        self.emit('error', error);\n        self.push(null);\n      }\n    });\n  }\n}\n\nReadableStream.prototype._fetch = function() {\n  var self = this;\n  if (self._closed === true) {\n    return;\n  }\n  if (self._cursor._closed === true) {\n    self.push(null);\n  }\n  else {\n    self._cursor._next().then(function(data) {\n      if (self._closed === true) {\n        return;\n      }\n      // Silently drop null values for now\n      if (data === null) {\n        if (self._recursion++ === self._maxRecursion) {\n          process.nextTick(function() {\n            self._fetch();\n          });\n        }\n        else {\n          self._fetch();\n        }\n      }\n      else {\n        if (self.push(data) !== false) {\n          if (self._recursion++ === self._maxRecursion) {\n            process.nextTick(function() {\n              self._fetch();\n            });\n          }\n          else {\n            self._fetch();\n          }\n        }\n      }\n      return null;\n    }).error(function(error) {\n      if (error.message.match(/No more rows in the/)) {\n        self.push(null);\n      }\n      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {\n        // if the user call `close`, the cursor may reject pending requests. We just\n        // ignore them here.\n      }\n      else {\n        self.emit('error', error);\n        self.push(null);\n      }\n    });\n  }\n}\n\n\nReadableStream.prototype.close = function() {\n  this._closed = true;\n  this.push(null);\n  return this._cursor.close();\n}\n\nmodule.exports = ReadableStream;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/stream.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/term.js":
/*!************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/term.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js\");\nvar protodef = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/protodef.js */ \"./node_modules/rethinkdbdash/lib/protodef.js\");\nvar termTypes = protodef.Term.TermType;\n\nvar Error = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/error.js */ \"./node_modules/rethinkdbdash/lib/error.js\");\nvar helper = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/helper.js */ \"./node_modules/rethinkdbdash/lib/helper.js\");\nvar ReadableStream = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/stream.js */ \"./node_modules/rethinkdbdash/lib/stream.js\");\nvar WritableStream = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/writable_stream.js */ \"./node_modules/rethinkdbdash/lib/writable_stream.js\");\nvar TransformStream = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/transform_stream.js */ \"./node_modules/rethinkdbdash/lib/transform_stream.js\");\n\nfunction Term(r, value, error) {\n  var self = this;\n  var term = function(field) {\n    if (Term.prototype._fastArity(arguments.length, 1) === false) {\n      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n      Term.prototype._arity(_args, 1, '(...)', self);\n    }\n    return term.bracket(field);\n  }\n  helper.changeProto(term, self);\n\n  if (value === undefined) {\n    term._query = [];\n  }\n  else {\n    term._query = value;\n  }\n  term._r = r; // Keep a reference to r for global settings\n\n  if (error !== undefined) {\n    term._error = error;\n    term._frames = [];\n  }\n\n  return term;\n}\n\n// run([connection][, options][, callback])\nTerm.prototype.run = function(connection, options, callback) {\n  var self = this;\n\n  if (self._error != null) {\n    var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});\n    return Promise.reject(error);\n  }\n\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    else {\n      if (!helper.isPlainObject(options)) options = {};\n    }\n\n    if (connection._isOpen() !== true) {\n      return new Promise(function(resolve, reject) {\n        reject(new Error.ReqlDriverError('`run` was called with a closed connection', self._query).setOperational());\n      });\n    }\n    var p = new Promise(function(resolve, reject) {\n      var token = connection._getToken();\n\n      var query = [protodef.Query.QueryType.START];\n      query.push(self._query);\n\n      var _options = {};\n      var sendOptions = false;\n      if (connection.db != null) {\n        sendOptions = true;\n        _options.db = self._r.db(connection.db)._query;\n      }\n\n      if (self._r.arrayLimit != null) {\n        sendOptions = true;\n        _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;\n      };\n\n\n      var keepGoing = true; // we need it just to avoir calling resolve/reject multiple times\n      helper.loopKeys(options, function(options, key) {\n        if (keepGoing === true) {\n          if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||\n            (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||\n            (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||\n            (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {\n\n            sendOptions = true;\n            if (key === 'db') {\n              _options[key] = self._r.db(options[key])._query;\n            }\n            else if (self._translateArgs.hasOwnProperty(key)) {\n              _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query;\n            }\n            else {\n              _options[key] = new Term(self._r).expr(options[key])._query;\n            }\n          }\n          else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&\n              (key !== 'binaryFormat') && (key !== 'cursor') &&\n              (key !== 'readable') && (key !== 'writable') &&\n              (key !== 'transform') && (key !== 'stream') &&\n              (key !== 'highWaterMark')) {\n            reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <bool>, cursor <bool>, stream <bool>'));\n            keepGoing = false;\n          }\n        }\n      });\n\n      if (keepGoing === false) {\n        connection.emit('release');\n        return // The promise was rejected in the loopKeys\n      }\n\n      if (sendOptions === true) {\n        query.push(_options);\n      }\n      connection._send(query, token, resolve, reject, self._query, options);\n    }).nodeify(callback);\n  }\n  else {\n    var poolMaster = self._r.getPoolMaster(); // if self._r is defined, so is self._r.getPool()\n    if (!poolMaster) {\n      throw new Error.ReqlDriverError('`run` was called without a connection and no pool has been created', self._query);\n    }\n    else {\n      if (typeof connection === 'function') {\n        // run(callback);\n        callback = connection;\n        options = {};\n      }\n      else if (helper.isPlainObject(connection)) {\n        // run(options[, callback])\n        callback = options;\n        options = connection;\n      }\n      else {\n        options = {};\n      }\n\n\n      var p = new Promise(function(resolve, reject) {\n        poolMaster.getConnection().then(function(connection) {\n          var token = connection._getToken();\n          var query = [protodef.Query.QueryType.START];\n          query.push(self._query);\n\n          var _options = {};\n          var sendOptions = false;\n          if (connection.db != null) {\n            sendOptions = true;\n            _options.db = self._r.db(connection.db)._query;\n          }\n          if (self._r.arrayLimit != null) {\n            sendOptions = true;\n            _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;\n          };\n\n          var keepGoing = true;\n          helper.loopKeys(options, function(options, key) {\n            if (keepGoing === true) {\n              if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||\n                  (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||\n                  (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||\n                  (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {\n\n\n                sendOptions = true;\n                if (key === 'db') {\n                  _options[key] = self._r.db(options[key])._query;\n                }\n                else if (self._translateArgs.hasOwnProperty(key)) {\n                  _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query\n                }\n                else {\n                  _options[key] = new Term(self._r).expr(options[key])._query\n                }\n              }\n              else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&\n                  (key !== 'binaryFormat') && (key !== 'cursor') &&\n                  (key !== 'readable') && (key !== 'writable') &&\n                  (key !== 'transform') && (key !== 'stream') &&\n                  (key !== 'highWaterMark')) {\n\n                setTimeout( function() {\n                  reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <string>, cursor <bool>, stream <bool>'));\n                }, 0);\n                keepGoing = false;\n                return false;\n              }\n            }\n          });\n\n          if (keepGoing === false) {\n            connection.emit('release');\n            return // The promise was rejected in the loopKeys\n          }\n\n          if (sendOptions === true) {\n            query.push(_options);\n          }\n          connection._send(query, token, resolve, reject, self._query, options);\n        }).error(function(error) {\n          reject(error);\n        });\n      }).nodeify(callback);\n    }\n  }\n\n  //if (options.noreply) return self; // Do not return a promise if the user ask for no reply.\n\n  return p;\n}\n\nTerm.prototype.toStream = function(connection, options) {\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    if (helper.isPlainObject(options) === false) {\n      options = {};\n    }\n    if (options.readable === true) {\n      return this._toReadableStream(connection, options);\n    }\n    else if (options.writable === true) {\n      return this._toWritableStream(connection, options);\n    }\n    else if (options.transform === true) {\n      return this._toTransformStream(connection, options);\n    }\n    else {\n      return this._toReadableStream(connection, options);\n    }\n  }\n  else {\n    options = connection;\n    if (helper.isPlainObject(options) === false) {\n      options = {};\n    }\n    if (options.readable === true) {\n      return this._toReadableStream(options);\n    }\n    else if (options.writable === true) {\n      return this._toWritableStream(options);\n    }\n    else if (options.transform === true) {\n      return this._toTransformStream(options);\n    }\n    else {\n      return this._toReadableStream(options);\n    }\n  }\n}\n\nTerm.prototype._toReadableStream = function(connection, options) {\n  var stream;\n\n  var _options = {};\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    //toStream make sure that options is an object\n    helper.loopKeys(options, function(obj, key) {\n      _options[key] = obj[key];\n    });\n    _options.cursor = true;\n    stream = new ReadableStream(_options);\n    this.run(connection, _options).then(function(cursor) {\n      stream._setCursor(cursor);\n      return null;\n    }).error(function(error) {\n      stream.emit('error', error);\n    });\n  }\n  else {\n    helper.loopKeys(connection, function(obj, key) {\n      _options[key] = obj[key];\n    });\n    _options.cursor = true;\n    stream = new ReadableStream(_options);\n    this.run(_options).then(function(cursor) {\n      stream._setCursor(cursor);\n      return null;\n    }).error(function(error) {\n      stream.emit('error', error);\n    });\n  }\n  return stream;\n}\n\nTerm.prototype._toWritableStream = function(connection, options) {\n  if (this._query[0] !== termTypes.TABLE) {\n    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');\n  }\n\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    return new WritableStream(this, options, connection);\n  }\n  else {\n    return new WritableStream(this, connection);\n  }\n}\nTerm.prototype._toTransformStream = function(connection, options) {\n  if (this._query[0] !== termTypes.TABLE) {\n    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');\n  }\n\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    return new TransformStream(this, options, connection);\n  }\n  else {\n    return new TransformStream(this, connection);\n  }\n}\n\n\n// Manipulating databases\nTerm.prototype.dbCreate = function(db) {\n  // Check for arity is done in r.prototype.dbCreate\n  this._noPrefix(this, 'dbCreate');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB_CREATE);\n  var args = [new Term(this._r).expr(db)._query]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dbDrop = function(db) {\n  this._noPrefix(this, 'dbDrop');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB_DROP);\n  var args = [new Term(this._r).expr(db)._query]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dbList = function() {\n  this._noPrefix(this, 'dbList');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB_LIST)\n  return term;\n}\n\n// Manipulating Tables\nTerm.prototype.tableCreate = function(table, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'tableCreate', self);\n  }\n\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.TABLE_CREATE)\n\n  var args = [];\n  if (Array.isArray(self._query) && (self._query.length > 0)) {\n    args.push(self); // Push db\n  }\n  args.push(new Term(self._r).expr(table))\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    // Check for non valid key\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'primaryKey')\n          && (key !== 'durability')\n          && (key !== 'shards')\n          && (key !== 'replicas')\n          && (key !== 'primaryReplicaTag')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `tableCreate`', self._query, 'Available options are primaryKey <string>, durability <string>, shards <number>, replicas <number/object>, primaryReplicaTag <object>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\nTerm.prototype.tableDrop = function(table) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'tableDrop', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TABLE_DROP)\n\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this); // push db\n  }\n  args.push(new Term(this._r).expr(table))\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.tableList = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'tableList', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TABLE_LIST);\n\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexList = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'indexList', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_LIST);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexCreate = function(name, fn, options) {\n  if (this._fastArityRange(arguments.length, 1, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 3, 'indexCreate', this);\n  }\n\n  if ((options == null) && (helper.isPlainObject(fn))) {\n    options = fn;\n    fn = undefined;\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_CREATE);\n  var args = [this];\n  args.push(new Term(this._r).expr(name));\n  if (typeof fn !== 'undefined') args.push(new Term(this._r).expr(fn)._wrap());\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    // There is no need to translate here\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'multi') && (key !== 'geo')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexCreate`', self._query, 'Available option is multi <bool> and geo <bool>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(options)._query);\n  }\n  return term;\n}\nTerm.prototype.indexDrop = function(name) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'indexDrop', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_DROP);\n  var args = [this, new Term(this._r).expr(name)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.indexStatus = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_STATUS);\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexWait = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_WAIT);\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexRename = function(oldName, newName, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 2, 3, 'indexRename', self);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_RENAME);\n  var args = [this, new Term(this._r).expr(oldName), new Term(this._r).expr(newName)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'overwrite') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexRename`', self._query, 'Available options are overwrite <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n\n\n  return term;\n}\nTerm.prototype.changes = function(options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'changes', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.CHANGES);\n  var args = [self];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'squash') && (key !== 'includeStates') && (key !== 'includeTypes')\n          && (key !== 'includeInitial') && (key !== 'includeOffsets')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `changes`', self._query,\n            'Available options are squash <bool>, includeInitial <bool>, includeStates <bool>, includeOffsets <bool>, includeTypes <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\n// Writing data\nTerm.prototype.insert = function(documents, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'insert', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.INSERT);\n  var args = [self, new Term(self._r).expr(documents)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'conflict')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `insert`', self._query, 'Available options are returnChanges <bool>, durability <string>, conflict <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.update = function(newValue, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'update', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.UPDATE);\n  var args = [self, new Term(self._r).expr(newValue)._wrap()];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `update`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.replace = function(newValue, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'replace', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.REPLACE);\n  var args = [self, new Term(self._r).expr(newValue)._wrap()];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `replace`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.delete = function(options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'delete', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.DELETE);\n  var args = [self];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `delete`', self._query, 'Available options are returnChanges <bool>, durability <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.sync = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'sync', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SYNC)\n  var args = [this._query];\n  term._fillArgs(args);\n  return term;\n}\n\n// Selecting data\nTerm.prototype.db = function(db) {\n  this._noPrefix(this, 'db');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'db', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB)\n  var args = [new Term(this._r).expr(db)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.table = function(table, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'table', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.TABLE)\n\n  var args = [];\n  if (Array.isArray(self._query) && (self._query.length > 0)) {\n    args.push(self);\n  }\n  args.push(new Term(self._r).expr(table))\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'readMode') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `table`', self._query, 'Available option is readMode <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.get = function(primaryKey) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'get', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET);\n  var args = [this, new Term(this._r).expr(primaryKey)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.getAll = function() {\n  // We explicitly _args here, so fastArityRange is not useful\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET_ALL);\n\n  var args = [];\n  args.push(this);\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);\n  }\n  else if (_args.length > 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1]))\n    term._fillArgs(args);\n  } else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.between = function(start, end, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 2, 3, 'between', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.BETWEEN);\n  var args = [self, new Term(self._r).expr(start), new Term(self._r).expr(end)]\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'index') && (key !== 'leftBound') && (key !== 'rightBound')){\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `between`', self._query, 'Available options are index <string>, leftBound <string>, rightBound <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.minval = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MINVAL);\n  return term;\n}\nTerm.prototype.maxval = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAXVAL);\n  return term;\n}\n\nTerm.prototype.filter = function(filter, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'filter', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.FILTER);\n  var args = [self, new Term(self._r).expr(filter)._wrap()]\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'default') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `filter`', self._query, 'Available option is filter');\n      }\n    })\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\n// Joins\nTerm.prototype.innerJoin = function(sequence, predicate) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'innerJoin', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INNER_JOIN);\n  var args = [this._query];\n  args.push(new Term(this._r).expr(sequence)._query);\n  args.push(new Term(this._r).expr(predicate)._wrap()._query);\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.outerJoin = function(sequence, predicate) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'outerJoin', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OUTER_JOIN);\n  var args = [this];\n  args.push(new Term(this._r).expr(sequence));\n  args.push(new Term(this._r).expr(predicate)._wrap());\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.eqJoin = function(rightKey, sequence, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 2, 3, 'eqJoin', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.EQ_JOIN);\n  var args = [self];\n  args.push(new Term(self._r).expr(rightKey)._wrap());\n  args.push(new Term(self._r).expr(sequence));\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'index') && (key !== 'ordered')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `eqJoin`', self._query, 'Available options are index <string>, ordered <boolean>');\n      }\n    })\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.zip = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'zip', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ZIP);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\n\n\n// Transformation\nTerm.prototype.map = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'map', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAP);\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  // Make sure that we don't push undefined if no argument is passed to map,\n  // in which case the server will handle the case and return an error.\n  if (_args.length> 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())\n  }\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.withFields = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'withFields', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.WITH_FIELDS);\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.concatMap = function(transformation) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'concatMap', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CONCAT_MAP);\n  var args = [this];\n  args.push(new Term(this._r).expr(transformation)._wrap())\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.orderBy = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'orderBy', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ORDER_BY);\n\n  var args = [this];\n  for(var i=0; i<_args.length-1; i++) {\n    if ((_args[i] instanceof Term) &&\n        ((_args[i]._query[0] === termTypes.DESC) || (_args[i]._query[0] === termTypes.ASC))) {\n      args.push(new Term(this._r).expr(_args[i]))\n    }\n    else {\n      args.push(new Term(this._r).expr(_args[i])._wrap())\n    }\n  }\n  // We actually don't need to make the difference here, but...\n  if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);\n  }\n  else {\n    if ((_args[_args.length-1] instanceof Term) &&\n      ((_args[_args.length-1]._query[0] === termTypes.DESC) || (_args[_args.length-1]._query[0] === termTypes.ASC))) {\n      args.push(new Term(this._r).expr(_args[_args.length-1]))\n    }\n    else {\n      args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())\n    }\n    term._fillArgs(args);\n  }\n  return term;\n\n}\nTerm.prototype.desc = function(field) {\n  this._noPrefix(this, 'desc');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'desc', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DESC)\n  var args = [new Term(this._r).expr(field)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.asc = function(field) {\n  this._noPrefix(this, 'asc');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'asc', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ASC)\n  var args = [new Term(this._r).expr(field)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.skip = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'skip', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SKIP)\n  var args = [this, new Term(this._r).expr(value)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.limit = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'limit', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LIMIT)\n  var args = [this, new Term(this._r).expr(value)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.slice = function(start, end, options) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 3, 'slice', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SLICE);\n\n  var args = [];\n  args.push(this);\n  args.push(new Term(this._r).expr(start));\n\n  if ((end !== undefined) && (options !== undefined)) {\n    args.push(new Term(this._r).expr(end));\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  else if ((end !== undefined) && (options === undefined)) {\n    if (helper.isPlainObject(end) === false) {\n      args.push(new Term(this._r).expr(end));\n      term._fillArgs(args);\n    }\n    else {\n      term._fillArgs(args);\n      term._query.push(new Term(this._r).expr(translateOptions(end))._query);\n    }\n  }\n  else { // end and options are both undefined\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.nth = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'nth', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NTH)\n  var args = [this._query, new Term(this._r).expr(value)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.offsetsOf = function(predicate) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'indexesOf', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OFFSETS_OF)\n  var args = [this, new Term(this._r).expr(predicate)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexesOf = Term.prototype.offsetsOf;\n\nTerm.prototype.isEmpty = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'isEmpty', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.IS_EMPTY)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.union = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UNION)\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  if ((_args.length > 1) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].interleave !== undefined)) {\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);\n  }\n  else if (_args.length > 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1]))\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.sample = function(size) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'sample', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SAMPLE)\n  var args = [this, new Term(this._r).expr(size)];\n  term._fillArgs(args);\n  return term;\n}\n\n// Aggregations\nTerm.prototype.reduce = function(func) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'reduce', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.REDUCE)\n  var args = [this, new Term(this._r).expr(func)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.count = function(filter) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'count', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.COUNT);\n  var args = [];\n  args.push(this);\n  if (filter !== undefined) {\n    args.push(new Term(this._r).expr(filter)._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.distinct = function(options) {\n  var self= this;\n  if (self._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'distinct', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.DISTINCT)\n  var args = [self];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    var keepGoing = true;\n    helper.loopKeys(options, function(obj, key) {\n      if ((keepGoing === true) && (key !== 'index')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distinct`', self._query, 'Available option is index: <string>');\n        keepGoing = false;\n      }\n    });\n    if (keepGoing === true) {\n      term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n    }\n  }\n\n  return term;\n}\nTerm.prototype.group = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var self = this;\n  self._arityRange(_args, 1, Infinity, 'group', self);\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.GROUP);\n  var args = [self];\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(self._r).expr(_args[i])._wrap())\n  }\n  if (_args.length > 0) {\n    if (helper.isPlainObject(_args[_args.length-1])) {\n      helper.loopKeys(_args[_args.length-1], function(obj, key) {\n         if ((key !== 'index')\n        && (key !==  'multi')) {\n          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `group`', self._query, 'Available options are index: <string>, multi <boolean>');\n        }\n      });\n      term._fillArgs(args);\n      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);\n    }\n    else {\n      args.push(new Term(self._r).expr(_args[_args.length-1])._wrap())\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n\n  return term;\n}\nTerm.prototype.split = function(separator, max) {\n  if (this._fastArityRange(arguments.length, 0, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 2, 'split', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SPLIT)\n  var args = [this];\n  if (separator !== undefined) {\n    args.push(new Term(this._r).expr(separator))\n    if (max !== undefined) {\n      args.push(new Term(this._r).expr(max))\n    }\n  }\n  term._fillArgs(args);\n\n  return term;\n}\n\nTerm.prototype.ungroup = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'ungroup', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UNGROUP)\n  var args = [this._query];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.contains = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'contains', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CONTAINS)\n  var args = [this._query];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i])._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.sum = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'sum', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SUM);\n  var args = [this];\n  if (field !== undefined) {\n    args.push(new Term(this._r).expr(field)._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.avg = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'avg', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.AVG)\n  var args = [this];\n  if (field !== undefined) {\n    args.push(new Term(this._r).expr(field)._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.min = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'min', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MIN)\n  var args = [this];\n  if (field !== undefined) {\n    if (helper.isPlainObject(field)) {\n      term._fillArgs(args);\n      term._query.push(new Term(this._r).expr(translateOptions(field))._query);\n    }\n    else {\n      args.push(new Term(this._r).expr(field)._wrap());\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.max = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'max', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAX)\n  var args = [this];\n  if (field !== undefined) {\n    if (helper.isPlainObject(field)) {\n      term._fillArgs(args);\n      term._query.push(new Term(this._r).expr(translateOptions(field))._query);\n    }\n    else {\n      args.push(new Term(this._r).expr(field)._wrap())\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.fold = function(base, func, options) {\n  if (this._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 2, 3, 'range', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FOLD)\n  var args = [this, new Term(this._r).expr(base), new Term(this._r).expr(func)._wrap()];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'emit') && (key !== 'finalEmit')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `fold`. Available options are emit <function>, finalEmit <function>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\n\n\n// Document manipulation\nTerm.prototype.row = function() {\n  this._noPrefix(this, 'row');\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'r.row', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.IMPLICIT_VAR)\n  return term;\n}\nTerm.prototype.pluck = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'pluck', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.PLUCK)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.without = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'without', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.WITHOUT)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.merge = function(arg) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'merge', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MERGE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i])._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.literal = function(obj) {\n  this._noPrefix(this, 'literal');\n  // The test for arity is performed in r.literal\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LITERAL);\n  if (arguments.length > 0) {\n    var args = [new Term(this._r).expr(obj)];\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.append = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'append', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.APPEND)\n  var args = [this, new Term(this._r).expr(value)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.prepend = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'prepend', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.PREPEND)\n  var args = [this, new Term(this._r).expr(value)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.difference = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'difference', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DIFFERENCE)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setInsert = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setInsert', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_INSERT)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setUnion = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setUnion', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_UNION)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setIntersection = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setIntersection', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_INTERSECTION)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setDifference = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setDifference', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_DIFFERENCE)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.getField = function(field) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, '(...)', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET_FIELD)\n  var args = [this, new Term(this._r).expr(field)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.bracket = function(field) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, '(...)', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.BRACKET)\n  var args = [this, new Term(this._r).expr(field)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.hasFields = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'hasFields', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.HAS_FIELDS)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n\n}\nTerm.prototype.insertAt = function(index, value) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'insertAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INSERT_AT)\n  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(value)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.spliceAt = function(index, array) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'spliceAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SPLICE_AT)\n  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(array)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.deleteAt = function(start, end) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'deleteAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DELETE_AT);\n  var args = [this, new Term(this._r).expr(start)];\n  if (end !== undefined) {\n    args.push(new Term(this._r).expr(end))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.changeAt = function(index, value) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'changeAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CHANGE_AT);\n  var args = [this];\n  args.push(new Term(this._r).expr(index))\n  args.push(new Term(this._r).expr(value))\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.keys = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'keys', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.KEYS)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.values = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'keys', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.VALUES)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.object = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._noPrefix(this, 'object');\n  this._arityRange(_args, 0, Infinity, 'object', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OBJECT)\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\n\n\n\n// String\nTerm.prototype.match = function(regex) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'match', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MATCH)\n  var args = [this, new Term(this._r).expr(regex)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.upcase = function(regex) {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'upcase', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UPCASE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.downcase = function(regex) {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'upcase', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DOWNCASE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\n\n\n\n// Math and Logic\nTerm.prototype.add = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'add', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ADD)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.sub = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'sub', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SUB)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.mul = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'mul', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MUL)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.div = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'div', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DIV)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.mod = function(b) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'mod', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MOD)\n  var args = [this, new Term(this._r).expr(b)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.and = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.AND)\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.or = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OR)\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.eq = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'eq', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.EQ)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ne = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'ne', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.gt = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'gt', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GT)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ge = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'ge', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.lt = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'lt', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LT)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.le = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'le', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.not = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'not', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NOT)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.random = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var self = this;\n  self._noPrefix(this, 'random');\n  self._arityRange(_args, 0, 3, 'random', self);\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.RANDOM);\n\n  var args = [];\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(self._r).expr(_args[i]))\n  }\n  if (_args.length > 0) {\n    if (helper.isPlainObject(_args[_args.length-1])) {\n      helper.loopKeys(_args[_args.length-1], function(obj, key) {\n        if (key !== 'float') {\n          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `random`', self._query, 'Available option is float: <boolean>');\n        }\n      });\n      term._fillArgs(args);\n      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);\n    }\n    else {\n      args.push(new Term(self._r).expr(_args[_args.length-1]))\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.floor = function() {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'floor', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FLOOR)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ceil = function() {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'ceil', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CEIL)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.round = function() {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'round', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ROUND)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\n// Dates and times\nTerm.prototype.now = function() {\n  this._noPrefix(this, 'now');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NOW)\n  return term;\n}\nTerm.prototype.time = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._noPrefix(this, 'time');\n  // Special check for arity\n  var foundArgs = false;\n  for(var i=0; i<_args.length; i++) {\n    if ((_args[i] instanceof Term) && (_args[i]._query[0] === termTypes.ARGS)) {\n      foundArgs = true;\n      break;\n    }\n  }\n  if (foundArgs === false) {\n    if ((_args.length !== 4) && (_args.length !== 7)) {\n      throw new Error.ReqlDriverError('`r.time` called with '+_args.length+' argument'+((_args.length>1)?'s':''), null, '`r.time` takes 4 or 7 arguments');\n    }\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TIME)\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.epochTime = function(epochTime) {\n  this._noPrefix(this, 'epochTime');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.EPOCH_TIME)\n  var args = [new Term(this._r).expr(epochTime)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ISO8601 = function(isoTime, options) {\n  this._noPrefix(this, 'ISO8601');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'ISO8601', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ISO8601)\n  var args = [new Term(this._r).expr(isoTime)._query];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'defaultTimezone') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `ISO8601`. Available options are primaryKey <string>, durability <string>, datancenter <string>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n\n  return term;\n}\nTerm.prototype.inTimezone = function(timezone) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'inTimezone', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.IN_TIMEZONE)\n  var args = [this, new Term(this._r).expr(timezone)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.timezone = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'timezone', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TIMEZONE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.during = function(left, right, options) {\n  if (this._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 2, 3, 'during', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DURING);\n  var args = [];\n  args.push(this);\n  args.push(new Term(this._r).expr(left));\n  args.push(new Term(this._r).expr(right));\n\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.date = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'date', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DATE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.timeOfDay = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'timeOfDay', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TIME_OF_DAY)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.year = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'year', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.YEAR)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.month = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'month', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MONTH)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.day = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'day', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DAY)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dayOfYear = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'dayOfYear', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DAY_OF_YEAR)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dayOfWeek = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'dayOfWeek', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DAY_OF_WEEK)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.hours = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'hours', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.HOURS)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.minutes = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'minutes', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MINUTES)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.seconds = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'seconds', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SECONDS)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toISO8601 = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toISO8601', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_ISO8601)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toEpochTime = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toEpochTime', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_EPOCH_TIME)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.monday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MONDAY);\n  return term;\n}\nTerm.prototype.tuesday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.TUESDAY);\n  return term;\n}\nTerm.prototype.wednesday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.WEDNESDAY);\n  return term;\n}\nTerm.prototype.thursday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.THURSDAY);\n  return term;\n}\nTerm.prototype.friday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.FRIDAY);\n  return term;\n}\nTerm.prototype.saturday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.SATURDAY);\n  return term;\n}\nTerm.prototype.sunday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.SUNDAY);\n  return term;\n}\n\nTerm.prototype.january = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.JANUARY);\n  return term;\n}\nTerm.prototype.february = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.FEBRUARY);\n  return term;\n}\nTerm.prototype.march = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MARCH);\n  return term;\n}\nTerm.prototype.april = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.APRIL);\n  return term;\n}\nTerm.prototype.may = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAY);\n  return term;\n}\nTerm.prototype.june = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.JUNE);\n  return term;\n}\nTerm.prototype.july = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.JULY);\n  return term;\n}\nTerm.prototype.august = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.AUGUST);\n  return term;\n}\nTerm.prototype.september = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.SEPTEMBER);\n  return term;\n}\nTerm.prototype.october = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.OCTOBER);\n  return term;\n}\nTerm.prototype.november = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.NOVEMBER);\n  return term;\n}\nTerm.prototype.december = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.DECEMBER);\n  return term;\n}\n\n\nTerm.prototype.args = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._noPrefix(this, 'args');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ARGS);\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.do = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FUNCALL);\n  var args = [];\n  if (_args.length > 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap()._query);\n  }\n  args.push(this);\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\n\n\nTerm.prototype.branch = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 2, Infinity, '', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.BRANCH)\n  var args = [];\n  args.push(this);\n  for(var i=0; i<_len; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.forEach = function(func) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'forEach', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FOR_EACH);\n  var args = [this, new Term(this._r).expr(func)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.default = function(expression) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'default', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DEFAULT);\n  var args = [this, new Term(this._r).expr(expression)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.expr = function(expression, nestingLevel) {\n  var self = this;\n  self._noPrefix(self, 'expr');\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'expr', self);\n  }\n\n  // undefined will be caught in the last else\n  var ar, obj;\n\n  if (expression === undefined) {\n    var error = 'Cannot convert `undefined` with r.expr()';\n    return new Term(self._r, expression, error);\n  }\n\n  var _nestingLevel = nestingLevel;\n  if (_nestingLevel == null) {\n    _nestingLevel = self._r.nestingLevel;\n  }\n  //if (nestingLevel == null) nestingLevel = self._r.nestingLevel;\n  if (_nestingLevel < 0) throw new Error.ReqlDriverError('Nesting depth limit exceeded.\\nYou probably have a circular reference somewhere')\n\n  if (expression instanceof Term) {\n    return expression;\n  }\n  else if (expression instanceof Function) {\n    return new Func(self._r, expression);\n  }\n  else if (expression instanceof Date) {\n    return new Term(self._r).ISO8601(expression.toISOString())\n  }\n  else if (Array.isArray(expression)) {\n    var term = new Term(self._r);\n    term._query.push(termTypes.MAKE_ARRAY);\n\n    var args = [];\n    for(var i=0; i<expression.length; i++) {\n      args.push(new Term(self._r).expr(expression[i], _nestingLevel-1))\n    }\n    term._fillArgs(args);\n    return term;\n  }\n  else if (expression instanceof Buffer) {\n    return self._r.binary(expression);\n  }\n  else if (helper.isPlainObject(expression)) {\n    var term = new Term(self._r);\n    var optArgs = {};\n    var foundError = false;\n    helper.loopKeys(expression, function(expression, key) {\n      if (expression[key] !== undefined) {\n        var optArg = new Term(self._r).expr(expression[key], _nestingLevel-1);\n        if (optArg instanceof Term && !foundError && optArg._error != null) {\n          foundError = true;\n          term._error = optArg._error;\n          term._frames = [key].concat(optArg._frames);\n        }\n        optArgs[key] = optArg._query;\n      }\n    });\n    term._query = optArgs;\n    return term;\n  }\n  else { // Primitive\n    if (expression === null) {\n      return new Term(self._r, null, expression);\n    }\n    else if (typeof expression === 'string') {\n      return new Term(self._r, expression);\n    }\n    else if (typeof expression === 'number') {\n      if (expression !== expression) {\n        var error = 'Cannot convert `NaN` to JSON';\n        return new Term(self._r, expression, error);\n      }\n      else if (!isFinite(expression)) {\n        var error = 'Cannot convert `Infinity` to JSON';\n        return new Term(self._r, expression, error);\n      }\n      return new Term(self._r, expression);\n    }\n    else if (typeof expression === 'boolean') {\n      return new Term(self._r, expression);\n    }\n    else {\n      self._error = new Error.ReqlDriverError('Cannot convert `'+expression+'` to datum.');\n      self._frames = [];\n    }\n  }\n  return self;\n}\n\nTerm.prototype.binary = function(bin) {\n  this._noPrefix(this, 'binary');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'binary', this);\n  }\n\n  var term;\n  if (bin instanceof Buffer) {\n    // We could use BINARY, and coerce `bin` to an ASCII string, but that\n    // will break if there is a null char\n    term = new Term(this._r, {\n      $reql_type$: 'BINARY',\n      data: bin.toString('base64')\n    });\n  }\n  else {\n    term = new Term(this._r);\n    term._query.push(termTypes.BINARY)\n    var args = [new Term(this._r).expr(bin)];\n    term._fillArgs(args);\n  }\n  return term;\n}\n\nTerm.prototype.js = function(arg, options) {\n  this._noPrefix(this, 'js');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'js', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.JAVASCRIPT)\n  var args = [new Term(this._r).expr(arg)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.coerceTo = function(type) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'coerceTo', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.COERCE_TO)\n  var args = [this, new Term(this._r).expr(type)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.typeOf = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'typeOf', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TYPE_OF);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.info = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'info', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INFO);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.json = function(json) {\n  this._noPrefix(this, 'json');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'info', this);\n  }\n  /*\n  if ((/\\\\u0000/.test(json)) || (/\\0/.test(json))) {\n    this._error = new Error.ReqlDriverError('The null character is currently not supported by RethinkDB');\n  }\n  */\n  var term = new Term(this._r);\n  term._query.push(termTypes.JSON);\n\n  var args = [new Term(this._r).expr(json)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.http = function(url, options) {\n  this._noPrefix(this, 'http');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'http', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.HTTP);\n  var args = [new Term(this._r).expr(url)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'timeout')\n        && (key !==  'attempts')\n        && (key !==  'redirects')\n        && (key !==  'verify')\n        && (key !==  'resultFormat')\n        && (key !==  'method')\n        && (key !==  'auth')\n        && (key !==  'params')\n        && (key !==  'header')\n        && (key !==  'data')\n        && (key !==  'page')\n        && (key !==  'pageLimit')\n        && (key !==  '')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `http`. Available options are attempts <number>, redirects <number>, verify <boolean>, resultFormat: <string>, method: <string>, auth: <object>, params: <object>, header: <string>, data: <string>, page: <string/function>, pageLimit: <number>');\n      }\n    });\n\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.uuid = function(str) {\n  this._noPrefix(this, 'uuid');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UUID)\n\n  if (str !== undefined) {\n    var args = [new Term(this._r).expr(str)];\n    term._fillArgs(args);\n  }\n  return term;\n}\n\n\nTerm.prototype.circle = function(center, radius, options) {\n  var self = this;\n\n  // Arity check is done by r.circle\n  self._noPrefix(self, 'circle');\n  var term = new Term(self._r);\n  term._query.push(termTypes.CIRCLE);\n  var args = [new Term(self._r).expr(center), new Term(self._r).expr(radius)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    // There is no need to translate here\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'numVertices') && (key !== 'geoSystem') && (key !== 'unit') && (key !== 'fill')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `circle`', self._query, 'Available options are numVertices <number>, geoSsystem <string>, unit <string> and fill <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n\n  return term;\n}\nTerm.prototype.distance = function(geometry, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'distance', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.DISTANCE);\n  var args = [self, new Term(self._r).expr(geometry)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'geoSystem') && (key !== 'unit')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are geoSystem <string>, unit <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.fill = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'fill', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.FILL);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.geojson = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'geojson', this);\n  }\n  this._noPrefix(this, 'geojson');\n  var term = new Term(this._r);\n  term._query.push(termTypes.GEOJSON);\n  var args = [new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.toGeojson = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toGeojson', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_GEOJSON);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.getIntersecting = function(geometry, options) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'getIntersecting', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET_INTERSECTING);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'index') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are index <string>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\nTerm.prototype.getNearest = function(geometry, options) {\n  var self = this;\n  if (self._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arity(_args, 2, 'getNearest', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.GET_NEAREST);\n  var args = [self, new Term(self._r).expr(geometry)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'index') && (key !== 'maxResults') && (key !== 'maxDist') && (key !== 'unit') && (key !== 'geoSystem')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `getNearest`', self._query, 'Available options are index <string>, maxResults <number>, maxDist <number>, unit <string>, geoSystem <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n\n}\n\nTerm.prototype.includes = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'includes', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.INCLUDES);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.intersects = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'intersects', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.INTERSECTS);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.line = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  // Arity check is done by r.line\n  this._noPrefix(this, 'line');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LINE);\n\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.point = function(longitude, latitude) {\n  // Arity check is done by r.point\n  this._noPrefix(this, 'point');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.POINT);\n  var args = [new Term(this._r).expr(longitude), new Term(this._r).expr(latitude)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.polygon = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  // Arity check is done by r.polygon\n  this._noPrefix(this, 'polygon');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.POLYGON);\n\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n\n  return term;\n}\n\nTerm.prototype.polygonSub = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'polygonSub', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.POLYGON_SUB);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.range = function(start, end) {\n  this._noPrefix(this, 'range');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'r.range', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.RANGE);\n  var args = [];\n  args.push(new Term(this._r).expr(start));\n  if (end !== undefined) {\n    args.push(new Term(this._r).expr(end));\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toJsonString = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toJSON', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_JSON_STRING);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toJSON = Term.prototype.toJsonString;\n\nTerm.prototype.config = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'config', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.CONFIG);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.status = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'status', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.STATUS);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.wait = function(options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'wait', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.WAIT);\n  var args = [self];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'waitFor') && (key !== 'timeout')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `wait`', self._query, 'Available options are waitFor: <string>, timeout: <number>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n\n  return term;\n}\n\nTerm.prototype.reconfigure = function(config) {\n  var self = this;\n  if (self._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arity(_args, 1, 'reconfigure', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.RECONFIGURE);\n\n  var args = [this];\n  term._fillArgs(args);\n  if (helper.isPlainObject(config)) {\n    helper.loopKeys(config, function(obj, key) {\n      if ((key !== 'shards') && (key !== 'replicas') &&\n        (key !== 'dryRun') && (key !== 'primaryReplicaTag') &&\n        (key !== 'nonvotingReplicaTags') && (key !== 'emergencyRepair')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `reconfigure`', self._query, 'Available options are shards: <number>, replicas: <number>, primaryReplicaTag: <object>, dryRun <boolean>, emergencyRepair: <string>, nonvotingReplicaTags: <array<string>>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(config))._query);\n  }\n  else {\n    throw new Error.ReqlDriverError('First argument of `reconfigure` must be an object');\n  }\n  return term;\n}\n\nTerm.prototype.rebalance = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'rebalance', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.REBALANCE);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.grant = function(name, access) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'grant', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GRANT)\n  var args = [this, new Term(this._r).expr(name), new Term(this._r).expr(access)];\n  term._fillArgs(args);\n  return term;\n}\n\n\nTerm.prototype.then = function(resolve, reject) {\n  return this.run().then(resolve, reject);\n}\nTerm.prototype.error = function(reject) {\n  return this.run().error(reject);\n}\nTerm.prototype.catch = function(reject) {\n  return this.run().catch(reject);\n}\nTerm.prototype.finally = function(handler) {\n  return this.run().finally(handler);\n}\nTerm.prototype.delay = function(msecs) {\n  return this.run().delay(msecs);\n}\n\nTerm.prototype.toString = function() {\n  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;\n}\n\nTerm.prototype._wrap = function() {\n  var self = this;\n  if (helper.hasImplicit(this._query)) {\n    if (this._query[0] === termTypes.ARGS) {\n      throw new Error.ReqlDriverError('Implicit variable `r.row` cannot be used inside `r.args`')\n    }\n    //Must pass at least one variable to the function or it won't accept r.row\n    return new Term(this._r).expr(function(doc) { return self; })\n  }\n  else {\n    return self;\n  }\n}\n\nTerm.prototype._fillArgs = function(args) {\n  var foundError = false;\n  var internalArgs = [];\n  for(var i=0; i<args.length; i++) {\n  if (args[i] instanceof Term) {\n    internalArgs.push(args[i]._query);\n    if (!foundError && (args[i]._error != null)) {\n    this._error = args[i]._error;\n    this._frames = args[i]._frames;\n    this._frames.unshift(i);\n    foundError = true;\n    }\n  }\n  else {\n    internalArgs.push(args[i]);\n  }\n  }\n  this._query.push(internalArgs);\n  return this;\n}\n\nTerm.prototype._translateArgs = {\n  returnChanges: 'return_changes',\n  includeInitial: 'include_initial',\n  primaryKey: 'primary_key',\n  readMode: 'read_mode',\n  nonAtomic: 'non_atomic',\n  leftBound: 'left_bound',\n  rightBound: 'right_bound',\n  defaultTimezone: 'default_timezone',\n  noReply: 'noreply',\n  resultFormat: 'result_format',\n  pageLimit: 'page_limit',\n  arrayLimit: 'array_limit',\n  numVertices: 'num_vertices',\n  geoSystem: 'geo_system',\n  maxResults: 'max_results',\n  maxDist: 'max_dist',\n  dryRun: 'dry_run',\n  waitFor: 'wait_for',\n  includeStates: 'include_states',\n  primaryReplicaTag: 'primary_replica_tag',\n  emergencyRepair: 'emergency_repair',\n  minBatchRows: 'min_batch_rows',\n  maxBatchRows: 'max_batch_rows',\n  maxBatchBytes: 'max_batch_bytes',\n  maxBatchSeconds: 'max_batch_seconds',\n  firstBatchScaledownFactor: 'first_batch_scaledown_factor',\n  includeOffsets: 'include_offsets',\n  includeTypes: 'include_types',\n  finalEmit: 'final_emit'\n}\nfunction translateOptions(options) {\n  var translatedOpt = {};\n  helper.loopKeys(options, function(options, key) {\n    var keyServer = Term.prototype._translateArgs[key] || key;\n    translatedOpt[keyServer] = options[key];\n  });\n  return translatedOpt;\n}\nTerm.prototype._setNestingLevel = function(nestingLevel) {\n  Term.prototype._nestingLevel = nestingLevel;\n}\nTerm.prototype._setArrayLimit = function(arrayLimit) {\n  Term.prototype._arrayLimit = arrayLimit;\n}\n\n\nTerm.prototype._noPrefix = function(term, method) {\n  if ((!Array.isArray(term._query)) || (term._query.length > 0)) {\n    throw new Error.ReqlDriverError('`'+method+'` is not defined', term._query);\n  }\n}\nTerm.prototype._arityRange = function(args, min, max, method, term) {\n  var foundArgs = false;\n  if (args.length < min) {\n    for(var i=0; i<args.length; i++) {\n      if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {\n        foundArgs = true;\n        break;\n      }\n    }\n    if (foundArgs === false) {\n      throw new Error.ReqlDriverError('`'+method+'` takes at least '+min+' argument'+((min>1)?'s':'')+', '+args.length+' provided', term._query);\n    }\n  }\n  else if (args.length > max) {\n    for(var i=0; i<args.length; i++) {\n      if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {\n        foundArgs = true;\n        break;\n      }\n    }\n    if (foundArgs === false) {\n      throw new Error.ReqlDriverError('`'+method+'` takes at most '+max+' argument'+((max>1)?'s':'')+', '+args.length+' provided', term._query);\n    }\n  }\n}\nTerm.prototype._arity = function(args, num, method, term) {\n  var foundArgs = false;\n  for(var i=0; i<args.length; i++) {\n    if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {\n      foundArgs = true;\n      break;\n    }\n  }\n  if (foundArgs === false) {\n    throw new Error.ReqlDriverError('`'+method+'` takes '+num+' argument'+((num>1)?'s':'')+', '+args.length+' provided', term._query);\n  }\n}\n// Cheap arity check. If it fails, return false, and then we are expected to call _arity/_arityRange\nTerm.prototype._fastArity = function(len, num) {\n  return (len === num);\n}\nTerm.prototype._fastArityRange = function(len, min, max) {\n  return ((len >= min) && (len <= max));\n}\n\n\n// Datums\nfunction Func(r, func) {\n  // We can retrieve the names of the arguments with\n  // func.toString().match(/\\(([^\\)]*)\\)/)[1].split(/\\s*,\\s*/)\n\n  var term = new Term(r);\n  term._query.push(termTypes.FUNC);\n  var args = [];\n  var argVars = [];\n  var argNums = [];\n\n  for(var i=0; i<func.length; i++) {\n    argVars.push(new Var(r, r.nextVarId));\n    argNums.push(r.nextVarId);\n\n    if (r.nextVarId === 9007199254740992) { // That seems like overdoing it... but well maybe...\n      r.nextVarId = 0;\n    }\n    else {\n      r.nextVarId++;\n    }\n  }\n\n  var body = func.apply(func, argVars)\n  if (body === undefined) throw new Error.ReqlDriverError('Anonymous function returned `undefined`. Did you forget a `return`? In:\\n'+func.toString(), this._query);\n  body = new Term(r).expr(body);\n  args.push(new Term(r).expr(argNums));\n  args.push(body);\n\n  term._fillArgs(args);\n\n  return term;\n}\nFunc.prototype.nextVarId = 1;\n\nfunction Var(r, id) {\n  var term = new Term(r);\n  term._query.push(termTypes.VAR)\n  term._query.push([new Term(r).expr(id)._query])\n  return term;\n}\n\nmodule.exports = Term;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/term.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/transform_stream.js":
/*!************************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/transform_stream.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! stream */ \"stream\").Transform;\nvar Cursor = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/cursor.js */ \"./node_modules/rethinkdbdash/lib/cursor.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n// Experimental, but should work fine.\nfunction TransformStream(table, options, connection) {\n  this._table = table;\n  this._r = table._r;\n  this._options = options;\n  this._cache = [];\n  this._pendingCallback = null;\n  this._ended = false;\n  this._inserting = false;\n  this._delayed = false;\n  this._connection = connection;\n  this._highWaterMark = options.highWaterMark || 100;\n  this._insertOptions = {};\n  this._insertOptions.durability = options.durability || 'hard';\n  this._insertOptions.conflict = options.conflict || 'error';\n  this._insertOptions.returnChanges = options.returnChanges || true;\n\n  // Internal option to run some tests\n  if (options.debug === true) {\n    this._sequence = [];\n  }\n\n  Transform.call(this, {\n    objectMode: true,\n    highWaterMark: this._highWaterMark\n  });\n};\nutil.inherits(TransformStream, Transform);\n\nTransformStream.prototype._transform = function(value, encoding, done) {\n  this._cache.push(value);\n  this._next(value, encoding, done);\n}\n\n// Everytime we want to insert but do not have a full buffer,\n// we recurse with setImmediate to give a chance to the input\n// stream to push a few more elements\nTransformStream.prototype._next = function(value, encoding, done) {\n  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {\n    // There's more data to buffer\n    if (this._cache.length < this._highWaterMark) {\n      this._delayed = false;\n      // Call done now, and more data will be put in the cache\n      done();\n    }\n    else {\n      if (this._inserting === false) {\n        if (this._delayed === true) {\n          // We have to flush\n          this._delayed = false;\n          this._insert();\n          // Fill the buffer while we are inserting data\n          done();\n        }\n        else {\n          var self = this;\n          this._delayed = true;\n          setImmediate(function() {\n            self._next(value, encoding, done);\n          })\n        }\n\n      }\n      else {\n        // to call when we are dong inserting to keep buffering\n        this._pendingCallback = done;\n      }\n    }\n  }\n  else { // We just pushed the last element in the internal buffer\n    if (this._inserting === false) {\n      if (this._delayed === true) {\n        this._delayed = false;\n        // to call when we are dong inserting to maybe flag the end\n        this._insert();\n        // We can call done now, because we have _flush to close the stream\n        done();\n      }\n      else {\n        var self = this;\n        this._delayed = true;\n        setImmediate(function() {\n          self._next(value, encoding, done);\n        })\n      }\n    }\n    else {\n      this._delayed = false;\n      // There is nothing left in the internal buffer\n      // But something is already inserting stuff.\n      if (this._cache.length < this._highWaterMark-1) {\n        // Call done, to attempt to buffer more\n        // This may trigger _flush\n        //this._pendingCallback = done;\n        done();\n      }\n      else {\n        this._pendingCallback = done;\n      }\n    }\n  }\n}\n\nTransformStream.prototype._insert = function() {\n  var self = this;\n  self._inserting = true;\n\n  var cache = self._cache;\n  self._cache = [];\n\n  if (Array.isArray(self._sequence)) {\n    self._sequence.push(cache.length);\n  }\n\n  var pendingCallback = self._pendingCallback;\n  self._pendingCallback = null;\n  if (typeof pendingCallback === 'function') {\n    pendingCallback();\n  }\n\n  var query = self._table.insert(cache, self._insertOptions);\n  if (self._options.format === 'primaryKey') {\n    query = query.do(function(result) {\n      return self._r.branch(\n        result('errors').eq(0),\n        self._table.config()('primary_key').do(function(primaryKey) {\n          return result('changes')('new_val')(primaryKey)\n        }),\n        result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\\n').add(result('first_error'))))\n      )\n    })\n  }\n\n  query.run(self._connection).then(function(result) {\n    self._inserting = false;\n    if (self._options.format === 'primaryKey') {\n      for(var i=0; i<result.length; i++) {\n        self.push(result[i]);\n      }\n    }\n    else {\n      if (result.errors > 0) {\n        self._inserting = false;\n        self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));\n      }\n      else {\n        if (self._insertOptions.returnChanges === true) {\n          for(var i=0; i<result.changes.length; i++) {\n            self.push(result.changes[i].new_val);\n          }\n        }\n      }\n    }\n\n    pendingCallback = self._pendingCallback\n    self._pendingCallback = null;\n    if (typeof pendingCallback === 'function') {\n      // Mean that we can buffer more\n      pendingCallback();\n    }\n    else if (self._ended !== true) {\n      if (((((self._writableState.lastBufferedRequest === null) ||\n          self._writableState.lastBufferedRequest.chunk === self._cache[self._cache.length-1])))\n        && (self._cache.length > 0)) {\n          self._insert();\n      }\n    }\n    else if (self._ended === true) {\n      if (self._cache.length > 0) {\n        self._insert();\n      }\n      else {\n        if (typeof self._flushCallback === 'function') {\n          self._flushCallback();\n        }\n        self.push(null);\n      }\n    }\n  }).error(function(error) {\n    self._inserting = false;\n    self.emit('error', error);\n  });\n}\n\nTransformStream.prototype._flush = function(done) {\n  this._ended = true;\n  if ((this._cache.length === 0) && (this._inserting === false)) {\n    done();\n  }\n  else { // this._inserting === true\n    if (this._inserting === false) {\n      this._flushCallback = done;\n      this._insert();\n    }\n    else {\n      this._flushCallback = done;\n    }\n  }\n}\n\n\nmodule.exports = TransformStream;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/transform_stream.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/lib/writable_stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/rethinkdbdash/lib/writable_stream.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Writable = __webpack_require__(/*! stream */ \"stream\").Writable;\nvar Cursor = __webpack_require__(/*! ./node_modules/rethinkdbdash/lib/cursor.js */ \"./node_modules/rethinkdbdash/lib/cursor.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n// Experimental, but should work fine.\nfunction WritableStream(table, options, connection) {\n  this._table = table;\n  this._options = options;\n  this._cache = [];\n  this._pendingCallback = null;\n  this._inserting = false;\n  this._delayed = false;\n  this._connection = connection;\n  this._highWaterMark = options.highWaterMark || 100;\n\n  this._insertOptions = {};\n  this._insertOptions.durability = options.durability || 'hard';\n  this._insertOptions.conflict = options.conflict || 'error';\n\n  // Internal option to run some tests\n  if (options.debug === true) {\n    this._sequence = [];\n  }\n\n  Writable.call(this, {\n    objectMode: true,\n    highWaterMark: this._highWaterMark\n  });\n  this._i = 0;\n};\nutil.inherits(WritableStream, Writable);\n\nWritableStream.prototype._write = function(value, encoding, done) {\n  this._i++;\n  this._cache.push(value);\n  this._next(value, encoding, done);\n}\n\n// Everytime we want to insert but do not have a full buffer,\n// we recurse with setImmediate to give a chance to the input\n// stream to push a few more elements\nWritableStream.prototype._next = function(value, encoding, done) {\n  var self = this;\n  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {\n    // There's more data to buffer\n    if (this._cache.length < this._highWaterMark) {\n      this._delayed = false;\n      // Call done now, and more data will be put in the cache\n      done();\n    }\n    else {\n      if (this._inserting === false) {\n        if (this._delayed === true) {\n          this._delayed = false;\n          // We have to flush\n          this._insert();\n          // Fill the buffer while we are inserting data\n          done();\n        }\n        else {\n          var self = this;\n          this._delayed = true;\n          setImmediate(function() {\n            self._next(value, encoding, done);\n          })\n        }\n\n      }\n      else {\n        this._delayed = false;\n        // to call when we are dong inserting to keep buffering\n        this._pendingCallback = done;\n      }\n    }\n  }\n  else { // We just pushed the last element in the internal buffer\n    if (this._inserting === false) {\n      if (this._delayed === true) {\n        this._delayed = false;\n        // to call when we are dong inserting to maybe flag the end\n        // We cannot call done here as we may be inserting the last batch\n        this._pendingCallback = done;\n        this._insert();\n      }\n      else {\n        var self = this;\n        this._delayed = true;\n        setImmediate(function() {\n          self._next(value, encoding, done);\n        })\n      }\n    }\n    else {\n      this._delayed = false;\n      // We cannot call done here as we may be inserting the last batch\n      //this._pendingCallback = done;\n      this._pendingCallback = function() {\n        self._next(value, encoding, done);\n      };\n    }\n  }\n}\n\nWritableStream.prototype._insert = function() {\n  var self = this;\n  self._inserting = true;\n\n  var cache = self._cache;\n  self._cache = [];\n\n  if (Array.isArray(self._sequence)) {\n    self._sequence.push(cache.length);\n  }\n\n  self._table.insert(cache, self._insertOptions).run(self._connection).then(function(result) {\n    self._inserting = false;\n    if (result.errors > 0) {\n      self._inserting = false;\n      self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));\n    }\n    if (typeof self._pendingCallback === 'function') {\n      var pendingCallback = self._pendingCallback;\n      self._pendingCallback = null;\n      pendingCallback();\n    }\n    return null;\n  }).error(function(error) {\n    self._inserting = false;\n    self.emit('error', error);\n  });\n}\n\n\nmodule.exports = WritableStream;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/lib/writable_stream.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/any.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/any.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/any.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/async.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/async.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = __webpack_require__(/*! ./schedule */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/schedule.js\");\nvar Queue = __webpack_require__(/*! ./queue */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/queue.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\n\nfunction Async() {\n    this._customScheduler = false;\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._haveDrainedQueues = false;\n    this._trampolineEnabled = true;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule = schedule;\n}\n\nAsync.prototype.setScheduler = function(fn) {\n    var prev = this._schedule;\n    this._schedule = fn;\n    this._customScheduler = true;\n    return prev;\n};\n\nAsync.prototype.hasCustomScheduler = function() {\n    return this._customScheduler;\n};\n\nAsync.prototype.enableTrampoline = function() {\n    this._trampolineEnabled = true;\n};\n\nAsync.prototype.disableTrampolineIfNecessary = function() {\n    if (util.hasDevTools) {\n        this._trampolineEnabled = false;\n    }\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._isTickUsed || this._haveDrainedQueues;\n};\n\n\nAsync.prototype.fatalError = function(e, isNode) {\n    if (isNode) {\n        process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) +\n            \"\\n\");\n        process.exit(2);\n    } else {\n        this.throwLater(e);\n    }\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nif (!util.hasDevTools) {\n    Async.prototype.invokeLater = AsyncInvokeLater;\n    Async.prototype.invoke = AsyncInvoke;\n    Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                setTimeout(function() {\n                    fn.call(receiver, arg);\n                }, 100);\n            });\n        }\n    };\n\n    Async.prototype.invoke = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                fn.call(receiver, arg);\n            });\n        }\n    };\n\n    Async.prototype.settlePromises = function(promise) {\n        if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n        } else {\n            this._schedule(function() {\n                promise._settlePromises();\n            });\n        }\n    };\n}\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._haveDrainedQueues = true;\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = Async;\nmodule.exports.firstLineError = firstLineError;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/async.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bind.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bind.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {\nvar calledBind = false;\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (((this._bitField & 50397184) === 0)) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    if (!calledBind) {\n        calledBind = true;\n        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n        Promise.prototype._boundValue = debug.boundValueFunction();\n    }\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, undefined, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, undefined, ret, context);\n        ret._setOnCancel(maybePromise);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 2097152;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~2097152);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 2097152) === 2097152;\n};\n\nPromise.bind = function (thisArg, value) {\n    return Promise.resolve(value).bind(thisArg);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bind.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = __webpack_require__(/*! ./promise */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bluebird.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/call_get.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/call_get.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n    if (true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/call_get.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/cancel.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/cancel.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, PromiseArray, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nPromise.prototype[\"break\"] = Promise.prototype.cancel = function() {\n    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n    var promise = this;\n    var child = promise;\n    while (promise._isCancellable()) {\n        if (!promise._cancelBy(child)) {\n            if (child._isFollowing()) {\n                child._followee().cancel();\n            } else {\n                child._cancelBranched();\n            }\n            break;\n        }\n\n        var parent = promise._cancellationParent;\n        if (parent == null || !parent._isCancellable()) {\n            if (promise._isFollowing()) {\n                promise._followee().cancel();\n            } else {\n                promise._cancelBranched();\n            }\n            break;\n        } else {\n            if (promise._isFollowing()) promise._followee().cancel();\n            promise._setWillBeCancelled();\n            child = promise;\n            promise = parent;\n        }\n    }\n};\n\nPromise.prototype._branchHasCancelled = function() {\n    this._branchesRemainingToCancel--;\n};\n\nPromise.prototype._enoughBranchesHaveCancelled = function() {\n    return this._branchesRemainingToCancel === undefined ||\n           this._branchesRemainingToCancel <= 0;\n};\n\nPromise.prototype._cancelBy = function(canceller) {\n    if (canceller === this) {\n        this._branchesRemainingToCancel = 0;\n        this._invokeOnCancel();\n        return true;\n    } else {\n        this._branchHasCancelled();\n        if (this._enoughBranchesHaveCancelled()) {\n            this._invokeOnCancel();\n            return true;\n        }\n    }\n    return false;\n};\n\nPromise.prototype._cancelBranched = function() {\n    if (this._enoughBranchesHaveCancelled()) {\n        this._cancel();\n    }\n};\n\nPromise.prototype._cancel = function() {\n    if (!this._isCancellable()) return;\n    this._setCancelled();\n    async.invoke(this._cancelPromises, this, undefined);\n};\n\nPromise.prototype._cancelPromises = function() {\n    if (this._length() > 0) this._settlePromises();\n};\n\nPromise.prototype._unsetOnCancel = function() {\n    this._onCancelField = undefined;\n};\n\nPromise.prototype._isCancellable = function() {\n    return this.isPending() && !this._isCancelled();\n};\n\nPromise.prototype.isCancellable = function() {\n    return this.isPending() && !this.isCancelled();\n};\n\nPromise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {\n    if (util.isArray(onCancelCallback)) {\n        for (var i = 0; i < onCancelCallback.length; ++i) {\n            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n        }\n    } else if (onCancelCallback !== undefined) {\n        if (typeof onCancelCallback === \"function\") {\n            if (!internalOnly) {\n                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                if (e === errorObj) {\n                    this._attachExtraTrace(e.e);\n                    async.throwLater(e.e);\n                }\n            }\n        } else {\n            onCancelCallback._resultCancelled(this);\n        }\n    }\n};\n\nPromise.prototype._invokeOnCancel = function() {\n    var onCancelCallback = this._onCancel();\n    this._unsetOnCancel();\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n};\n\nPromise.prototype._invokeInternalOnCancel = function() {\n    if (this._isCancellable()) {\n        this._doInvokeOnCancel(this._onCancel(), true);\n        this._unsetOnCancel();\n    }\n};\n\nPromise.prototype._resultCancelled = function() {\n    this.cancel();\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/cancel.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/catch_filter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/catch_filter.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar getKeys = __webpack_require__(/*! ./es5 */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js\").keys;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction catchFilter(instances, cb, promise) {\n    return function(e) {\n        var boundTo = promise._boundValue();\n        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n            var item = instances[i];\n\n            if (item === Error ||\n                (item != null && item.prototype instanceof Error)) {\n                if (e instanceof item) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (typeof item === \"function\") {\n                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                if (matchesPredicate === errorObj) {\n                    return matchesPredicate;\n                } else if (matchesPredicate) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (util.isObject(e)) {\n                var keys = getKeys(item);\n                for (var j = 0; j < keys.length; ++j) {\n                    var key = keys[j];\n                    if (item[key] != e[key]) {\n                        continue predicateLoop;\n                    }\n                }\n                return tryCatch(cb).call(boundTo, e);\n            }\n        }\n        return NEXT_FILTER;\n    };\n}\n\nreturn catchFilter;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/catch_filter.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/context.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/context.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar longStackTraces = false;\nvar contextStack = [];\n\nPromise.prototype._promiseCreated = function() {};\nPromise.prototype._pushContext = function() {};\nPromise.prototype._popContext = function() {return null;};\nPromise._peekContext = Promise.prototype._peekContext = function() {};\n\nfunction Context() {\n    this._trace = new Context.CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (this._trace !== undefined) {\n        this._trace._promiseCreated = null;\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (this._trace !== undefined) {\n        var trace = contextStack.pop();\n        var ret = trace._promiseCreated;\n        trace._promiseCreated = null;\n        return ret;\n    }\n    return null;\n};\n\nfunction createContext() {\n    if (longStackTraces) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\nContext.CapturedTrace = null;\nContext.create = createContext;\nContext.deactivateLongStackTraces = function() {};\nContext.activateLongStackTraces = function() {\n    var Promise_pushContext = Promise.prototype._pushContext;\n    var Promise_popContext = Promise.prototype._popContext;\n    var Promise_PeekContext = Promise._peekContext;\n    var Promise_peekContext = Promise.prototype._peekContext;\n    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n    Context.deactivateLongStackTraces = function() {\n        Promise.prototype._pushContext = Promise_pushContext;\n        Promise.prototype._popContext = Promise_popContext;\n        Promise._peekContext = Promise_PeekContext;\n        Promise.prototype._peekContext = Promise_peekContext;\n        Promise.prototype._promiseCreated = Promise_promiseCreated;\n        longStackTraces = false;\n    };\n    longStackTraces = true;\n    Promise.prototype._pushContext = Context.prototype._pushContext;\n    Promise.prototype._popContext = Context.prototype._popContext;\n    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n    Promise.prototype._promiseCreated = function() {\n        var ctx = this._peekContext();\n        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n    };\n};\nreturn Context;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/context.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/debuggability.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/debuggability.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, Context) {\nvar getDomain = Promise._getDomain;\nvar async = Promise._async;\nvar Warning = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\").Warning;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\nvar nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\nvar parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar printWarning;\nvar debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 &&\n                        (false ||\n                         util.env(\"BLUEBIRD_DEBUG\") ||\n                         util.env(\"NODE_ENV\") === \"development\"));\n\nvar warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\nvar longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\nvar wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 &&\n    (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\nPromise.prototype.suppressUnhandledRejections = function() {\n    var target = this._target();\n    target._bitField = ((target._bitField & (~1048576)) |\n                      524288);\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 524288) !== 0) return;\n    this._setRejectionIsUnhandled();\n    var self = this;\n    setTimeout(function() {\n        self._notifyUnhandledRejection();\n    }, 1);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._setReturnedNonUndefined = function() {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._returnedNonUndefined = function() {\n    return (this._bitField & 268435456) !== 0;\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._settledValue();\n        this._setUnhandledRejectionIsNotified();\n        fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 262144;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~262144);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 262144) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 1048576;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~1048576);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._warn = function(message, shouldUseOwnTrace, promise) {\n    return warn(message, shouldUseOwnTrace, promise || this);\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection =\n        typeof fn === \"function\" ? (domain === null ?\n                                            fn : util.domainBind(domain, fn))\n                                 : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled =\n        typeof fn === \"function\" ? (domain === null ?\n                                            fn : util.domainBind(domain, fn))\n                                 : undefined;\n};\n\nvar disableLongStackTraces = function() {};\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() && !config.longStackTraces) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\n        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n        config.longStackTraces = true;\n        disableLongStackTraces = function() {\n            if (async.haveItemsQueued() && !config.longStackTraces) {\n                throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n            }\n            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n            Context.deactivateLongStackTraces();\n            async.enableTrampoline();\n            config.longStackTraces = false;\n        };\n        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n        Context.activateLongStackTraces();\n        async.disableTrampolineIfNecessary();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return config.longStackTraces && longStackTracesIsSupported();\n};\n\nvar fireDomEvent = (function() {\n    try {\n        if (typeof CustomEvent === \"function\") {\n            var event = new CustomEvent(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = new CustomEvent(name.toLowerCase(), {\n                    detail: event,\n                    cancelable: true\n                });\n                return !util.global.dispatchEvent(domEvent);\n            };\n        } else if (typeof Event === \"function\") {\n            var event = new Event(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = new Event(name.toLowerCase(), {\n                    cancelable: true\n                });\n                domEvent.detail = event;\n                return !util.global.dispatchEvent(domEvent);\n            };\n        } else {\n            var event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(\"testingtheevent\", false, true, {});\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = document.createEvent(\"CustomEvent\");\n                domEvent.initCustomEvent(name.toLowerCase(), false, true,\n                    event);\n                return !util.global.dispatchEvent(domEvent);\n            };\n        }\n    } catch (e) {}\n    return function() {\n        return false;\n    };\n})();\n\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function() {\n            return process.emit.apply(process, arguments);\n        };\n    } else {\n        if (!util.global) {\n            return function() {\n                return false;\n            };\n        }\n        return function(name) {\n            var methodName = \"on\" + name.toLowerCase();\n            var method = util.global[methodName];\n            if (!method) return false;\n            method.apply(util.global, [].slice.call(arguments, 1));\n            return true;\n        };\n    }\n})();\n\nfunction generatePromiseLifecycleEventObject(name, promise) {\n    return {promise: promise};\n}\n\nvar eventToObjectGenerator = {\n    promiseCreated: generatePromiseLifecycleEventObject,\n    promiseFulfilled: generatePromiseLifecycleEventObject,\n    promiseRejected: generatePromiseLifecycleEventObject,\n    promiseResolved: generatePromiseLifecycleEventObject,\n    promiseCancelled: generatePromiseLifecycleEventObject,\n    promiseChained: function(name, promise, child) {\n        return {promise: promise, child: child};\n    },\n    warning: function(name, warning) {\n        return {warning: warning};\n    },\n    unhandledRejection: function (name, reason, promise) {\n        return {reason: reason, promise: promise};\n    },\n    rejectionHandled: generatePromiseLifecycleEventObject\n};\n\nvar activeFireEvent = function (name) {\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent.apply(null, arguments);\n    } catch (e) {\n        async.throwLater(e);\n        globalEventFired = true;\n    }\n\n    var domEventFired = false;\n    try {\n        domEventFired = fireDomEvent(name,\n                    eventToObjectGenerator[name].apply(null, arguments));\n    } catch (e) {\n        async.throwLater(e);\n        domEventFired = true;\n    }\n\n    return domEventFired || globalEventFired;\n};\n\nPromise.config = function(opts) {\n    opts = Object(opts);\n    if (\"longStackTraces\" in opts) {\n        if (opts.longStackTraces) {\n            Promise.longStackTraces();\n        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n            disableLongStackTraces();\n        }\n    }\n    if (\"warnings\" in opts) {\n        var warningsOption = opts.warnings;\n        config.warnings = !!warningsOption;\n        wForgottenReturn = config.warnings;\n\n        if (util.isObject(warningsOption)) {\n            if (\"wForgottenReturn\" in warningsOption) {\n                wForgottenReturn = !!warningsOption.wForgottenReturn;\n            }\n        }\n    }\n    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n        if (async.haveItemsQueued()) {\n            throw new Error(\n                \"cannot enable cancellation after promises are in use\");\n        }\n        Promise.prototype._clearCancellationData =\n            cancellationClearCancellationData;\n        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n        Promise.prototype._onCancel = cancellationOnCancel;\n        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n        Promise.prototype._attachCancellationCallback =\n            cancellationAttachCancellationCallback;\n        Promise.prototype._execute = cancellationExecute;\n        propagateFromFunction = cancellationPropagateFrom;\n        config.cancellation = true;\n    }\n    if (\"monitoring\" in opts) {\n        if (opts.monitoring && !config.monitoring) {\n            config.monitoring = true;\n            Promise.prototype._fireEvent = activeFireEvent;\n        } else if (!opts.monitoring && config.monitoring) {\n            config.monitoring = false;\n            Promise.prototype._fireEvent = defaultFireEvent;\n        }\n    }\n    return Promise;\n};\n\nfunction defaultFireEvent() { return false; }\n\nPromise.prototype._fireEvent = defaultFireEvent;\nPromise.prototype._execute = function(executor, resolve, reject) {\n    try {\n        executor(resolve, reject);\n    } catch (e) {\n        return e;\n    }\n};\nPromise.prototype._onCancel = function () {};\nPromise.prototype._setOnCancel = function (handler) { ; };\nPromise.prototype._attachCancellationCallback = function(onCancel) {\n    ;\n};\nPromise.prototype._captureStackTrace = function () {};\nPromise.prototype._attachExtraTrace = function () {};\nPromise.prototype._clearCancellationData = function() {};\nPromise.prototype._propagateFrom = function (parent, flags) {\n    ;\n    ;\n};\n\nfunction cancellationExecute(executor, resolve, reject) {\n    var promise = this;\n    try {\n        executor(resolve, reject, function(onCancel) {\n            if (typeof onCancel !== \"function\") {\n                throw new TypeError(\"onCancel must be a function, got: \" +\n                                    util.toString(onCancel));\n            }\n            promise._attachCancellationCallback(onCancel);\n        });\n    } catch (e) {\n        return e;\n    }\n}\n\nfunction cancellationAttachCancellationCallback(onCancel) {\n    if (!this._isCancellable()) return this;\n\n    var previousOnCancel = this._onCancel();\n    if (previousOnCancel !== undefined) {\n        if (util.isArray(previousOnCancel)) {\n            previousOnCancel.push(onCancel);\n        } else {\n            this._setOnCancel([previousOnCancel, onCancel]);\n        }\n    } else {\n        this._setOnCancel(onCancel);\n    }\n}\n\nfunction cancellationOnCancel() {\n    return this._onCancelField;\n}\n\nfunction cancellationSetOnCancel(onCancel) {\n    this._onCancelField = onCancel;\n}\n\nfunction cancellationClearCancellationData() {\n    this._cancellationParent = undefined;\n    this._onCancelField = undefined;\n}\n\nfunction cancellationPropagateFrom(parent, flags) {\n    if ((flags & 1) !== 0) {\n        this._cancellationParent = parent;\n        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n        if (branchesRemainingToCancel === undefined) {\n            branchesRemainingToCancel = 0;\n        }\n        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n    }\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\n\nfunction bindingPropagateFrom(parent, flags) {\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\nvar propagateFromFunction = bindingPropagateFrom;\n\nfunction boundValueFunction() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n}\n\nfunction longStackTracesCaptureStackTrace() {\n    this._trace = new CapturedTrace(this._peekContext());\n}\n\nfunction longStackTracesAttachExtraTrace(error, ignoreSelf) {\n    if (canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n}\n\nfunction checkForgottenReturns(returnValue, promiseCreated, name, promise,\n                               parent) {\n    if (returnValue === undefined && promiseCreated !== null &&\n        wForgottenReturn) {\n        if (parent !== undefined && parent._returnedNonUndefined()) return;\n        if ((promise._bitField & 65535) === 0) return;\n\n        if (name) name = name + \" \";\n        var handlerLine = \"\";\n        var creatorLine = \"\";\n        if (promiseCreated._trace) {\n            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n            var stack = cleanStack(traceLines);\n            for (var i = stack.length - 1; i >= 0; --i) {\n                var line = stack[i];\n                if (!nodeFramePattern.test(line)) {\n                    var lineMatches = line.match(parseLinePattern);\n                    if (lineMatches) {\n                        handlerLine  = \"at \" + lineMatches[1] +\n                            \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                    }\n                    break;\n                }\n            }\n\n            if (stack.length > 0) {\n                var firstUserLine = stack[0];\n                for (var i = 0; i < traceLines.length; ++i) {\n\n                    if (traceLines[i] === firstUserLine) {\n                        if (i > 0) {\n                            creatorLine = \"\\n\" + traceLines[i - 1];\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        var msg = \"a promise was created in a \" + name +\n            \"handler \" + handlerLine + \"but was not returned from it, \" +\n            \"see http://goo.gl/rRqMUw\" +\n            creatorLine;\n        promise._warn(msg, true, promiseCreated);\n    }\n}\n\nfunction deprecated(name, replacement) {\n    var message = name +\n        \" is deprecated and will be removed in a future version.\";\n    if (replacement) message += \" Use \" + replacement + \" instead.\";\n    return warn(message);\n}\n\nfunction warn(message, shouldUseOwnTrace, promise) {\n    if (!config.warnings) return;\n    var warning = new Warning(message);\n    var ctx;\n    if (shouldUseOwnTrace) {\n        promise._attachExtraTrace(warning);\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n\n    if (!activeFireEvent(\"warning\", warning)) {\n        formatAndLogError(warning, \"\", true);\n    }\n}\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = \"    (No stack trace)\" === line ||\n            stackFramePattern.test(line);\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0 && error.name != \"SyntaxError\") {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nfunction parseStackAndMessage(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n    };\n}\n\nfunction formatAndLogError(error, title, isSoft) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (util.isObject(error)) {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof printWarning === \"function\") {\n            printWarning(message, isSoft);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n}\n\nfunction fireRejectionEvent(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    if (name === \"unhandledRejection\") {\n        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n            formatAndLogError(reason, \"Unhandled rejection \");\n        }\n    } else {\n        activeFireEvent(name, promise);\n    }\n}\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj && typeof obj.toString === \"function\"\n            ? obj.toString() : util.toString(obj);\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nfunction longStackTracesIsSupported() {\n    return typeof captureStackTrace === \"function\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\n\nfunction setBounds(firstLineError, lastLineError) {\n    if (!longStackTracesIsSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    this._promisesCreated = 0;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\nContext.CapturedTrace = CapturedTrace;\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit += 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit += 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit -= 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit += 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit -= 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    printWarning = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        printWarning = function(message, isSoft) {\n            var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n            console.warn(color + message + \"\\u001b[0m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        printWarning = function(message, isSoft) {\n            console.warn(\"%c\" + message,\n                        isSoft ? \"color: darkorange\" : \"color: red\");\n        };\n    }\n}\n\nvar config = {\n    warnings: warnings,\n    longStackTraces: false,\n    cancellation: false,\n    monitoring: false\n};\n\nif (longStackTraces) Promise.longStackTraces();\n\nreturn {\n    longStackTraces: function() {\n        return config.longStackTraces;\n    },\n    warnings: function() {\n        return config.warnings;\n    },\n    cancellation: function() {\n        return config.cancellation;\n    },\n    monitoring: function() {\n        return config.monitoring;\n    },\n    propagateFromFunction: function() {\n        return propagateFromFunction;\n    },\n    boundValueFunction: function() {\n        return boundValueFunction;\n    },\n    checkForgottenReturns: checkForgottenReturns,\n    setBounds: setBounds,\n    warn: warn,\n    deprecated: deprecated,\n    CapturedTrace: CapturedTrace,\n    fireDomEvent: fireDomEvent,\n    fireGlobalEvent: fireGlobalEvent\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/debuggability.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/direct_resolve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/direct_resolve.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction returner() {\n    return this.value;\n}\nfunction thrower() {\n    throw this.reason;\n}\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value instanceof Promise) value.suppressUnhandledRejections();\n    return this._then(\n        returner, undefined, undefined, {value: value}, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    return this._then(\n        thrower, undefined, undefined, {reason: reason}, undefined);\n};\n\nPromise.prototype.catchThrow = function (reason) {\n    if (arguments.length <= 1) {\n        return this._then(\n            undefined, thrower, undefined, {reason: reason}, undefined);\n    } else {\n        var _reason = arguments[1];\n        var handler = function() {throw _reason;};\n        return this.caught(reason, handler);\n    }\n};\n\nPromise.prototype.catchReturn = function (value) {\n    if (arguments.length <= 1) {\n        if (value instanceof Promise) value.suppressUnhandledRejections();\n        return this._then(\n            undefined, returner, undefined, {value: value}, undefined);\n    } else {\n        var _value = arguments[1];\n        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n        var handler = function() {return _value;};\n        return this.caught(value, handler);\n    }\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/direct_resolve.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/each.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/each.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\nvar PromiseAll = Promise.all;\n\nfunction promiseAllThis() {\n    return PromiseAll(this);\n}\n\nfunction PromiseMapSeries(promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n}\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, this, undefined);\n};\n\nPromise.prototype.mapSeries = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, promises, undefined);\n};\n\nPromise.mapSeries = PromiseMapSeries;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/each.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n        value: errorTypes,\n        writable: false,\n        enumerable: false,\n        configurable: false\n    });\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/filter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/filter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/filter.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/finally.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/finally.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar CancellationError = Promise.CancellationError;\nvar errorObj = util.errorObj;\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\n\nfunction PassThroughHandlerContext(promise, type, handler) {\n    this.promise = promise;\n    this.type = type;\n    this.handler = handler;\n    this.called = false;\n    this.cancelPromise = null;\n}\n\nPassThroughHandlerContext.prototype.isFinallyHandler = function() {\n    return this.type === 0;\n};\n\nfunction FinallyHandlerCancelReaction(finallyHandler) {\n    this.finallyHandler = finallyHandler;\n}\n\nFinallyHandlerCancelReaction.prototype._resultCancelled = function() {\n    checkCancel(this.finallyHandler);\n};\n\nfunction checkCancel(ctx, reason) {\n    if (ctx.cancelPromise != null) {\n        if (arguments.length > 1) {\n            ctx.cancelPromise._reject(reason);\n        } else {\n            ctx.cancelPromise._cancel();\n        }\n        ctx.cancelPromise = null;\n        return true;\n    }\n    return false;\n}\n\nfunction succeed() {\n    return finallyHandler.call(this, this.promise._target()._settledValue());\n}\nfunction fail(reason) {\n    if (checkCancel(this, reason)) return;\n    errorObj.e = reason;\n    return errorObj;\n}\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    if (!this.called) {\n        this.called = true;\n        var ret = this.isFinallyHandler()\n            ? handler.call(promise._boundValue())\n            : handler.call(promise._boundValue(), reasonOrValue);\n        if (ret === NEXT_FILTER) {\n            return ret;\n        } else if (ret !== undefined) {\n            promise._setReturnedNonUndefined();\n            var maybePromise = tryConvertToPromise(ret, promise);\n            if (maybePromise instanceof Promise) {\n                if (this.cancelPromise != null) {\n                    if (maybePromise._isCancelled()) {\n                        var reason =\n                            new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        errorObj.e = reason;\n                        return errorObj;\n                    } else if (maybePromise.isPending()) {\n                        maybePromise._attachCancellationCallback(\n                            new FinallyHandlerCancelReaction(this));\n                    }\n                }\n                return maybePromise._then(\n                    succeed, fail, undefined, this, undefined);\n            }\n        }\n    }\n\n    if (promise.isRejected()) {\n        checkCancel(this);\n        errorObj.e = reasonOrValue;\n        return errorObj;\n    } else {\n        checkCancel(this);\n        return reasonOrValue;\n    }\n}\n\nPromise.prototype._passThrough = function(handler, type, success, fail) {\n    if (typeof handler !== \"function\") return this.then();\n    return this._then(success,\n                      fail,\n                      undefined,\n                      new PassThroughHandlerContext(this, type, handler),\n                      undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThrough(handler,\n                             0,\n                             finallyHandler,\n                             finallyHandler);\n};\n\n\nPromise.prototype.tap = function (handler) {\n    return this._passThrough(handler, 1, finallyHandler);\n};\n\nPromise.prototype.tapCatch = function (handlerOrPredicate) {\n    var len = arguments.length;\n    if(len === 1) {\n        return this._passThrough(handlerOrPredicate,\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    } else {\n         var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(new TypeError(\n                    \"tapCatch statement predicate: \"\n                    + \"expecting an object but got \" + util.classString(item)\n                ));\n            }\n        }\n        catchInstances.length = j;\n        var handler = arguments[i];\n        return this._passThrough(catchFilter(catchInstances, handler, this),\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    }\n\n};\n\nreturn PassThroughHandlerContext;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/finally.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/generators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/generators.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise,\n                          Proxyable,\n                          debug) {\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\");\nvar TypeError = errors.TypeError;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    if (debug.cancellation()) {\n        var internal = new Promise(INTERNAL);\n        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n        this._promise = internal.lastly(function() {\n            return _finallyPromise;\n        });\n        internal._captureStackTrace();\n        internal._setOnCancel(this);\n    } else {\n        var promise = this._promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n    }\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n    this._yieldedPromise = null;\n    this._cancellationPhase = false;\n}\nutil.inherits(PromiseSpawn, Proxyable);\n\nPromiseSpawn.prototype._isResolved = function() {\n    return this._promise === null;\n};\n\nPromiseSpawn.prototype._cleanup = function() {\n    this._promise = this._generator = null;\n    if (debug.cancellation() && this._finallyPromise !== null) {\n        this._finallyPromise._fulfill();\n        this._finallyPromise = null;\n    }\n};\n\nPromiseSpawn.prototype._promiseCancelled = function() {\n    if (this._isResolved()) return;\n    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n    var result;\n    if (!implementsReturn) {\n        var reason = new Promise.CancellationError(\n            \"generator .return() sentinel\");\n        Promise.coroutine.returnSentinel = reason;\n        this._promise._attachExtraTrace(reason);\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"throw\"]).call(this._generator,\n                                                         reason);\n        this._promise._popContext();\n    } else {\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"return\"]).call(this._generator,\n                                                          undefined);\n        this._promise._popContext();\n    }\n    this._cancellationPhase = true;\n    this._yieldedPromise = null;\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseFulfilled = function(value) {\n    this._yieldedPromise = null;\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseRejected = function(reason) {\n    this._yieldedPromise = null;\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._resultCancelled = function() {\n    if (this._yieldedPromise instanceof Promise) {\n        var promise = this._yieldedPromise;\n        this._yieldedPromise = null;\n        promise.cancel();\n    }\n};\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._promiseFulfilled(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    var promise = this._promise;\n    if (result === errorObj) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._rejectCallback(result.e, false);\n        }\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._resolveCallback(value);\n        }\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._promiseRejected(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", String(value)) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise = maybePromise._target();\n        var bitField = maybePromise._bitField;\n        ;\n        if (((bitField & 50397184) === 0)) {\n            this._yieldedPromise = maybePromise;\n            maybePromise._proxy(this, null);\n        } else if (((bitField & 33554432) !== 0)) {\n            Promise._async.invoke(\n                this._promiseFulfilled, this, maybePromise._value()\n            );\n        } else if (((bitField & 16777216) !== 0)) {\n            Promise._async.invoke(\n                this._promiseRejected, this, maybePromise._reason()\n            );\n        } else {\n            this._promiseCancelled();\n        }\n    }\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        var ret = spawn.promise();\n        spawn._generator = generator;\n        spawn._promiseFulfilled(undefined);\n        return ret;\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/generators.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/join.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/join.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,\n         getDomain) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var promiseSetter = function(i) {\n        return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var generateHolderClass = function(total) {\n        var props = new Array(total);\n        for (var i = 0; i < props.length; ++i) {\n            props[i] = \"this.p\" + (i+1);\n        }\n        var assignment = props.join(\" = \") + \" = null;\";\n        var cancellationCode= \"var promise;\\n\" + props.map(function(prop) {\n            return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n        }).join(\"\\n\");\n        var passedArguments = props.join(\", \");\n        var name = \"Holder$\" + total;\n\n\n        var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n\n        code = code.replace(/\\[TheName\\]/g, name)\n            .replace(/\\[TheTotal\\]/g, total)\n            .replace(/\\[ThePassedArguments\\]/g, passedArguments)\n            .replace(/\\[TheProperties\\]/g, assignment)\n            .replace(/\\[CancellationCode\\]/g, cancellationCode);\n\n        return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)\n                           (tryCatch, errorObj, Promise, async);\n    };\n\n    var holderClasses = [];\n    var thenCallbacks = [];\n    var promiseSetters = [];\n\n    for (var i = 0; i < 8; ++i) {\n        holderClasses.push(generateHolderClass(i + 1));\n        thenCallbacks.push(thenCallback(i + 1));\n        promiseSetters.push(promiseSetter(i + 1));\n    }\n\n    reject = function (reason) {\n        this._reject(reason);\n    };\n}}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (true) {\n            if (last <= 8 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var HolderClass = holderClasses[last - 1];\n                var holder = new HolderClass(fn);\n                var callbacks = thenCallbacks;\n\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if (((bitField & 50397184) === 0)) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                            promiseSetters[i](maybePromise, holder);\n                            holder.asyncNeeded = false;\n                        } else if (((bitField & 33554432) !== 0)) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else if (((bitField & 16777216) !== 0)) {\n                            ret._reject(maybePromise._reason());\n                        } else {\n                            ret._cancel();\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n\n                if (!ret._isFateSealed()) {\n                    if (holder.asyncNeeded) {\n                        var domain = getDomain();\n                        if (domain !== null) {\n                            holder.fn = util.domainBind(domain, holder.fn);\n                        }\n                    }\n                    ret._setAsyncGuaranteed();\n                    ret._setOnCancel(holder);\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/join.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/map.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/map.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar getDomain = Promise._getDomain;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : util.domainBind(domain, fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = [];\n    async.invoke(this._asyncInit, this, undefined);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._asyncInit = function() {\n    this._init$(undefined, -2);\n};\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n\n    if (index < 0) {\n        index = (index * -1) - 1;\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return true;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return false;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var promise = this._promise;\n        var callback = this._callback;\n        var receiver = promise._boundValue();\n        promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        var promiseCreated = promise._popContext();\n        debug.checkForgottenReturns(\n            ret,\n            promiseCreated,\n            preservedValues !== null ? \"Promise.filter\" : \"Promise.map\",\n            promise\n        );\n        if (ret === errorObj) {\n            this._reject(ret.e);\n            return true;\n        }\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            var bitField = maybePromise._bitField;\n            ;\n            if (((bitField & 50397184) === 0)) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = maybePromise;\n                maybePromise._proxy(this, (index + 1) * -1);\n                return false;\n            } else if (((bitField & 33554432) !== 0)) {\n                ret = maybePromise._value();\n            } else if (((bitField & 16777216) !== 0)) {\n                this._reject(maybePromise._reason());\n                return true;\n            } else {\n                this._cancel();\n                return true;\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n        return true;\n    }\n    return false;\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n\n    var limit = 0;\n    if (options !== undefined) {\n        if (typeof options === \"object\" && options !== null) {\n            if (typeof options.concurrency !== \"number\") {\n                return Promise.reject(\n                    new TypeError(\"'concurrency' must be a number but it is \" +\n                                    util.classString(options.concurrency)));\n            }\n            limit = options.concurrency;\n        } else {\n            return Promise.reject(new TypeError(\n                            \"options argument must be an object but it is \" +\n                             util.classString(options)));\n        }\n    }\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n}\n\nPromise.prototype.map = function (fn, options) {\n    return map(this, fn, options, null);\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    return map(promises, fn, options, _filter);\n};\n\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/map.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/method.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/method.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        var promiseCreated = ret._popContext();\n        debug.checkForgottenReturns(\n            value, promiseCreated, \"Promise.method\", ret);\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value;\n    if (arguments.length > 1) {\n        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n        var arg = arguments[1];\n        var ctx = arguments[2];\n        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)\n                                  : tryCatch(fn).call(ctx, arg);\n    } else {\n        value = tryCatch(fn)();\n    }\n    var promiseCreated = ret._popContext();\n    debug.checkForgottenReturns(\n        value, promiseCreated, \"Promise.try\", ret);\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/method.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeback.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeback.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\");\nvar OperationalError = errors.OperationalError;\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise, multiArgs) {\n    return function(err, value) {\n        if (promise === null) return;\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (!multiArgs) {\n            promise._fulfill(value);\n        } else {\n            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n            promise._fulfill(args);\n        }\n        promise = null;\n    };\n}\n\nmodule.exports = nodebackForPromise;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeback.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeify.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeify.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar async = Promise._async;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var newReason = new Error(reason + \"\");\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,\n                                                                     options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeify.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar reflectHandler = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\nfunction Proxyable() {}\nvar UNDEFINED_BINDING = {};\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\n\nvar getDomain;\nif (util.isNode) {\n    getDomain = function() {\n        var ret = process.domain;\n        if (ret === undefined) ret = null;\n        return ret;\n    };\n} else {\n    getDomain = function() {\n        return null;\n    };\n}\nutil.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js\");\nvar Async = __webpack_require__(/*! ./async */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/async.js\");\nvar async = new Async();\nes5.defineProperty(Promise, \"_async\", {value: async});\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nvar CancellationError = Promise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {};\nvar tryConvertToPromise = __webpack_require__(/*! ./thenables */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    __webpack_require__(/*! ./promise_array */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise_array.js\")(Promise, INTERNAL,\n                               tryConvertToPromise, apiRejection, Proxyable);\nvar Context = __webpack_require__(/*! ./context */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/context.js\")(Promise);\n /*jshint unused:false*/\nvar createContext = Context.create;\nvar debug = __webpack_require__(/*! ./debuggability */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/debuggability.js\")(Promise, Context);\nvar CapturedTrace = debug.CapturedTrace;\nvar PassThroughHandlerContext =\n    __webpack_require__(/*! ./finally */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/finally.js\")(Promise, tryConvertToPromise, NEXT_FILTER);\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeback.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction check(self, executor) {\n    if (self == null || self.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (typeof executor !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n    }\n\n}\n\nfunction Promise(executor) {\n    if (executor !== INTERNAL) {\n        check(this, executor);\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._resolveFromExecutor(executor);\n    this._promiseCreated();\n    this._fireEvent(\"promiseCreated\", this);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return apiRejection(\"Catch statement predicate: \" +\n                    \"expecting an object but got \" + util.classString(item));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        return this.then(undefined, catchFilter(catchInstances, fn, this));\n    }\n    return this.then(undefined, fn);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflectHandler,\n        reflectHandler, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject) {\n    if (debug.warnings() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject) {\n    var promise =\n        this._then(didFulfill, didReject, undefined, undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    if (arguments.length > 0) {\n        this._warn(\".all() was passed arguments but it does not take any\");\n    }\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.getNewLibraryCopy = module.exports;\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = Promise.fromCallback = function(fn) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs\n                                         : false;\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true);\n    }\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._setFulfilled();\n        ret._rejectionHandler0 = obj;\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return async.setScheduler(fn);\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    _,    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n    var target = this._target();\n    var bitField = target._bitField;\n\n    if (!haveInternalData) {\n        promise._propagateFrom(this, 3);\n        promise._captureStackTrace();\n        if (receiver === undefined &&\n            ((this._bitField & 2097152) !== 0)) {\n            if (!((bitField & 50397184) === 0)) {\n                receiver = this._boundValue();\n            } else {\n                receiver = target === this ? undefined : this._boundTo;\n            }\n        }\n        this._fireEvent(\"promiseChained\", this, promise);\n    }\n\n    var domain = getDomain();\n    if (!((bitField & 50397184) === 0)) {\n        var handler, value, settler = target._settlePromiseCtx;\n        if (((bitField & 33554432) !== 0)) {\n            value = target._rejectionHandler0;\n            handler = didFulfill;\n        } else if (((bitField & 16777216) !== 0)) {\n            value = target._fulfillmentHandler0;\n            handler = didReject;\n            target._unsetRejectionIsUnhandled();\n        } else {\n            settler = target._settlePromiseLateCancellationObserver;\n            value = new CancellationError(\"late cancellation observer\");\n            target._attachExtraTrace(value);\n            handler = didReject;\n        }\n\n        async.invoke(settler, target, {\n            handler: domain === null ? handler\n                : (typeof handler === \"function\" &&\n                    util.domainBind(domain, handler)),\n            promise: promise,\n            receiver: receiver,\n            value: value\n        });\n    } else {\n        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\n    }\n\n    return promise;\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 65535;\n};\n\nPromise.prototype._isFateSealed = function () {\n    return (this._bitField & 117506048) !== 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 67108864) === 67108864;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -65536) |\n        (len & 65535);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 33554432;\n    this._fireEvent(\"promiseFulfilled\", this);\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 16777216;\n    this._fireEvent(\"promiseRejected\", this);\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 67108864;\n    this._fireEvent(\"promiseResolved\", this);\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._unsetCancelled = function() {\n    this._bitField = this._bitField & (~65536);\n};\n\nPromise.prototype._setCancelled = function() {\n    this._bitField = this._bitField | 65536;\n    this._fireEvent(\"promiseCancelled\", this);\n};\n\nPromise.prototype._setWillBeCancelled = function() {\n    this._bitField = this._bitField | 8388608;\n};\n\nPromise.prototype._setAsyncGuaranteed = function() {\n    if (async.hasCustomScheduler()) return;\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0 ? this._receiver0 : this[\n            index * 4 - 4 + 3];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return this[\n            index * 4 - 4 + 2];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 1];\n};\n\nPromise.prototype._boundValue = function() {};\n\nPromise.prototype._migrateCallback0 = function (follower) {\n    var bitField = follower._bitField;\n    var fulfill = follower._fulfillmentHandler0;\n    var reject = follower._rejectionHandler0;\n    var promise = follower._promise0;\n    var receiver = follower._receiverAt(0);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._migrateCallbackAt = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    promise,\n    receiver,\n    domain\n) {\n    var index = this._length();\n\n    if (index >= 65535 - 4) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        this._receiver0 = receiver;\n        if (typeof fulfill === \"function\") {\n            this._fulfillmentHandler0 =\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 =\n                domain === null ? reject : util.domainBind(domain, reject);\n        }\n    } else {\n        var base = index * 4 - 4;\n        this[base + 2] = promise;\n        this[base + 3] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                domain === null ? reject : util.domainBind(domain, reject);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._proxy = function (proxyable, arg) {\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (((this._bitField & 117506048) !== 0)) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n    var promise = maybePromise._target();\n\n    if (promise === this) {\n        this._reject(makeSelfResolutionError());\n        return;\n    }\n\n    var bitField = promise._bitField;\n    if (((bitField & 50397184) === 0)) {\n        var len = this._length();\n        if (len > 0) promise._migrateCallback0(this);\n        for (var i = 1; i < len; ++i) {\n            promise._migrateCallbackAt(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (((bitField & 33554432) !== 0)) {\n        this._fulfill(promise._value());\n    } else if (((bitField & 16777216) !== 0)) {\n        this._reject(promise._reason());\n    } else {\n        var reason = new CancellationError(\"late cancellation observer\");\n        promise._attachExtraTrace(reason);\n        this._reject(reason);\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, ignoreNonErrorWarnings) {\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n        var message = \"a promise was rejected with a non-error: \" +\n            util.classString(reason);\n        this._warn(message, true);\n    }\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason);\n};\n\nPromise.prototype._resolveFromExecutor = function (executor) {\n    if (executor === INTERNAL) return;\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = this._execute(executor, function(value) {\n        promise._resolveCallback(value);\n    }, function (reason) {\n        promise._rejectCallback(reason, synchronous);\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined) {\n        promise._rejectCallback(r, true);\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    var bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY) {\n        if (!value || typeof value.length !== \"number\") {\n            x = errorObj;\n            x.e = new TypeError(\"cannot .spread() a non-array: \" +\n                                    util.classString(value));\n        } else {\n            x = tryCatch(handler).apply(this._boundValue(), value);\n        }\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    var promiseCreated = promise._popContext();\n    bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n\n    if (x === NEXT_FILTER) {\n        promise._reject(value);\n    } else if (x === errorObj) {\n        promise._rejectCallback(x.e, false);\n    } else {\n        debug.checkForgottenReturns(x, promiseCreated, \"\",  promise, this);\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._settlePromise = function(promise, handler, receiver, value) {\n    var isPromise = promise instanceof Promise;\n    var bitField = this._bitField;\n    var asyncGuaranteed = ((bitField & 134217728) !== 0);\n    if (((bitField & 65536) !== 0)) {\n        if (isPromise) promise._invokeInternalOnCancel();\n\n        if (receiver instanceof PassThroughHandlerContext &&\n            receiver.isFinallyHandler()) {\n            receiver.cancelPromise = promise;\n            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                promise._reject(errorObj.e);\n            }\n        } else if (handler === reflectHandler) {\n            promise._fulfill(reflectHandler.call(receiver));\n        } else if (receiver instanceof Proxyable) {\n            receiver._promiseCancelled(promise);\n        } else if (isPromise || promise instanceof PromiseArray) {\n            promise._cancel();\n        } else {\n            receiver.cancel();\n        }\n    } else if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof Proxyable) {\n        if (!receiver._isResolved()) {\n            if (((bitField & 33554432) !== 0)) {\n                receiver._promiseFulfilled(value, promise);\n            } else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n        if (((bitField & 33554432) !== 0)) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value);\n        }\n    }\n};\n\nPromise.prototype._settlePromiseLateCancellationObserver = function(ctx) {\n    var handler = ctx.handler;\n    var promise = ctx.promise;\n    var receiver = ctx.receiver;\n    var value = ctx.value;\n    if (typeof handler === \"function\") {\n        if (!(promise instanceof Promise)) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (promise instanceof Promise) {\n        promise._reject(value);\n    }\n};\n\nPromise.prototype._settlePromiseCtx = function(ctx) {\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n};\n\nPromise.prototype._settlePromise0 = function(handler, value, bitField) {\n    var promise = this._promise0;\n    var receiver = this._receiverAt(0);\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settlePromise(promise, handler, receiver, value);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    var base = index * 4 - 4;\n    this[base + 2] =\n    this[base + 3] =\n    this[base + 0] =\n    this[base + 1] = undefined;\n};\n\nPromise.prototype._fulfill = function (value) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._reject(err);\n    }\n    this._setFulfilled();\n    this._rejectionHandler0 = value;\n\n    if ((bitField & 65535) > 0) {\n        if (((bitField & 134217728) !== 0)) {\n            this._settlePromises();\n        } else {\n            async.settlePromises(this);\n        }\n    }\n};\n\nPromise.prototype._reject = function (reason) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    this._setRejected();\n    this._fulfillmentHandler0 = reason;\n\n    if (this._isFinal()) {\n        return async.fatalError(reason, util.isNode);\n    }\n\n    if ((bitField & 65535) > 0) {\n        async.settlePromises(this);\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._fulfillPromises = function (len, value) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._fulfillmentHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, value);\n    }\n};\n\nPromise.prototype._rejectPromises = function (len, reason) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._rejectionHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, reason);\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    var bitField = this._bitField;\n    var len = (bitField & 65535);\n\n    if (len > 0) {\n        if (((bitField & 16842752) !== 0)) {\n            var reason = this._fulfillmentHandler0;\n            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n            this._rejectPromises(len, reason);\n        } else {\n            var value = this._rejectionHandler0;\n            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n            this._fulfillPromises(len, value);\n        }\n        this._setLength(0);\n    }\n    this._clearCancellationData();\n};\n\nPromise.prototype._settledValue = function() {\n    var bitField = this._bitField;\n    if (((bitField & 33554432) !== 0)) {\n        return this._rejectionHandler0;\n    } else if (((bitField & 16777216) !== 0)) {\n        return this._fulfillmentHandler0;\n    }\n};\n\nfunction deferResolve(v) {this.promise._resolveCallback(v);}\nfunction deferReject(v) {this.promise._rejectCallback(v, false);}\n\nPromise.defer = Promise.pending = function() {\n    debug.deprecated(\"Promise.defer\", \"new Promise\");\n    var promise = new Promise(INTERNAL);\n    return {\n        promise: promise,\n        resolve: deferResolve,\n        reject: deferReject\n    };\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\n__webpack_require__(/*! ./method */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection,\n    debug);\n__webpack_require__(/*! ./bind */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/bind.js\")(Promise, INTERNAL, tryConvertToPromise, debug);\n__webpack_require__(/*! ./cancel */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/cancel.js\")(Promise, PromiseArray, apiRejection, debug);\n__webpack_require__(/*! ./direct_resolve */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/direct_resolve.js\")(Promise);\n__webpack_require__(/*! ./synchronous_inspection */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/synchronous_inspection.js\")(Promise);\n__webpack_require__(/*! ./join */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/join.js\")(\n    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\nPromise.Promise = Promise;\nPromise.version = \"3.5.1\";\n__webpack_require__(/*! ./map.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/map.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./call_get.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/call_get.js\")(Promise);\n__webpack_require__(/*! ./using.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/using.js\")(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n__webpack_require__(/*! ./timers.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/timers.js\")(Promise, INTERNAL, debug);\n__webpack_require__(/*! ./generators.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/generators.js\")(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n__webpack_require__(/*! ./nodeify.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeify.js\")(Promise);\n__webpack_require__(/*! ./promisify.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promisify.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./props.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/props.js\")(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./race.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/race.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./reduce.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/reduce.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./settle.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/settle.js\")(Promise, PromiseArray, debug);\n__webpack_require__(/*! ./some.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/some.js\")(Promise, PromiseArray, apiRejection);\n__webpack_require__(/*! ./filter.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/filter.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./each.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/each.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./any.js */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/any.js\")(Promise);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    debug.setBounds(Async.firstLineError, util.lastLineError);               \n    return Promise;                                                          \n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise_array.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise_array.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection, Proxyable) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    case -6: return new Map();\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    if (values instanceof Promise) {\n        promise._propagateFrom(values, 3);\n    }\n    promise._setOnCancel(this);\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nutil.inherits(PromiseArray, Proxyable);\n\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        var bitField = values._bitField;\n        ;\n        this._values = values;\n\n        if (((bitField & 50397184) === 0)) {\n            this._promise._setAsyncGuaranteed();\n            return values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n        } else if (((bitField & 33554432) !== 0)) {\n            values = values._value();\n        } else if (((bitField & 16777216) !== 0)) {\n            return this._reject(values._reason());\n        } else {\n            return this._cancel();\n        }\n    }\n    values = util.asArray(values);\n    if (values === null) {\n        var err = apiRejection(\n            \"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n        this._promise._rejectCallback(err, false);\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    this._iterate(values);\n};\n\nPromiseArray.prototype._iterate = function(values) {\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var result = this._promise;\n    var isResolved = false;\n    var bitField = null;\n    for (var i = 0; i < len; ++i) {\n        var maybePromise = tryConvertToPromise(values[i], result);\n\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            bitField = maybePromise._bitField;\n        } else {\n            bitField = null;\n        }\n\n        if (isResolved) {\n            if (bitField !== null) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        } else if (bitField !== null) {\n            if (((bitField & 50397184) === 0)) {\n                maybePromise._proxy(this, i);\n                this._values[i] = maybePromise;\n            } else if (((bitField & 33554432) !== 0)) {\n                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n            } else if (((bitField & 16777216) !== 0)) {\n                isResolved = this._promiseRejected(maybePromise._reason(), i);\n            } else {\n                isResolved = this._promiseCancelled(i);\n            }\n        } else {\n            isResolved = this._promiseFulfilled(maybePromise, i);\n        }\n    }\n    if (!isResolved) result._setAsyncGuaranteed();\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype._cancel = function() {\n    if (this._isResolved() || !this._promise._isCancellable()) return;\n    this._values = null;\n    this._promise._cancel();\n};\n\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false);\n};\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nPromiseArray.prototype._promiseCancelled = function() {\n    this._cancel();\n    return true;\n};\n\nPromiseArray.prototype._promiseRejected = function (reason) {\n    this._totalResolved++;\n    this._reject(reason);\n    return true;\n};\n\nPromiseArray.prototype._resultCancelled = function() {\n    if (this._isResolved()) return;\n    var values = this._values;\n    this._cancel();\n    if (values instanceof Promise) {\n        values.cancel();\n    } else {\n        for (var i = 0; i < values.length; ++i) {\n            if (values[i] instanceof Promise) {\n                values[i].cancel();\n            }\n        }\n    }\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promise_array.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promisify.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promisify.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/nodeback.js\");\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n    var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode);\n    body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\n                        body)(\n                    Promise,\n                    fn,\n                    receiver,\n                    withAppended,\n                    maybeWrapAsError,\n                    nodebackForPromise,\n                    util.tryCatch,\n                    util.errorObj,\n                    util.notEnumerableProp,\n                    INTERNAL);\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise, multiArgs);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key,\n                                           fn, suffix, multiArgs);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined,\n                                callback, null, multiArgs);\n}\n\nPromise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier,\n                multiArgs);\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n};\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/promisify.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/props.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/props.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar isObject = util.isObject;\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js\");\nvar Es6Map;\nif (typeof Map === \"function\") Es6Map = Map;\n\nvar mapToEntries = (function() {\n    var index = 0;\n    var size = 0;\n\n    function extractEntry(value, key) {\n        this[index] = value;\n        this[index + size] = key;\n        index++;\n    }\n\n    return function mapToEntries(map) {\n        size = map.size;\n        index = 0;\n        var ret = new Array(map.size * 2);\n        map.forEach(extractEntry, ret);\n        return ret;\n    };\n})();\n\nvar entriesToMap = function(entries) {\n    var ret = new Es6Map();\n    var length = entries.length / 2 | 0;\n    for (var i = 0; i < length; ++i) {\n        var key = entries[length + i];\n        var value = entries[i];\n        ret.set(key, value);\n    }\n    return ret;\n};\n\nfunction PropertiesPromiseArray(obj) {\n    var isMap = false;\n    var entries;\n    if (Es6Map !== undefined && obj instanceof Es6Map) {\n        entries = mapToEntries(obj);\n        isMap = true;\n    } else {\n        var keys = es5.keys(obj);\n        var len = keys.length;\n        entries = new Array(len * 2);\n        for (var i = 0; i < len; ++i) {\n            var key = keys[i];\n            entries[i] = obj[key];\n            entries[i + len] = key;\n        }\n    }\n    this.constructor$(entries);\n    this._isMap = isMap;\n    this._init$(undefined, isMap ? -6 : -3);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val;\n        if (this._isMap) {\n            val = entriesToMap(this._values);\n        } else {\n            val = {};\n            var keyOffset = this.length();\n            for (var i = 0, len = this.length(); i < len; ++i) {\n                val[this._values[i + keyOffset]] = this._values[i];\n            }\n        }\n        this._resolve(val);\n        return true;\n    }\n    return false;\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 2);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/props.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/queue.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/queue.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/queue.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/race.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/race.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else {\n        promises = util.asArray(promises);\n        if (promises === null)\n            return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 3);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/race.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/reduce.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/reduce.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar getDomain = Promise._getDomain;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nfunction ReductionPromiseArray(promises, fn, initialValue, _each) {\n    this.constructor$(promises);\n    var domain = getDomain();\n    this._fn = domain === null ? fn : util.domainBind(domain, fn);\n    if (initialValue !== undefined) {\n        initialValue = Promise.resolve(initialValue);\n        initialValue._attachCancellationCallback(this);\n    }\n    this._initialValue = initialValue;\n    this._currentCancellable = null;\n    if(_each === INTERNAL) {\n        this._eachValues = Array(this._length);\n    } else if (_each === 0) {\n        this._eachValues = null;\n    } else {\n        this._eachValues = undefined;\n    }\n    this._promise._captureStackTrace();\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._gotAccum = function(accum) {\n    if (this._eachValues !== undefined && \n        this._eachValues !== null && \n        accum !== INTERNAL) {\n        this._eachValues.push(accum);\n    }\n};\n\nReductionPromiseArray.prototype._eachComplete = function(value) {\n    if (this._eachValues !== null) {\n        this._eachValues.push(value);\n    }\n    return this._eachValues;\n};\n\nReductionPromiseArray.prototype._init = function() {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function() {\n    this._resolve(this._eachValues !== undefined ? this._eachValues\n                                                 : this._initialValue);\n};\n\nReductionPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nReductionPromiseArray.prototype._resolve = function(value) {\n    this._promise._resolveCallback(value);\n    this._values = null;\n};\n\nReductionPromiseArray.prototype._resultCancelled = function(sender) {\n    if (sender === this._initialValue) return this._cancel();\n    if (this._isResolved()) return;\n    this._resultCancelled$();\n    if (this._currentCancellable instanceof Promise) {\n        this._currentCancellable.cancel();\n    }\n    if (this._initialValue instanceof Promise) {\n        this._initialValue.cancel();\n    }\n};\n\nReductionPromiseArray.prototype._iterate = function (values) {\n    this._values = values;\n    var value;\n    var i;\n    var length = values.length;\n    if (this._initialValue !== undefined) {\n        value = this._initialValue;\n        i = 0;\n    } else {\n        value = Promise.resolve(values[0]);\n        i = 1;\n    }\n\n    this._currentCancellable = value;\n\n    if (!value.isRejected()) {\n        for (; i < length; ++i) {\n            var ctx = {\n                accum: null,\n                value: values[i],\n                index: i,\n                length: length,\n                array: this\n            };\n            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n        }\n    }\n\n    if (this._eachValues !== undefined) {\n        value = value\n            ._then(this._eachComplete, undefined, undefined, this, undefined);\n    }\n    value._then(completed, completed, undefined, value, this);\n};\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n\nfunction completed(valueOrReason, array) {\n    if (this.isFulfilled()) {\n        array._resolve(valueOrReason);\n    } else {\n        array._reject(valueOrReason);\n    }\n}\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nfunction gotAccum(accum) {\n    this.accum = accum;\n    this.array._gotAccum(accum);\n    var value = tryConvertToPromise(this.value, this.array._promise);\n    if (value instanceof Promise) {\n        this.array._currentCancellable = value;\n        return value._then(gotValue, undefined, undefined, this, undefined);\n    } else {\n        return gotValue.call(this, value);\n    }\n}\n\nfunction gotValue(value) {\n    var array = this.array;\n    var promise = array._promise;\n    var fn = tryCatch(array._fn);\n    promise._pushContext();\n    var ret;\n    if (array._eachValues !== undefined) {\n        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n    } else {\n        ret = fn.call(promise._boundValue(),\n                              this.accum, value, this.index, this.length);\n    }\n    if (ret instanceof Promise) {\n        array._currentCancellable = ret;\n    }\n    var promiseCreated = promise._popContext();\n    debug.checkForgottenReturns(\n        ret,\n        promiseCreated,\n        array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\",\n        promise\n    );\n    return ret;\n}\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/reduce.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/schedule.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/schedule.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar schedule;\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar NativePromise = util.getNativePromise();\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if (typeof NativePromise === \"function\" &&\n           typeof NativePromise.resolve === \"function\") {\n    var nativePromise = NativePromise.resolve();\n    schedule = function(fn) {\n        nativePromise.then(fn);\n    };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            (window.navigator.standalone || window.cordova))) {\n    schedule = (function() {\n        var div = document.createElement(\"div\");\n        var opts = {attributes: true};\n        var toggleScheduled = false;\n        var div2 = document.createElement(\"div\");\n        var o2 = new MutationObserver(function() {\n            div.classList.toggle(\"foo\");\n            toggleScheduled = false;\n        });\n        o2.observe(div2, opts);\n\n        var scheduleToggle = function() {\n            if (toggleScheduled) return;\n            toggleScheduled = true;\n            div2.classList.toggle(\"foo\");\n        };\n\n        return function schedule(fn) {\n            var o = new MutationObserver(function() {\n                o.disconnect();\n                fn();\n            });\n            o.observe(div, opts);\n            scheduleToggle();\n        };\n    })();\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/schedule.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/settle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/settle.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\n    function(Promise, PromiseArray, debug) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 33554432;\n    ret._settledValueField = value;\n    return this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 16777216;\n    ret._settledValueField = reason;\n    return this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    debug.deprecated(\".settle()\", \".reflect()\");\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return Promise.settle(this);\n};\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/settle.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/some.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/some.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar RangeError = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\").RangeError;\nvar AggregateError = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\").AggregateError;\nvar isArray = util.isArray;\nvar CANCELLATION = {};\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n        return true;\n    }\n    return false;\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._promiseCancelled = function () {\n    if (this._values instanceof Promise || this._values == null) {\n        return this._cancel();\n    }\n    this._addRejected(CANCELLATION);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._checkOutcome = function() {\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            if (this._values[i] !== CANCELLATION) {\n                e.push(this._values[i]);\n            }\n        }\n        if (e.length > 0) {\n            this._reject(e);\n        } else {\n            this._cancel();\n        }\n        return true;\n    }\n    return false;\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/some.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/synchronous_inspection.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/synchronous_inspection.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValueField = promise._isFateSealed()\n            ? promise._settledValue() : undefined;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValueField = undefined;\n    }\n}\n\nPromiseInspection.prototype._settledValue = function() {\n    return this._settledValueField;\n};\n\nvar value = PromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar reason = PromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar isFulfilled = PromiseInspection.prototype.isFulfilled = function() {\n    return (this._bitField & 33554432) !== 0;\n};\n\nvar isRejected = PromiseInspection.prototype.isRejected = function () {\n    return (this._bitField & 16777216) !== 0;\n};\n\nvar isPending = PromiseInspection.prototype.isPending = function () {\n    return (this._bitField & 50397184) === 0;\n};\n\nvar isResolved = PromiseInspection.prototype.isResolved = function () {\n    return (this._bitField & 50331648) !== 0;\n};\n\nPromiseInspection.prototype.isCancelled = function() {\n    return (this._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.__isCancelled = function() {\n    return (this._bitField & 65536) === 65536;\n};\n\nPromise.prototype._isCancelled = function() {\n    return this._target().__isCancelled();\n};\n\nPromise.prototype.isCancelled = function() {\n    return (this._target()._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.isPending = function() {\n    return isPending.call(this._target());\n};\n\nPromise.prototype.isRejected = function() {\n    return isRejected.call(this._target());\n};\n\nPromise.prototype.isFulfilled = function() {\n    return isFulfilled.call(this._target());\n};\n\nPromise.prototype.isResolved = function() {\n    return isResolved.call(this._target());\n};\n\nPromise.prototype.value = function() {\n    return value.call(this._target());\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    target._unsetRejectionIsUnhandled();\n    return reason.call(target);\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue();\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue();\n};\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/synchronous_inspection.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/thenables.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/thenables.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) return obj;\n        var then = getThen(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            if (isAnyBluebirdPromise(obj)) {\n                var ret = new Promise(INTERNAL);\n                obj._then(\n                    ret._fulfill,\n                    ret._reject,\n                    undefined,\n                    ret,\n                    null\n                );\n                return ret;\n            }\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction doGetThen(obj) {\n    return obj.then;\n}\n\nfunction getThen(obj) {\n    try {\n        return doGetThen(obj);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    try {\n        return hasProp.call(obj, \"_promise0\");\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x, resolve, reject);\n    synchronous = false;\n\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolve(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function reject(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/thenables.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/timers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/timers.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nfunction HandleWrapper(handle)  {\n    this.handle = handle;\n}\n\nHandleWrapper.prototype._resultCancelled = function() {\n    clearTimeout(this.handle);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (ms, value) {\n    var ret;\n    var handle;\n    if (value !== undefined) {\n        ret = Promise.resolve(value)\n                ._then(afterValue, null, null, ms, undefined);\n        if (debug.cancellation() && value instanceof Promise) {\n            ret._setOnCancel(value);\n        }\n    } else {\n        ret = new Promise(INTERNAL);\n        handle = setTimeout(function() { ret._fulfill(); }, +ms);\n        if (debug.cancellation()) {\n            ret._setOnCancel(new HandleWrapper(handle));\n        }\n        ret._captureStackTrace();\n    }\n    ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(ms, this);\n};\n\nvar afterTimeout = function (promise, message, parent) {\n    var err;\n    if (typeof message !== \"string\") {\n        if (message instanceof Error) {\n            err = message;\n        } else {\n            err = new TimeoutError(\"operation timed out\");\n        }\n    } else {\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._reject(err);\n\n    if (parent != null) {\n        parent.cancel();\n    }\n};\n\nfunction successClear(value) {\n    clearTimeout(this.handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    clearTimeout(this.handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret, parent;\n\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n        if (ret.isPending()) {\n            afterTimeout(ret, message, parent);\n        }\n    }, ms));\n\n    if (debug.cancellation()) {\n        parent = this.then();\n        ret = parent._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n        ret._setOnCancel(handleWrapper);\n    } else {\n        ret = this._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n    }\n\n    return ret;\n};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/timers.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/using.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/using.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext, INTERNAL, debug) {\n    var util = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\");\n    var TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/errors.js\").TypeError;\n    var inherits = __webpack_require__(/*! ./util */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js\").inherits;\n    var errorObj = util.errorObj;\n    var tryCatch = util.tryCatch;\n    var NULL = {};\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = new Promise(INTERNAL);\n        function iterator() {\n            if (i >= len) return ret._fulfill();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret;\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return NULL;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== NULL\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    function ResourceList(length) {\n        this.length = length;\n        this.promise = null;\n        this[length-1] = null;\n    }\n\n    ResourceList.prototype._resultCancelled = function() {\n        var len = this.length;\n        for (var i = 0; i < len; ++i) {\n            var item = this[i];\n            if (item instanceof Promise) {\n                item.cancel();\n            }\n        }\n    };\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") {\n            return apiRejection(\"expecting a function but got \" + util.classString(fn));\n        }\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new ResourceList(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var reflectedResources = new Array(resources.length);\n        for (var i = 0; i < reflectedResources.length; ++i) {\n            reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n        }\n\n        var resultPromise = Promise.all(reflectedResources)\n            .then(function(inspections) {\n                for (var i = 0; i < inspections.length; ++i) {\n                    var inspection = inspections[i];\n                    if (inspection.isRejected()) {\n                        errorObj.e = inspection.error();\n                        return errorObj;\n                    } else if (!inspection.isFulfilled()) {\n                        resultPromise.cancel();\n                        return;\n                    }\n                    inspections[i] = inspection.value();\n                }\n                promise._pushContext();\n\n                fn = tryCatch(fn);\n                var ret = spreadArgs\n                    ? fn.apply(undefined, inspections) : fn(inspections);\n                var promiseCreated = promise._popContext();\n                debug.checkForgottenReturns(\n                    ret, promiseCreated, \"Promise.using\", promise);\n                return ret;\n            });\n\n        var promise = resultPromise.lastly(function() {\n            var inspection = new Promise.PromiseInspection(resultPromise);\n            return dispose(resources, inspection);\n        });\n        resources.promise = promise;\n        promise._setOnCancel(resources);\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 131072;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 131072) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~131072);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/using.js?");

/***/ }),

/***/ "./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/rethinkdbdash/node_modules/bluebird/js/release/es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nvar globalObject = typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    typeof global !== \"undefined\" ? global :\n    this !== undefined ? this : null;\n\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return typeof value === \"function\" ||\n           typeof value === \"object\" && value !== null;\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function FakeConstructor() {}\n    FakeConstructor.prototype = obj;\n    var l = 8;\n    while (l--) new FakeConstructor();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction isError(obj) {\n    return obj instanceof Error ||\n        (obj !== null &&\n           typeof obj === \"object\" &&\n           typeof obj.message === \"string\" &&\n           typeof obj.name === \"string\");\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar asArray = function(v) {\n    if (es5.isArray(v)) {\n        return v;\n    }\n    return null;\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n    var ArrayFrom = typeof Array.from === \"function\" ? function(v) {\n        return Array.from(v);\n    } : function(v) {\n        var ret = [];\n        var it = v[Symbol.iterator]();\n        var itResult;\n        while (!((itResult = it.next()).done)) {\n            ret.push(itResult.value);\n        }\n        return ret;\n    };\n\n    asArray = function(v) {\n        if (es5.isArray(v)) {\n            return v;\n        } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n            return ArrayFrom(v);\n        }\n        return null;\n    };\n}\n\nvar isNode = typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\";\n\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\n\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n\nfunction getNativePromise() {\n    if (typeof Promise === \"function\") {\n        try {\n            var promise = new Promise(function(){});\n            if ({}.toString.call(promise) === \"[object Promise]\") {\n                return Promise;\n            }\n        } catch (e) {}\n    }\n}\n\nfunction domainBind(self, cb) {\n    return self.bind(cb);\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    asArray: asArray,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    isError: isError,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    hasDevTools: typeof chrome !== \"undefined\" && chrome &&\n                 typeof chrome.loadTimes === \"function\",\n    isNode: isNode,\n    hasEnvVariables: hasEnvVariables,\n    env: env,\n    global: globalObject,\n    getNativePromise: getNativePromise,\n    domainBind: domainBind\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version = process.versions.node.split(\".\").map(Number);\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n\n\n//# sourceURL=webpack:///./node_modules/rethinkdbdash/node_modules/bluebird/js/release/util.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/document.js":
/*!*********************************************!*\
  !*** ./node_modules/thinky/lib/document.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var schemaUtil =    __webpack_require__(/*! ./node_modules/thinky/lib/schema.js */ \"./node_modules/thinky/lib/schema.js\");\nvar type =          __webpack_require__(/*! ./node_modules/thinky/lib/type/index.js */ \"./node_modules/thinky/lib/type/index.js\");\nvar util =          __webpack_require__(/*! ./node_modules/thinky/lib/util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Promise =       __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/main/bluebird.js\");\nvar EventEmitter =  __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Errors =        __webpack_require__(/*! ./node_modules/thinky/lib/errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\n\n/**\n * Create a document of a model (returned by `thinky.createModel`).\n * @param {function} model The model of this document\n * @param {object=} options Options that can overwrite the ones of the model\n */\nfunction Document(model, options) {\n  var self = this;  // Keep a reference to itself.\n\n  this.constructor = model;  // The constructor for this model\n  this._model = model._getModel(); // The instance of Model\n\n  // We don't want to store options if they are different\n  // than the one provided by the model\n  if (util.isPlainObject(options)) {\n    this._schemaOptions = {};\n    this._schemaOptions.enforce_missing =\n        (options.enforce_missing != null) ? options.enforce_missing : model.getOptions().enforce_missing;\n    this._schemaOptions.enforce_extra =\n        (options.enforce_extra != null) ? options.enforce_extra : model.getOptions().enforce_extra;\n    this._schemaOptions.enforce_type =\n        (options.enforce_type != null) ? options.enforce_type : model.getOptions().enforce_type;\n  }\n\n  //TODO: We do not need to make a deep copy. We can do the same as for this._schemaOptions.\n  options = options || {};\n  this._options = {};\n  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : model.getOptions().timeFormat;\n  this._options.validate = (options.validate != null) ? options.validate : model.getOptions().validate;\n\n  this._saved = options.saved || false;  // Whether the document is saved or not\n\n  util.bindEmitter(self);  // Copy methods from eventEmitter\n\n  // links to hasOne/hasMany documents\n  // We use it to know if some links have been removed/added before saving.\n  // Example: { key: doc } or { key: [docs] }\n  this._belongsTo = {};\n  this._hasOne = {};\n  this._hasMany = {};\n  // Example: { <linkTableName>: { <valueOfRightKey>: true, ... }, ... }\n  this._links = {}\n\n  // Keep reference of any doc having a link pointing to this\n  // So we can clean when users do doc.belongsToDoc.delete()\n  this._parents = {\n    _hasOne: {},      // <tableName>: [{doc, key}]\n    _hasMany: {},     // <tableName>: [{doc, key}]\n    _belongsTo: {},   // <tableName>: [{doc, key, foreignKey}]\n    _belongsLinks: {} // <tableName>: [{doc, key}]\n  }\n\n  // Bind listeners of the model to this documents.\n  util.loopKeys(model._listeners, function(listeners, eventKey) {\n    for(var j=0; j<listeners[eventKey].length; j++) {\n      if (listeners[eventKey][j].once === false) {\n        self.addListener(eventKey, listeners[eventKey][j].listener);\n      }\n      else if (listeners[eventKey][j].once === true) {\n        self.once(eventKey, listeners[eventKey][j].listener);\n      }\n    }\n  });\n\n\n  // Atom feed\n  this._active = false;\n  this._feed = null;\n\n  // Add customized methods of the model on this document.\n  util.loopKeys(model._methods, function(methods, key) {\n    if (self[key] === undefined) {\n      self[key] = methods[key];\n    }\n    else {\n      //TODO: Should we warn the users? Throw an error?\n      console.log(self[key]);\n      console.log(\"A property \"+key+\" is already defined in the prototype chain. Skipping.\");\n    }\n  });\n}\n\n\n/**\n * Return the options of the document, not the instance of Document.\n * @return {Object=}\n */\nDocument.prototype._getOptions = function() {\n  return this.__proto__._options;\n}\n\n\n/**\n * Return the options for the schema of the document, not the instance of Document.\n * @return {Object=}\n */\nDocument.prototype._getSchemaOptions = function() {\n  return this.__proto__._schemaOptions;\n}\n\n\n/**\n * Return the constructor of the document, not the instance of Document.\n * @return {function}\n */\nDocument.prototype.getModel = function() {\n  return this.__proto__.constructor;\n}\n\n\n/**\n * Return the model, the instance of Model\n * @return {function}\n */\nDocument.prototype._getModel = function() {\n  return this.__proto__._model;\n}\n\n\n/**\n * Save the virtual fields of the document to be re-injected later.\n */\nDocument.prototype._saveVirtual = function() {\n  var copy = {};\n  var model = this._getModel(); // instance of Model\n\n  // TODO We could do better and copy less things, but things get a bit tricky\n  // when virtual fields are nested in arrays.\n  // This implementation still allows no overhead if no virtual fields exist,\n  // which should be the most common case\n  for(var i=0; i<this._getModel().virtualFields.length; i++) {\n    var key = this._getModel().virtualFields[i].path[0];\n    copy[key] = this[key];\n  }\n  this.__proto__.virtualValue = util.deepCopy(copy);\n}\n\n\n/**\n * Get the virtual fields saved by `_saveVirtual`.\n * @return {Object=}\n */\nDocument.prototype._getVirtual = function() {\n  return this.__proto__.virtualValue;\n}\n\n/**\n * Generate the virtual values for the document, or re-inject the ones\n * previously saved.\n * This should be called **after** `_generateDefault`.\n */\nDocument.prototype.generateVirtualValues = function() {\n  for(var i=0; i<this._getModel().virtualFields.length; i++) {\n    schemaUtil.generateVirtual(this, this._getModel().virtualFields[i], this, this._getVirtual());\n  }\n}\n\n\n/**\n * Generate the default values for the document, first the non virtual fields, and then\n * the virtual fields.\n */\nDocument.prototype._generateDefault = function() {\n  for(var i=0; i<this._getModel().defaultFields.length; i++) {\n    schemaUtil.generateDefault(this, this._getModel().defaultFields[i], this);\n  }\n  if (this._getModel().virtualFields.length > 0) {\n    this.generateVirtualValues();\n  }\n}\n\n\n/*\n * Validate this document against the schema of its model and triggers all the hooks.\n * @param {Object=} options Options to overwrite the ones of the document.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.\n * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.\n * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).\n * @return {Promise=} return a promise if the validation is asynchrone, else undefined.\n */\nDocument.prototype.validate = function(options, modelToValidate, validateAll, validatedModel, prefix) {\n  modelToValidate = modelToValidate || {};\n  validateAll = validateAll || false;\n  validatedModel = validatedModel || {};\n  prefix = prefix || '';\n\n  var self = this;\n  var validatedModelCopy = util.deepCopy(validatedModel);\n\n  //TODO: Can we not always call this?\n  var async = self._validateIsAsync(modelToValidate, validateAll, validatedModelCopy);\n\n  return util.hook({\n    preHooks: self._getModel()._pre.validate,\n    postHooks: self._getModel()._post.validate,\n    doc: self,\n    async: async,\n    fn: self._validateHook,\n    fnArgs: [options, modelToValidate, validateAll, validatedModel, prefix]\n  })\n}\n\n\n/*\n * Validate this document against the schema of its model and all its joined documents and triggers all the hooks\n * @param {Object=} options Options to overwrite the ones of the document.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @return {Promise=} return a promise if the validation is asynchrone, else undefined.\n */\nDocument.prototype.validateAll = function(options, modelToValidate) {\n  var validateAll = modelToValidate === undefined;\n  modelToValidate = modelToValidate || {};\n\n  return this.validate(options, modelToValidate, validateAll, {}, '', true);\n}\n\n\n/*\n * Internal methods that will validate the document (but that will not execute the hooks).\n * @param {Object=} options Options to overwrite the ones of the document.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.\n * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.\n * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).\n * @return {Promise=} return a promise if the validation is asynchrone, else undefined.\n */\nDocument.prototype._validateHook = function(options, modelToValidate, validateAll, validatedModel, prefix) {\n  var self = this;\n  var promises = [];\n  var error;\n\n  var schemaOptions = self._getSchemaOptions();\n  if (util.isPlainObject(schemaOptions)) {\n    schemaOptions = util.mergeOptions(schemaOptions, options);\n  }\n  else {\n    schemaOptions = options;\n  }\n\n\n  if (typeof self._getModel()._validator === 'function') {\n    if (self._getModel()._validator.call(self, self) === false) {\n      throw new Errors.ValidationError(\"Document's validator returned `false`.\");\n    }\n  }\n\n  // Validate this document\n  self._getModel()._schema.validate(self, prefix, schemaOptions)\n\n  if (util.isPlainObject(modelToValidate) === false) {\n    modelToValidate = {};\n  }\n\n  var constructor = self.__proto__.constructor;\n  validatedModel[constructor.getTableName()] = true;\n\n  // Validate joined documents\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {\n      switch (joins[key].type) {\n        case 'hasOne':\n        case 'belongsTo':\n          if (util.isPlainObject(self[key])) {\n            if (self[key] instanceof Document === false) {\n              self[key] = new self._getModel()._joins[key].model(self[key]);\n            }\n            // We do not propagate the options of this document, but only those given to validate\n            var promise = self[key].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']');\n            if (promise instanceof Promise) {\n              promises.push(promise);\n              promise = null;\n            }\n          }\n          else if (self[key] != null) {\n            throw new Errors.ValidationError(\"Joined field \"+prefix+\"[\"+key+\"] should be `undefined`, `null` or an `Object`\")\n          }\n          break;\n\n        case 'hasMany':\n        case 'hasAndBelongsToMany':\n          if (Array.isArray(self[key])) {\n            for(var i=0; i<self[key].length; i++) {\n              if (util.isPlainObject(self[key][i])) {\n                if (self[key][i] instanceof Document === false) {\n                  self[key][i] = new self._getModel()._joins[key].model(self[key][i]);\n                }\n                promise = self[key][i].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']['+i+']');\n                if (promise instanceof Promise) {\n                  promises.push(promise);\n                  promise = null;\n                }\n              }\n              else {\n                throw new Errors.ValidationError(\"Joined field \"+prefix+\"[\"+key+\"][\"+i+\"] should be `undefined`, `null` or an `Array`\")\n              }\n            }\n          }\n          else if (self[key] != null) {\n            throw new Errors.ValidationError(\"Joined field \"+prefix+\"[\"+key+\"] should be `undefined`, `null` or an `Array`\")\n          }\n          break;\n      }\n    }\n  });\n  if (promises.length > 0) {\n    return Promise.all(promises);\n  }\n}\n\n\n/*\n * Return whether the validation run with the same options will be asynchronous or not.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.\n * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.\n * @return {boolean}\n */\nDocument.prototype._validateIsAsync = function(modelToValidate, validateAll, validatedModel) {\n  var self = this;\n\n  if (self._getModel()._async.validate) {\n    return true;\n  }\n  var async = false;\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {\n      if (((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo'))) {\n        if (util.isPlainObject(self[key])) {\n          if (self[key] instanceof Document === false) {\n            self[key] = new self._getModel()._joins[key].model(self[key]);\n          }\n          // We do not propagate the options of this document, but only those given to validate\n          if (self[key]._getModel()._async.validate || self[key]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {\n            async = true;\n            return false;\n          }\n        }\n      }\n      else  if (((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany'))) {\n        if (Array.isArray(self[key])) {\n          for(var i=0; i<self[key].length; i++) {\n            if (util.isPlainObject(self[key][i])) {\n              if (self[key][i] instanceof Document === false) {\n                self[key][i] = new self._getModel()._joins[key].model(self[key][i]);\n              }\n              if (self[key][i]._getModel()._async.validate || self[key][i]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {\n                async = true;\n                return false;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  });\n  return async;\n}\n\n\n/**\n * Save the document and execute the hooks. Return a promise if the callback\n * is not provided.\n * @param {function=} callback to execute\n * @return {Promise=}\n */\nDocument.prototype.save = function(callback) {\n  return this._save({}, false, {}, callback);\n}\n\n\n/**\n * Save the document and its joined documents. It will also execute the hooks.\n * Return a promise if the callback is not provided.\n * It will save joined documents as long as a document of the same model has not\n * been saved.\n * @param {function=} callback to execute\n * @return {Promise=}\n */\nDocument.prototype.saveAll = function(docToSave, callback) {\n  var saveAll;\n  if (typeof docToSave === 'function') {\n    callback = docToSave;\n    saveAll = true;\n    docToSave = {};\n  }\n  else {\n    saveAll = docToSave === undefined;\n    docToSave = docToSave || {};\n  }\n\n  return this._save(docToSave, saveAll,{}, callback);\n}\n\n\n/**\n * Return a savable copy of the document by removing the extra fields,\n * generating the default and virtual fields.\n * @return {object}\n */\nDocument.prototype._makeSavableCopy = function() {\n  var model = this._getModel(); // instance of Model\n  var schema = this._getModel()._schema;\n\n  var r = this._getModel()._thinky.r;\n\n  if (this._getModel().needToGenerateFields === true){\n    this._generateDefault();\n  }\n\n  return this.__makeSavableCopy(this, schema, this._getOptions(), model, r)\n}\n\n\n/**\n * Internal helper for _makeSavableCopy.\n * generating the dfault and virtual fields.\n * @return {any} the copy of the field/object.\n */\nDocument.prototype.__makeSavableCopy = function(doc, schema, options, model, r) {\n  var localOptions; // can be undefined\n  if (schema !== undefined) {\n    localOptions = schema._options;\n  }\n\n  // model is an instance of a Model (for the top level fields), or undefined\n  var result, key, keys, nextSchema, copyFlag;\n  if (type.isDate(schema) && (typeof doc === 'string' || typeof doc === 'number')) {\n    if (typeof doc === 'number') {\n      var numericDate = parseInt(doc, 10);\n      if(!isNaN(numericDate)) {\n        doc = numericDate;\n      }\n    }\n    return new Date(doc); // Use r.ISO8601 and not `new Date()` to keep timezone\n  }\n  else if (type.isPoint(schema)) {\n    if (util.isPlainObject(doc) && (doc['$reql_type$'] !== \"GEOMETRY\")) {\n      var keys = Object.keys(doc).sort();\n      if ((keys.length === 2) && (keys[0] === 'latitude') && (keys[1] === 'longitude') && (typeof doc.latitude === \"number\") && (typeof doc.longitude === \"number\")) {\n        return r.point(doc.longitude, doc.latitude)\n      }\n      else if ((doc.type === \"Point\") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson\n        return r.geojson(doc)\n      }\n    }\n    else if (Array.isArray(doc)) {\n      if ((doc.length === 2) && (typeof doc[0] === \"number\") && (typeof doc[1] === \"number\")) {\n        return r.point(doc[0], doc[1])\n      }\n    }\n    else { // no transformation are required here, return doc\n      return doc;\n    }\n  }\n  else if (type.isNumber(schema) && (typeof doc === 'string')) {\n    var numericString = parseFloat(doc);\n    if(!isNaN(numericString)){\n      return numericString;\n    }else{\n      return doc;\n    }\n  }\n\n  if (util.isPlainObject(doc) && (doc instanceof Buffer === false)) {\n    result = {};\n    util.loopKeys(doc, function(doc, key) {\n      copyFlag = true;\n      if ((util.isPlainObject(model) === false) || (model._joins[key] === undefined)) { // We do not copy joined documents\n        if ((schema !== undefined) && (schema._schema !== undefined) && (type.isVirtual(schema._schema[key]) === true)) {\n          // We do not copy virtual\n        }\n        else if (((schema === undefined) || (schema._schema === undefined) || (schema._schema[key] === undefined)) &&\n            (localOptions !== undefined) && (localOptions.enforce_extra === \"remove\")) {\n          // We do not copy fields if enfroce_extra is \"remove\"\n        }\n        else {\n          if ((schema !== undefined) && (schema._schema !== undefined)) {\n            nextSchema = schema._schema[key];\n          }\n          else {\n            nextSchema = undefined;\n          }\n          result[key] = Document.prototype.__makeSavableCopy(doc[key], nextSchema, localOptions, undefined, r);\n        }\n      }\n    });\n\n    // Copy the fields that are used as foreign keys\n    if (util.isPlainObject(model) === true) {\n      util.loopKeys(model._localKeys, function(localKeys, localKey) {\n        if (doc[localKey] !== undefined) {\n          if (schema !== undefined) {\n            nextSchema = schema._schema[key];\n          }\n          else {\n            nextSchema = undefined;\n          }\n          //TODO: Do we want to copy the foreign key value? If yes, there's no need for this loop\n          //Do we want to copy the key from the joined document? If yes we need to replace doc[localKey]\n          result[localKey] = Document.prototype.__makeSavableCopy(doc[localKey], nextSchema, localOptions, undefined, r);\n        }\n      });\n    }\n    return result;\n  }\n  else if (Array.isArray(doc)) {\n    result = [];\n    copyFlag = true;\n\n    // Next schema\n    if (type.isArray(schema)) {\n      nextSchema = schema._schema;\n    }\n    else if ((util.isPlainObject(schema)) && (schema._type !== undefined) && (schema._schema !== undefined)) {\n      nextSchema = schema._schema\n      if (schema._type === \"virtual\") {\n        copyFlag = false;\n      }\n    }\n    else {\n      nextSchema = undefined;\n    }\n    if (copyFlag === true) {\n      for(var i=0; i<doc.length; i++) {\n        result.push(Document.prototype.__makeSavableCopy(doc[i], nextSchema, localOptions, undefined, r));\n      }\n    }\n    return result;\n  }\n  // else, doc is a primitive (or a buffer)\n  return doc;\n}\n\n\n/**\n * Save the document, its joined documents and execute the hooks. Return a\n * promise if the callback is undefined.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Object=} callback to execute\n * @return {Promise=}\n */\nDocument.prototype._save = function(docToSave, saveAll, savedModel, callback) {\n  //TOIMPROVE? How should we handle circular references outsides of joined fields? Now we throw with a maximum call stack size exceed\n  var self = this;\n  self.emit('saving', self);\n\n  return util.hook({\n    preHooks: self._getModel()._pre.save,\n    postHooks: self._getModel()._post.save,\n    doc: self,\n    async: true,\n    fn: self._saveHook,\n    fnArgs: [docToSave, saveAll, savedModel]\n  }).nodeify(callback);\n}\n\n\n/**\n * Save the document and execute the hooks. This is an internal method used with\n * Model.save. This let us use a similar code path for `document.save` and `Model.save`.\n * @param {Function} executeInsert the method that will execute the batch insert\n * @return {Promise}\n */\nDocument.prototype._batchSave = function(executeInsert) {\n  // Keep in sync with _save\n  var self = this;\n  self.emit('saving', self);\n\n  return util.hook({\n    preHooks: self._getModel()._pre.save,\n    postHooks: self._getModel()._post.save,\n    doc: self,\n    async: true,\n    fn: self._batchSaveSelf,\n    fnArgs: [executeInsert]\n  });\n}\n\n\n/**\n * Call executeInsert when the model is ready\n * @param {Function} executeInsert the method that will execute the batch insert\n * @return {Promise}\n */\nDocument.prototype._batchSaveSelf = function(executeInsert) {\n  var self = this;\n\n  return new Promise(function(resolve, reject) {\n    self.getModel().ready().then(function() {\n      executeInsert(resolve, reject)\n    });\n  })\n}\n\n\n/**\n * Save the document and maybe its joined documents. Hooks have been dealt with\n * in _save.\n * @param {!Object} copy The savable copy of the original documents.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {Object=} belongsToKeysSaved The keys that may contains a document to save\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveHook = function(docToSave, saveAll, savedModel) {\n  var self = this;\n  var model = self._getModel(); // instance of Model\n  var constructor = self.getModel();\n  var r = model._thinky.r;\n\n  if (util.isPlainObject(docToSave) === false) {\n    docToSave = {};\n  }\n\n  savedModel[constructor.getTableName()] = true;\n\n\n  var p = new Promise(function(resolve, reject) {\n    // Steps:\n    // - Save belongsTo\n    // - Save this\n    // - Save hasOne, hasMany and hasAndBelongsToMany docs\n    // - Save links\n\n    // We'll use it to know which `belongsTo` docs were saved\n    var belongsToKeysSaved = {};\n\n    var copy = self._makeSavableCopy();\n    self._saveVirtual();\n\n    // Save the joined documents via belongsTo first\n    var promises = [];\n    util.loopKeys(model._joins, function(joins, key) {\n      if ((docToSave.hasOwnProperty(key) || (saveAll === true)) &&\n          (joins[key].type === 'belongsTo') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {\n\n        belongsToKeysSaved[key] = true;\n        if (self[key] != null) {\n          savedModel[joins[key].model.getTableName()] = true;\n          if (saveAll === true) {\n            promises.push(self[key]._save({}, true, savedModel))\n          }\n          else {\n            promises.push(self[key]._save(docToSave[joins[key].model.getTableName()], false, savedModel))\n          }\n        }\n      }\n    });\n\n    //TODO Remove once\n    self.getModel().ready().then(function() {\n      Promise.all(promises).then(function() {\n        self._onSavedBelongsTo(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject);\n      }).error(reject);\n    });\n  });\n  return p;\n}\n\n\n/**\n * Save the joined documents linked with a BelongsTo relation. This should be\n * called before _saveSelf as we will have to copy the foreign keys in `self`.\n * @param {!Object} copy The savable copy of the original documents.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {Object=} belongsToKeysSaved The keys that may contains a document to save\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._onSavedBelongsTo = function(\n    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n  var constructor = self.__proto__.constructor;\n  var r = this._getModel()._thinky.r;\n\n  util.loopKeys(belongsToKeysSaved, function(joins, key) {\n    var joins = model._joins;\n    if (self[key] != null) {\n\n      self.__proto__._belongsTo[key] = true;\n\n      // Copy foreign key\n      if (self[key][joins[key].rightKey] == null) {\n        if (self.hasOwnProperty(joins[key].leftKey)) {\n          delete self[joins[key][joins[key].leftKey]];\n        }\n        if (copy.hasOwnProperty(joins[key].leftKey)) {\n          delete copy[joins[key][joins[key].leftKey]];\n        }\n      }\n      else {\n        self[joins[key].leftKey] = self[key][joins[key].rightKey];\n        copy[joins[key].leftKey] = self[key][joins[key].rightKey]; // We need to put it in copy before saving it\n      }\n\n      // Save the document that belongs to self[key]\n      if (self[key].__proto__._parents._belongsTo[constructor.getTableName()] == null) {\n        self[key].__proto__._parents._belongsTo[constructor.getTableName()] = [];\n      }\n      self[key].__proto__._parents._belongsTo[constructor.getTableName()].push({\n        doc: self,\n        foreignKey: joins[key].leftKey,\n        key: key // foreignDoc\n      });\n    }\n  });\n  self._saveSelf(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject)\n}\n\n\n/**\n * Save the document on which `save` was called.\n * @param {!Object} copy The savable copy of the original documents.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {Object=} belongsToKeysSaved The keys that may contains a document to save\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveSelf = function(\n    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n  var constructor = self.__proto__.constructor;\n  var r = this._getModel()._thinky.r;\n\n  // BelongsTo documents were saved before. We just need to copy the foreign\n  // keys.\n  util.loopKeys(model._joins, function(joins, key) {\n    if ((joins[key].type === 'belongsTo') && (belongsToKeysSaved[key] === true)) {\n      if (self[key] != null) {\n        self[joins[key].leftKey] = self[key][joins[key].rightKey]\n      }\n      else if (self.__proto__._belongsTo[key]) {\n        delete self[joins[key].leftKey];\n        delete copy[joins[key].leftKey];\n      }\n    }\n  });\n\n  var querySaveSelf; // The query to save the document on which `save`/`saveAll` was called.\n  // We haven't validated the document yet, so building the query with `copy`\n  // may throw an error (for example if a Date has not a valid time).\n  var buildQuery = function () {\n    if (self.__proto__._saved === false) {\n      return querySaveSelf = r.table(constructor.getTableName())\n        .insert(copy, {returnChanges: 'always'})\n    }\n    else {\n      if (copy[model._pk] === undefined) {\n        throw new Error(\"The document was previously saved, but its primary key is undefined.\");\n      }\n      return querySaveSelf = r.table(constructor.getTableName())\n        .get(copy[model._pk]).replace(copy, {returnChanges: 'always'})\n    }\n  }\n\n  self.getModel().ready().then(function() {\n    util.tryCatch(function() {\n      // Validate the document before saving it\n      var promise = self.validate();\n      if (promise instanceof Promise) {\n        promise.then(function() {\n          querySaveSelf = buildQuery();\n          querySaveSelf.run().then(function(result) {\n            self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)\n          }).error(reject)\n        }).error(reject);\n      }\n      else {\n        querySaveSelf = buildQuery();\n        querySaveSelf.run().then(function(result) {\n          self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)\n        }).error(reject)\n      }\n    }, reject);\n  });\n}\n\n\n/**\n * Callback for the insert query.\n * @param {Object} result The result from the insert query\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._onSaved = function(result, docToSave, saveAll, savedModel, resolve, reject) {\n  // Keep in sync with Model.save\n  var self = this;\n\n  if (result.first_error != null) {\n    return reject(Errors.create(result.first_error));\n  }\n\n  util.tryCatch(function() { // Validate the doc, replace it, and tag it as saved\n    if (Array.isArray(result.changes) && result.changes.length > 0) {\n      self._merge(result.changes[0].new_val);\n      self._setOldValue(util.deepCopy(result.changes[0].old_val));\n    }\n\n    if (self._getModel().needToGenerateFields === true) {\n      self._generateDefault();\n    }\n    self.setSaved();\n    self.emit('saved', self);\n\n    var promise = self.validate();\n    if (promise instanceof Promise) {\n      promise.then(function() {\n        self._saveMany(docToSave, saveAll, savedModel, resolve, reject)\n      }).error(reject);\n    }\n    else {\n      self._saveMany(docToSave, saveAll, savedModel, resolve, reject)\n    }\n  }, reject);\n}\n\n\n/**\n * Save the joined documents linked with a hasOne or hasMany or\n * hasAndBelongsToMany relation. This should be called after `_saveSelf` as we\n * will have to copy the foreign keys in the joined documents.\n * @param {Object} result The result from the insert query\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveMany = function(docToSave, saveAll, savedModel, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n\n  var promisesMany = [];\n  util.loopKeys(model._joins, function(joins, key) {\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasOne') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {\n      savedModel[joins[key].model.getTableName()] = true;\n\n      if (self[key] != null) {\n        self[key][joins[key].rightKey] = self[joins[key].leftKey];\n        (function(_key) {\n          promisesMany.push(new Promise(function(resolve, reject) {\n            self[_key]._save(docToSave[_key], saveAll, savedModel).then(function() {\n              self.__proto__._hasOne[_key] = {\n                doc: self[_key],\n                foreignKey: self._getModel()._joins[_key].rightKey\n              };\n              if (self[_key].__proto__._parents._hasOne[self._getModel()._name] == null) {\n                self[_key].__proto__._parents._hasOne[self._getModel()._name] = [];\n              }\n              self[_key].__proto__._parents._hasOne[self._getModel()._name].push({\n                doc: self,\n                key: key\n              });\n              resolve();\n            }).error(reject);\n          }))\n        })(key)\n      }\n      else if ((self[key] == null) && (self.__proto__._hasOne[key] != null)) {\n        var doc = self.__proto__._hasOne[key].doc;\n        delete doc[self.__proto__._hasOne[key].foreignKey];\n        promisesMany.push(doc._save(docToSave[key], saveAll, savedModel))\n        self.__proto__._hasOne[key] = null;\n      }\n    }\n  });\n  util.loopKeys(model._joins, function(joins, key) {\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))\n        && (Array.isArray(self[key]))) {\n\n      savedModel[joins[key].model.getTableName()] = true;\n\n      //Go through _hasMany and find element that were removed\n      var pkMap = {};\n      if (Array.isArray(self[key])) {\n        for(var i=0; i<self[key].length; i++) {\n          if (self[key][i][joins[key].model._pk] != null) {\n            pkMap[self[key][i][joins[key].model._pk]] = true;\n          }\n        }\n      }\n\n      if (self.__proto__._hasMany[key] != null) {\n        for(var i=0; i<self.__proto__._hasMany[key].length; i++) {\n          if (pkMap[self.__proto__._hasMany[key][i].doc[[joins[key].model._pk]]] == null) {\n            delete self.__proto__._hasMany[key][i].doc[self.__proto__._hasMany[key][i].foreignKey];\n            promisesMany.push(self.__proto__._hasMany[key][i].doc._save(docToSave[key], saveAll, savedModel));\n          }\n        }\n      }\n      self.__proto__._hasMany[key] = [];\n\n      for(var i=0; i<self[key].length; i++) {\n        self[key][i][joins[key].rightKey] = self[joins[key].leftKey];\n        (function(key, i) {\n          promisesMany.push(new Promise(function(resolve, reject) {\n            if (!(self[key][i] instanceof Document)) {\n              self[key][i] = new joins[key].model(self[key][i]);\n            }\n\n            var callback = function() {\n              self[key][i]._save(docToSave[key], saveAll, savedModel).then(function(doc) {\n                if (!Array.isArray(self.__proto__._hasMany[key])) {\n                  self.__proto__._hasMany[key] = [];\n                }\n                self.__proto__._hasMany[key].push({\n                  doc: doc,\n                  foreignKey: self._getModel()._joins[key].rightKey\n                });\n\n                if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {\n                  self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];\n                }\n                self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({\n                  doc: self,\n                  key: key\n                });\n\n                resolve();\n              }).error(reject);\n            }\n\n            if (self[key][i] instanceof Promise) {\n              self[key][i].then(callback).error(reject);\n            }\n            else {\n              callback();\n            }\n\n          }))\n        })(key, i);\n      }\n    }\n  });\n  util.loopKeys(model._joins, function(joins, key) {\n    // Compare to null\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasAndBelongsToMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {\n\n      savedModel[joins[key].model.getTableName()] = true;\n\n      if (Array.isArray(self[key])) {\n        for(var i=0; i<self[key].length; i++) {\n          if (util.isPlainObject(self[key][i])) { // Save only if we have a full object, and not just a key\n            (function(key, i) {\n              promisesMany.push(new Promise(function(resolve, reject) {\n                if (!(self[key][i] instanceof Document)) {\n                  self[key][i] = new joins[key].model(self[key][i]);\n                }\n                var callback = function() {\n                  self[key][i]._save(docToSave[key], saveAll, savedModel).then(function() {\n                    // self.__proto__._links will be saved in saveLinks\n                    if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {\n                      self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];\n                    }\n                    self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({\n                      doc: self,\n                      key: key\n                    });\n                    resolve();\n                  }).error(reject);\n                }\n\n                if (self[key][i] instanceof Promise) {\n                  self[key][i].then(callback).error(reject);\n                }\n                else {\n                  callback();\n                }\n              }))\n            })(key, i)\n          }\n        }\n      }\n    }\n  });\n\n  if (promisesMany.length > 0) {\n    Promise.all(promisesMany).then(function() {\n      self._saveLinks(docToSave, saveAll, resolve, reject)\n    }).error(reject);\n  }\n  else {\n    self._saveLinks(docToSave, saveAll, resolve, reject)\n  }\n}\n\n\n/**\n * Save the links for hasAndBelongsToMany joined documents.\n * called before _saveSelf as we will have to copy the foreign keys in `self`.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveLinks = function(docToSave, saveAll, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n  var constructor = self.getModel();\n  var r = model._thinky.r;\n\n  var promisesLink = [];\n\n  util.loopKeys(model._joins, function(joins, key) {\n    // Write tests about that!\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasAndBelongsToMany')) {\n\n      if (Array.isArray(self[key])) {\n        var newKeys = {}\n        for(var i=0; i<self[key].length; i++) {\n          if (util.isPlainObject(self[key][i])) {\n            if (self[key][i].isSaved() === true) {\n              newKeys[self[key][i][joins[key].rightKey]] = true;\n            }\n          }\n          else { // self[key][i] is just the key\n            newKeys[self[key][i]] = true;\n          }\n        }\n\n        if (self.__proto__._links[joins[key].link] === undefined) {\n          self.__proto__._links[joins[key].link] = {}\n        }\n        var oldKeys = self.__proto__._links[joins[key].link];\n\n        util.loopKeys(newKeys, function(newKeys, link) {\n          if (oldKeys[link] !== true) {\n            var newLink = {};\n\n            if ((constructor.getTableName() === joins[key].model.getTableName())\n              && (joins[key].leftKey === joins[key].rightKey)) {\n\n              // We link on the same model and same key\n              // We don't want to save redundant field\n              if (link < self[joins[key].leftKey]) {\n                newLink.id = link+\"_\"+self[joins[key].leftKey];\n              }\n              else {\n                newLink.id = self[joins[key].leftKey]+\"_\"+link;\n              }\n              newLink[joins[key].leftKey+\"_\"+joins[key].leftKey] = [link, self[joins[key].leftKey]];\n            }\n            else {\n              newLink[constructor.getTableName()+\"_\"+joins[key].leftKey] = self[joins[key].leftKey];\n              newLink[joins[key].model.getTableName()+\"_\"+joins[key].rightKey] = link;\n\n              // Create the primary key\n              if (constructor.getTableName() < joins[key].model.getTableName()) {\n                newLink.id = self[joins[key].leftKey]+\"_\"+link;\n              }\n              else if (constructor.getTableName() > joins[key].model.getTableName()) {\n                newLink.id = link+\"_\"+self[joins[key].leftKey];\n              }\n              else {\n                if (link < self[joins[key].leftKey]) {\n                  newLink.id = link+\"_\"+self[joins[key].leftKey];\n                }\n                else {\n                  newLink.id = self[joins[key].leftKey]+\"_\"+link;\n                }\n              }\n            }\n\n            (function(key, link) {\n              promisesLink.push(new Promise(function(resolve, reject) {\n                r.table(self._getModel()._joins[key].link).insert(newLink, {conflict: \"replace\", returnChanges: 'always'}).run().then(function(result) {\n                  if (Array.isArray(result.changes) && result.changes.length > 0) {\n                    self.__proto__._links[joins[key].link][result.changes[0].new_val[joins[key].model.getTableName()+\"_\"+joins[key].rightKey]] = true;\n                  }\n                  else {\n                    self.__proto__._links[joins[key].link][newLink[joins[key].model.getTableName()+\"_\"+joins[key].rightKey]] = true;\n                  }\n                  resolve();\n                }).error(reject);\n              }))\n            })(key, link);\n          }\n        });\n\n        var keysToDelete = []\n        util.loopKeys(oldKeys, function(oldKeys, link) {\n          if (newKeys[link] === undefined) {\n            if (constructor.getTableName() < joins[key].model.getTableName()) {\n              keysToDelete.push(self[joins[key].leftKey]+\"_\"+link);\n            }\n            else {\n              keysToDelete.push(link+\"_\"+self[joins[key].leftKey]);\n            }\n          }\n        });\n        if (keysToDelete.length > 0) {\n          var table = r.table(joins[key].link);\n          promisesLink.push(table.getAll.apply(table, keysToDelete).delete().run().then(function() {\n            for(var i=0; i<keysToDelete.length; i++) {\n              self.__proto__._links[joins[key].link][keysToDelete[i]] = false;\n            }\n          }));\n        }\n      }\n    }\n  });\n\n  if (promisesLink.length > 0) {\n    Promise.all(promisesLink).then(function() {\n      resolve(self);\n    }).error(reject);\n  }\n  else {\n    resolve(self);\n  }\n}\n\n\n/**\n * Return the value saved in __proto__.oldValue\n */\nDocument.prototype.getOldValue = function() {\n  return this.__proto__.oldValue;\n}\n\n\n/**\n * Save a reference of `value` that will be later accessible with `getOldValue`.\n * @param {Object} value The value to save\n */\nDocument.prototype._setOldValue = function(value) {\n  return this.__proto__.oldValue = value;\n}\n\n\n/**\n * Return whether this document was saved or not.\n * @return {boolean}\n */\nDocument.prototype.isSaved = function() {\n  return this.__proto__._saved;\n}\n\n\n/**\n * Set the document (and maybe its joined documents) as saved.\n * @param {boolean=} all Recursively set all the joined documents as saved\n */\nDocument.prototype.setSaved = function(all) {\n  var self = this;\n  self.__proto__._saved = true;\n  if (all !== true) return;\n    util.loopKeys(self._getModel()._joins, function(joins, key) {\n      switch (joins[key].type) {\n        case 'hasOne':\n          if (self[key] instanceof Document) {\n            self[key].setSaved(true);\n          }\n          break;\n\n        case 'belongsTo':\n          if (self[key] instanceof Document) {\n            self[key].setSaved(true);\n          }\n          break;\n\n        case 'hasMany':\n          if (Array.isArray(self[key])) {\n            for(var i=0; i<self[key].length; i++) {\n              if (self[key][i] instanceof Document) {\n                self[key][i].setSaved(true);\n              }\n            }\n          }\n          break;\n\n        case 'hasAndBelongsToMany':\n          if (Array.isArray(self[key])) {\n            for(var i=0; i<self[key].length; i++) {\n              if (self[key][i] instanceof Document) {\n                self[key][i].setSaved(true);\n              }\n            }\n          }\n          break;\n      }\n    });\n\n    // Make joins, we should keep references only of the saved documents\n    util.loopKeys(self._getModel()._joins, function(joins, key) {\n      if (self[key] == null) return;\n      switch (joins[key].type) {\n        case 'hasOne':\n          if (self[key].isSaved()) {\n            self.__proto__._hasOne[key] = {\n              doc: self[key],\n              foreignKey: self._getModel()._joins[key].rightKey\n            }\n          }\n\n          if (self[key].__proto__._parents._hasOne[self._getModel()._name] == null) {\n            self[key].__proto__._parents._hasOne[self._getModel()._name] = [];\n          }\n          self[key].__proto__._parents._hasOne[self._getModel()._name].push({\n            doc: self,\n            key: key\n          });\n          break;\n\n        case 'belongsTo':\n          if (self[key].__proto__._parents._belongsTo[self._getModel()._name] == null) {\n            self[key].__proto__._parents._belongsTo[self._getModel()._name] = [];\n          }\n          self[key].__proto__._parents._belongsTo[self._getModel()._name].push({\n            doc: self,\n            foreignKey: self._getModel()._joins[key].leftKey,\n            key: key\n          });\n          self.__proto__._belongsTo[key] = true;\n          break;\n\n        case 'hasMany':\n          self.__proto__._hasMany[key] = []\n\n          for(var i=0; i<self[key].length; i++) {\n            if (self[key][i].isSaved()) {\n              self.__proto__._hasMany[key].push({\n                doc: self[key][i],\n                foreignKey: self._getModel()._joins[key].rightKey\n              })\n            }\n\n            if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {\n              self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];\n            }\n            self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({\n              doc: self,\n              key: key\n            });\n\n          }\n          break;\n\n        case 'hasAndBelongsToMany':\n          if (self.__proto__._links[self._getModel()._joins[key].link] === undefined) {\n            self.__proto__._links[self._getModel()._joins[key].link] = {}\n          }\n\n          for(var i=0; i<self[key].length; i++) {\n            if (self[key][i].isSaved()) {\n              self.__proto__._links[self._getModel()._joins[key].link][self[key][i][self._getModel()._joins[key].rightKey]] = true;\n            }\n\n            if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {\n              self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];\n            }\n            self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({\n              doc: self,\n              key: key\n            });\n\n          }\n          break;\n      }\n    });\n\n}\n\n\n/**\n * Set the document as unsaved\n */\nDocument.prototype._setUnSaved = function() {\n  this.__proto__._saved = false;\n}\n\n\n/**\n * Delete the document from the database. Update the joined documents by\n * removing the foreign key for hasOne/hasMany joined documents, and remove the\n * links for hasAndBelongsToMany joined documents if the link is built on the\n * primary key.\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype.delete = function(callback) {\n  return this._delete({}, false, [], true, true, callback)\n}\n\n\n/**\n * Delete the document from the database and the joined documents. If\n * `docToDelete` is undefined, it will delete all the joined documents, else it\n * will limits itself to the one stored in the keys defined in `docToDelete`.\n * It will also update the joined documents by removing the foreign key for\n * `hasOne`/`hasMany` joined documents, and remove the links for\n * `hasAndBelongsToMany` joined documents if the link is built on the primary\n * key.\n * @param {Object=} docToDelete An object where a field maps to `true` if the\n * document stored in this field should be deleted.\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype.deleteAll = function(docToDelete, callback) {\n  var deleteAll;\n  if (typeof docToDelete === 'function') {\n    callback = docToDelete;\n    deleteAll = true;\n    docToDelete = {};\n  }\n  else {\n    deleteAll = docToDelete === undefined;\n    docToDelete = docToDelete || {};\n  }\n  return this._delete(docToDelete, deleteAll, [], true, true, callback)\n}\n\n\n/**\n * Delete the document from the database and the joined documents. If\n * `docToDelete` is `undefined` and `deleteAll` is `true`, it will delete all\n * the joined documents, else it will limits itself to the one stored in the\n * keys defined in `docToDelete`. It will also update the joined documents by\n * removing the foreign key for `hasOne`/`hasMany` joined documents, and\n * remove the links for `hasAndBelongsToMany` joined documents if the link is\n * built on the primary key.\n * Hooks will also be executed.\n * @param {Object=} docToDelete Explicit maps of the documents to delete\n * @param {boolean} deleteAll Recursively delete all the documents if\n *     `docToDelete` is undefined\n * @param {Array} deletedDocs Array of docs already deleted, used to make sure\n *     that we do not try to delete multiple times the same documents\n * @param {boolean} deleteSelf Whether it should delete self\n * @param {boolean} updateParents Whether it should update the keys for the\n *     parents\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype._delete = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {\n  //TODO Set a (string) id per document and use it to perform faster lookup\n  var self = this;\n\n  if (util.isPlainObject(docToDelete) === false) {\n    docToDelete = {};\n  }\n\n  deleteSelf = (deleteSelf === undefined) ? true: deleteSelf;\n\n  return util.hook({\n    preHooks: self._getModel()._pre.delete,\n    postHooks: self._getModel()._post.delete,\n    doc: self,\n    async: true,\n    fn: self._deleteHook,\n    fnArgs: [docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback]\n  });\n}\n\n\n/**\n * Internal methods used in `_delete`. Does the same as `_delete` but without\n * the hooks.\n * @param {Object=} docToDelete Explicit maps of the documents to delete\n * @param {boolean} deleteAll Recursively delete all the documents if\n *     `docToDelete` is undefined\n * @param {Array} deletedDocs Array of docs already deleted, used to make sure\n *     that we do not try to delete multiple times the same documents\n * @param {boolean} deleteSelf Whether it should delete self\n * @param {boolean} updateParents Whether it should update the keys for the\n *     parents\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype._deleteHook = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {\n  var self = this;\n  var model = self._getModel(); // instance of Model\n  var constructor = self.getModel();\n  var r = model._thinky.r;\n\n  var promises = [];\n\n  deletedDocs.push(self);\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    if ((joins[key].type === 'hasOne') && (self[key] instanceof Document)) {\n      if ((self[key].isSaved() === true) &&\n        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {\n\n        (function(key) {\n          promises.push(new Promise(function(resolve, reject) {\n            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {\n              delete self[key];\n              resolve();\n            }).error(reject);\n          }))\n        })(key);\n      }\n      else if ((deleteSelf === true) && (deletedDocs.indexOf(self[key]) === -1)) {\n        delete self[key][joins[key].rightKey];\n        if (self[key].isSaved() === true) {\n          promises.push(self[key].save({}, false, {}, true, false));\n        }\n      }\n    }\n    if ((joins[key].type === 'belongsTo') && (self[key] instanceof Document)) {\n      if ((self[key].isSaved() === true) &&\n        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {\n\n        (function(key) {\n          promises.push(new Promise(function(resolve, reject) {\n            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {\n              delete self[key];\n              resolve();\n            }).error(reject);\n          }));\n        })(key);\n      }\n    }\n\n    if ((joins[key].type === 'hasMany') && (Array.isArray(self[key]))) {\n      var manyPromises = [];\n      for(var i=0; i<self[key].length; i++) {\n        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))\n          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {\n\n          manyPromises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))\n        }\n        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {\n          delete self[key][i][joins[key].rightKey];\n          if (self[key][i].isSaved() === true) {\n            promises.push(self[key][i].save({}, false, {}, true, false))\n          }\n        }\n      }\n      (function(key) {\n        promises.push(new Promise(function(resolve, reject) {\n          Promise.all(manyPromises).then(function() {\n            delete self[key];\n            resolve()\n          })\n        }));\n      })(key)\n    }\n    if ((joins[key].type === 'hasAndBelongsToMany') && (Array.isArray(self[key]))) {\n      // Delete links + docs\n      var pks = []; // primary keys of the documents\n      var linksPks = []; // primary keys of the links\n\n      // Store the element we are going to delete.\n      // If the user force the deletion of the same element multiple times, we can't naively loop\n      // over the elements in the array...\n      var docsToDelete = [];\n\n\n      for(var i=0; i<self[key].length; i++) {\n        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))\n          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {\n\n          //pks.push(self[key][i][joins[key].model._getModel()._pk]);\n          docsToDelete.push(self[key][i]);\n          // We are going to do a range delete, but we still have to recurse\n          promises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))\n\n          if (self.getModel()._getModel()._pk === joins[key].leftKey) {\n            // The table is created since we are deleting an element from it\n            if (self._getModel()._name === joins[key].model._getModel()._name) {\n              if (self[joins[key].leftKey] < self[key][i][joins[key].rightKey]) {\n                //TODO Add test for this\n                linksPks.push(self[joins[key].leftKey]+\"_\"+self[key][i][joins[key].rightKey]);\n              }\n              else {\n                linksPks.push(self[key][i][joins[key].rightKey]+\"_\"+self[joins[key].leftKey]);\n              }\n            }\n            else if (self._getModel()._name < joins[key].model._getModel()._name) {\n              linksPks.push(self[joins[key].leftKey]+\"_\"+self[key][i][joins[key].rightKey]);\n            }\n            else {\n              linksPks.push(self[key][i][joins[key].rightKey]+\"_\"+self[joins[key].leftKey]);\n            }\n          }\n        }\n        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {\n          // It's safe to destroy links only if it's a primary key\n          if (self.getModel()._getModel()._pk === joins[key].leftKey) {\n            if (self._getModel()._name < joins[key].model._getModel()._name) {\n              linksPks.push(self[joins[key].leftKey]+\"_\"+self[key][i][joins[key].rightKey]);\n            }\n            else {\n              linksPks.push(self[key][i][joins[key].rightKey]+\"_\"+self[joins[key].leftKey]);\n            }\n          }\n        }\n      }\n      if (linksPks.length > 0) {\n        var query = r.table(joins[key].link);\n        query = query.getAll.apply(query, linksPks).delete();\n        promises.push(query.run());\n      }\n    }\n  });\n  if (updateParents !== false) {\n    // Clean links that we are aware of\n    util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {\n      var parents = hasOne[key];\n      for(var i=0; i<parents.length; i++) {\n        delete parents[i].doc[parents[i].key];\n        util.loopKeys(parents[i].doc.__proto__._hasOne, function(joined, joinKey) {\n          if (joined[joinKey].doc === self) {\n            delete parents[i].doc.__proto__._hasOne[joinKey];\n          }\n        })\n      }\n    });\n    util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {\n      var parents = belongsTo[key];\n      for(var i=0; i<parents.length; i++) {\n        delete parents[i].doc[parents[i].key];\n        delete parents[i].doc[parents[i].foreignKey];\n        if (deletedDocs.indexOf(parents[i]) === -1) {\n          promises.push(parents[i].doc.save());\n        }\n      }\n    });\n    util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {\n      var parents = hasMany[key];\n      for(var i=0; i<parents.length; i++) {\n        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {\n          if (parents[i].doc[parents[i].key][j] === self) {\n            util.loopKeys(parents[i].doc.__proto__._hasMany, function(joined, joinKey) {\n              for(var k=0; k<joined[joinKey].length; k++) {\n                if (joined[joinKey][k].doc === self) {\n                  joined[joinKey].splice(k, 1);\n                  return false;\n                }\n              }\n            });\n            parents[i].doc[parents[i].key].splice(j, 1);\n            break;\n          }\n        }\n      }\n    });\n    util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {\n      var parents = belongsLinks[key];\n      for(var i=0; i<parents.length; i++) {\n        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {\n          if (parents[i].doc[parents[i].key][j] === self) {\n            parents[i].doc[parents[i].key].splice(j, 1);\n            break;\n          }\n        }\n      }\n    });\n  }\n\n  if (deleteSelf !== false) {\n    if (self.isSaved() === true) {\n      promises.push(new Promise(function(resolve, reject) {\n        r.table(model._name).get(self[model._pk]).delete().run().then(function(result) {\n          self._setUnSaved();\n          self.emit('deleted', self);\n          resolve(self);\n        }).error(reject);\n      }))\n    }\n    // else we don't throw an error, should we?\n  }\n\n  var p = new Promise(function(resolve, reject) {\n    Promise.all(promises).then(function(result) {\n      resolve(self);\n    }).error(function(error) {\n      reject(error)\n    });\n  })\n  return p.nodeify(callback);\n}\n\n/*\n * Delete this document and purge the database by doing range update to clean\n * the foreign keys.\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype.purge = function(callback) {\n  var self = this;\n\n  var model = self._getModel(); // instance of Model\n  var r = model._thinky.r;\n\n  // Clean parent for hasOne\n  // doc.otherDoc.delete()\n  util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {\n    for(var i=0; i<hasOne[key].length; i++) {\n      var parentDoc = hasOne[key][i].doc; // A doc that belongs to otherDoc (aka this)\n      delete parentDoc[hasOne[key][i].key] // Delete reference to otherDoc (aka this)\n    }\n  });\n\n  // Clean parent for belongsTo\n  // doc.otherDoc.delete()\n  util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {\n    for(var i=0; i<belongsTo[key].length; i++) {\n      var parentDoc = belongsTo[key][i].doc;\n      delete parentDoc[belongsTo[key][i].key];\n      delete parentDoc[belongsTo[key][i].foreignKey];\n    }\n  });\n\n  // Clean parent for hasMany\n  util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {\n    for(var i=0; i<hasMany[key].length; i++) {\n      var parentDoc = hasMany[key][i].doc;\n      var field = hasMany[key][i].key;\n      for(var j=0; j<parentDoc[field].length; j++) {\n        if (parentDoc[field][j] === this) {\n          parentDoc[field].splice(j, 1);\n          break;\n        }\n      }\n    }\n  });\n\n\n  // Clean parent for hasAndBelongsToMany\n  util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {\n    for(var i=0; i<belongsLinks[key].length; i++) {\n      var parentDoc = belongsLinks[key][i].doc;\n      var field = belongsLinks[key][i].key;\n      for(var j=0; j<parentDoc[field].length; j++) {\n        if (parentDoc[field][j] === this) {\n          parentDoc[field].splice(j, 1);\n          break;\n        }\n      }\n    }\n  });\n\n  // Purge the database\n  var promises = [];\n  util.loopKeys(self._getModel()._joins, function(joins, field) {\n    var join = joins[field];\n    var joinedModel = join.model;\n\n    if ((join.type === 'hasOne') || (join.type === 'hasMany')) {\n      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.leftKey], {index: join.rightKey}).replace(function(doc) {\n        return doc.without(join.rightKey)\n      }).run())\n    }\n    // nothing to do for \"belongsTo\"\n    else if (join.type === 'hasAndBelongsToMany') {\n      if (self.getModel()._getModel()._pk === join.leftKey) {\n        // [1]\n        promises.push(r.table(join.link).getAll(self[join.leftKey], {index: self.getModel().getTableName()+\"_\"+join.leftKey}).delete().run())\n      }\n    }\n  });\n\n  util.loopKeys(self._getModel()._reverseJoins, function(reverseJoins, field) {\n    var join = reverseJoins[field];\n    var joinedModel = join.model; // model where belongsTo/hasAndBelongsToMany was called\n\n    if (join.type === 'belongsTo') {\n      // What was called is joinedModel.belongsTo(self, fieldDoc, leftKey, rightKey)\n      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.rightKey], {index: join.leftKey}).replace(function(doc) {\n        return doc.without(join.leftKey)\n      }).run())\n    }\n    // nothing to do for \"belongsTo\"\n    else if (join.type === 'hasAndBelongsToMany') {\n      // Purge only if the key is a primary key\n      // What was called is joinedModel.hasAndBelongsToMany(self, fieldDoc, leftKey, rightKey)\n      if (self.getModel()._getModel()._pk === join.leftKey) {\n        promises.push(r.table(join.link).getAll(self[join.rightKey], {index: self.getModel().getTableName()+\"_\"+join.rightKey}).delete().run())\n      }\n    }\n  });\n\n  // Delete itself\n  promises.push(self.delete())\n\n  return new Promise(function(resolve, reject) {\n    Promise.all(promises).then(function() {\n      resolve(self);\n    }).error(reject);\n  }).nodeify(callback);\n}\n\nDocument.prototype.addRelation = function() {\n  var self = this;\n  var pk = self._getModel()._pk;\n\n  var query = self.getModel().get(this[pk])\n  return query.addRelation.apply(query, arguments);\n}\n\nDocument.prototype.removeRelation = function() {\n  var self = this;\n  var pk = self._getModel()._pk;\n\n  var query = self.getModel().get(this[pk])\n  return query.removeRelation.apply(query, arguments);\n}\n\n/**\n * Perform a `merge` of `obj` in this document. Extra keys will be removed.\n */\nDocument.prototype._merge = function(obj) {\n  var self = this;\n  util.loopKeys(self, function(self, key) {\n    if ((obj[key] === undefined) && (self._getModel()._joins[key] === undefined)) {\n      delete self[key];\n    }\n  });\n  util.loopKeys(obj, function(obj, key) {\n    self[key] = obj[key];\n  });\n  return self;\n}\n\n\n/**\n * Perform a `merge` of `obj` in this document. Extra keys will not be removed.\n */\nDocument.prototype.merge = function(obj) {\n  var self = this;\n  util.loopKeys(obj, function(obj, key) {\n    // Recursively merge only if both fields are objects, else we'll overwrite the field\n    if (util.isPlainObject(obj[key]) && util.isPlainObject(self[key])) {\n      Document.prototype.merge.call(self[key], obj[key])\n    }\n    else {\n      self[key] = obj[key];\n    }\n  });\n  return self;\n}\n\n/**\n * Set the atom feed and update the document for each change\n */\nDocument.prototype._setFeed = function(feed) {\n  var self = this;\n\n  self.__proto__._feed = feed;\n  self.__proto__._active = true;\n  feed.each(function(err, change) {\n    if (err) {\n      self.__proto__._active = false;\n      self.emit('error', err);\n    }\n    else {\n      if (change.new_val === null) {\n        // Delete all the fields\n        self._merge({});\n        self._setOldValue(change.old_val);\n        self._setUnSaved();\n        self.emit('change', self);\n      }\n      else {\n        self._merge(change.new_val);\n        self._setOldValue(change.old_val);\n        self.setSaved();\n        self.emit('change', self);\n      }\n    }\n\n  });\n};\n\nDocument.prototype.getFeed = function() {\n  return this.__proto__._feed;\n}\n\nDocument.prototype.closeFeed = function() {\n  return this.__proto__._feed.close();\n}\n\n/**\n * Have the model emit 'retrieved' with the current document and\n * recurse to have all joined models do the same.\n */\nDocument.prototype._emitRetrieve = function() {\n  var self = this;\n  self.getModel().emit('retrieved', self);\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    var join = joins[key];\n    if ((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo')) {\n      if ((self[key] != null) && (typeof self[key]._emitRetrieve === 'function')) {\n        self[key]._emitRetrieve();\n      }\n    }\n    else if ((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany')) {\n      if (Array.isArray(self[key])) {\n        for(var i=0; i<self[key].length; i++) {\n          if (typeof self[key][i]._emitRetrieve === 'function') {\n            self[key][i]._emitRetrieve();\n          }\n        }\n      }\n    }\n  })\n}\n\nmodule.exports = Document;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/document.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/thinky/lib/errors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar errors = module.exports = {};\n\n/**\n * The base error that all thinky related errors derive from\n *\n * @constructor\n * @alias Error\n */\nerrors.ThinkyError = function() {\n  var tmp = Error.apply(this, arguments);\n  tmp.name = this.name = 'ThinkyError';\n\n  this.message = tmp.message;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, this.constructor);\n};\nutil.inherits(errors.ThinkyError, Error);\n\n/**\n * Thrown or returned when `get` returns `null`.\n * @extends ThinkyError\n */\nerrors.DocumentNotFound = function(message) {\n  var errorMessage = message || \"The query did not find a document and returned null.\";\n  errors.ThinkyError.call(this, errorMessage);\n  this.name = 'DocumentNotFoundError';\n};\nutil.inherits(errors.DocumentNotFound, errors.ThinkyError);\n\n/**\n * Thrown or returned when an in place update/replace returns an invalid document.\n * @extends ThinkyError\n */\nerrors.InvalidWrite = function(message, raw) {\n  errors.ThinkyError.call(this, message);\n  this.name = 'InvalidWriteError';\n  this.raw = raw;\n};\nutil.inherits(errors.InvalidWrite, errors.ThinkyError);\n\n/**\n * Thrown or returned when validation of a document fails.\n * @extends ThinkyError\n */\nerrors.ValidationError = function(message) {\n  errors.ThinkyError.call(this, message);\n  this.name = 'ValidationError';\n};\nutil.inherits(errors.ValidationError, errors.ThinkyError);\n\n/**\n * Thrown or returned when the primary key unique document constraint fails.\n * @extends ThinkyError\n */\nerrors.DuplicatePrimaryKey = function(message, primaryKey) {\n  errors.ThinkyError.call(this, message);\n  this.name = 'DuplicatePrimaryKeyError';\n  if (primaryKey !== undefined) {\n    this.primaryKey = primaryKey;\n  }\n};\nutil.inherits(errors.DuplicatePrimaryKey, errors.ThinkyError);\n\n/**\n * regular expressions used to determine which errors should be thrown\n */\nerrors.DOCUMENT_NOT_FOUND_REGEX = new RegExp('^The query did not find a document and returned null.*');\nerrors.DUPLICATE_PRIMARY_KEY_REGEX = new RegExp('^Duplicate primary key `(.*)`.*');\n\n/**\n * Creates an appropriate error given either an instance of Error or a message\n * from the RethinkDB driver\n */\nerrors.create = function(errorOrMessage) {\n  var message = (errorOrMessage instanceof Error) ? errorOrMessage.message : errorOrMessage;\n  if (message.match(errors.DOCUMENT_NOT_FOUND_REGEX)) {\n    return new errors.DocumentNotFound(message);\n  } else if (message.match(errors.DUPLICATE_PRIMARY_KEY_REGEX)) {\n    var primaryKey = message.match(errors.DUPLICATE_PRIMARY_KEY_REGEX)[1];\n    return new errors.DuplicatePrimaryKey(message, primaryKey);\n  } else if (errorOrMessage instanceof Error) {\n    return errorOrMessage;\n  }\n\n  return new errors.ThinkyError(errorOrMessage);\n};\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/errors.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/feed.js":
/*!*****************************************!*\
  !*** ./node_modules/thinky/lib/feed.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/main/bluebird.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar util = __webpack_require__(/*! ./node_modules/thinky/lib/util.js */ \"./node_modules/thinky/lib/util.js\");\n\nfunction Feed(feed, model) {\n  this.feed = feed;\n  this.model = model;\n  this._closed = false;\n\n  this.each = this._each;\n  this.next = this._next;\n}\n\nFeed.prototype.toString = function() {\n  return '[object Feed]'\n}\n\n\nFeed.prototype._next = function() {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    self.feed.next().then(function(data) {\n      util.tryCatch(function() {\n        if (data.new_val != null) {\n          self.model._parse(data.new_val).then(function(doc) {\n            doc._setOldValue(data.old_val);\n            resolve(doc);\n          }).error(reject);\n        }\n        else if (data.old_val != null) { // new_val is null\n          self.model._parse(data.old_val).then(function(doc) {\n            doc._setUnSaved();\n            resolve(doc);\n          }).error(reject);\n        }\n        //else we just drop the change as it's a state/initializing object\n      }, function(err) {\n        reject(err);\n      })\n    }).error(reject);\n  });\n}\n\nFeed.prototype.toArray = function() {\n  throw new Error(\"The `toArray` method is not available on feeds.\");\n}\n\nFeed.prototype.close = function(callback) {\n  this._closed = true;\n  return this.feed.close(callback);\n}\n\nFeed.prototype._each = function(callback, onFinish) {\n  var self = this;\n  self.feed.each(function(err, data) {\n    if (err) {\n      if (self._closed === true) {\n        return;\n      }\n      return callback(err);\n    }\n    util.tryCatch(function() {\n      if (data.new_val != null) {\n        self.model._parse(data.new_val).then(function(doc) {\n          doc._setOldValue(data.old_val);\n          callback(null, doc);\n        }).error(function(err) {\n          callback(err);\n        });\n      }\n      else if (data.old_val != null) { // new_val is null\n        self.model._parse(data.old_val).then(function(doc) {\n          doc._setUnSaved();\n          callback(null, doc);\n        }).error(function(err) {\n          callback(err);\n        });\n      }\n      //else we just drop the change as it's a state/initializing object\n    }, function(err) {\n      callback(err);\n    })\n  }, onFinish);\n};\n\nFeed.prototype._makeEmitter = function() {\n  this.next = function() {\n    throw new Error(\"You cannot called `next` once you have bound listeners on the feed\")\n  }\n  this.each = function() {\n    throw new Error(\"You cannot called `each` once you have bound listeners on the feed\")\n  }\n  this.toArray = function() {\n    throw new Error(\"You cannot called `toArray` once you have bound listeners on the feed\")\n  }\n  this._eventEmitter = new EventEmitter();\n}\n\nFeed.prototype._eachCb = function(err, data) {\n  var self = this;\n  if (err != null) {\n    if ((this._closed !== false) || (err.message !== \"You cannot retrieve data from a cursor that is closed\")) {\n      self._eventEmitter.emit('error', err);\n    }\n    return;\n  }\n\n  util.tryCatch(function() {\n    if (data.new_val !== null) {\n      self.model._parse(data.new_val).then(function(doc) {\n        doc._setOldValue(data.old_val);\n        self._eventEmitter.emit('data', doc);\n      }).error(function(err) {\n        self._eventEmitter.emit('error', err);\n      });\n    }\n    else if (data.old_val !== null) { // new_val is null\n      self.model._parse(data.old_val).then(function(doc) {\n        doc._setUnSaved();\n        self._eventEmitter.emit('data', doc);\n      }).error(function(err) {\n        self._eventEmitter.emit('error', err);\n      });\n    }\n  }, function(err) {\n    self._eventEmitter.emit('error', err);\n  })\n}\n\nvar methods = [\n    'addListener',\n    'on',\n    'once',\n    'removeListener',\n    'removeAllListeners',\n    'setMaxListeners',\n    'listeners',\n    'emit'\n];\n\nfor(var i=0; i<methods.length; i++) {\n  (function(n) {\n    var method = methods[n];\n    Feed.prototype[method] = function() {\n      var self = this;\n      if (self._eventEmitter == null) {\n        self._makeEmitter();\n        setImmediate(function() {\n          self.feed._each(self._eachCb.bind(self), function() {\n            self._eventEmitter.emit('end');\n          });\n        });\n      }\n      self._eventEmitter[method].apply(self._eventEmitter, util.toArray(arguments));\n    };\n  })(i);\n}\n\nmodule.exports = Feed;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/feed.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/model.js":
/*!******************************************!*\
  !*** ./node_modules/thinky/lib/model.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/util.js */ \"./node_modules/thinky/lib/util.js\");\nvar _util = __webpack_require__(/*! util */ \"util\");\nvar schemaUtil = __webpack_require__(/*! ./node_modules/thinky/lib/schema.js */ \"./node_modules/thinky/lib/schema.js\");\nvar Document = __webpack_require__(/*! ./node_modules/thinky/lib/document.js */ \"./node_modules/thinky/lib/document.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Query = __webpack_require__(/*! ./node_modules/thinky/lib/query.js */ \"./node_modules/thinky/lib/query.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/main/bluebird.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\n/*\n * Constructor for a Model. Note that this is not what `thinky.createModel`\n * returns. It is the prototype of what `thinky.createModel` returns.\n * The whole chain being:\n * document.__proto__ = new Document(...)\n * document.__proto__.constructor = model (returned by thinky.createModel\n * document.__proto__._model = instance of Model\n * document.__proto__.constructor.__proto__ = document.__proto__._model\n */\nfunction Model(name, schema, options, thinky) {\n  /**\n   * Name of the table used\n   * @type {string}\n   */\n  this._name = name;\n\n  // We want a deep copy\n  options = options || {};\n  this._options = {};\n  this._options.enforce_missing = (options.enforce_missing != null) ? options.enforce_missing : thinky._options.enforce_missing;\n  this._options.enforce_extra = (options.enforce_extra != null) ? options.enforce_extra : thinky._options.enforce_extra;\n  this._options.enforce_type = (options.enforce_type != null) ? options.enforce_type : thinky._options.enforce_type;\n  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : thinky._options.timeFormat;\n  this._options.validate = (options.validate != null) ? options.validate : thinky._options.validate;\n\n  this._schema = schemaUtil.parse(schema, '', this._options, this);\n  //console.log(JSON.stringify(this._schema, null, 2));\n\n  this.virtualFields = [];\n  this.defaultFields = [];\n  this._schema._getDefaultFields([], this.defaultFields, this.virtualFields)\n\n  this.needToGenerateFields = (this.defaultFields.length+this.virtualFields.length) !== 0;\n\n  this._pk = (options.pk != null) ? options.pk : 'id';\n\n  this._table = (options.table != null) ? options.table : {};\n  this._table.primaryKey = this._pk;\n\n  this._thinky = thinky;\n\n  this._validator = options.validator;\n\n  this._indexes = {}; // indexName -> true\n  this._pendingPromises = [];\n\n  this._error = null; // If an error occured, we won't let people save things\n\n  this._listeners = {};\n  this._maxListeners = 10;\n  this._joins = {};\n  this._localKeys = {}; // key used as a foreign key by another model\n\n  // This is to track joins that were not directly called by this model but that we still need\n  // to purge the database\n  this._reverseJoins = {};\n\n  this._methods = {};\n  this._staticMethods = {};\n  this._async = {\n    init: false,\n    retrieve: false,\n    save: false,\n    validate: false\n  };\n\n  this._pre = {\n    save: [],\n    delete: [],\n    validate: []\n  };\n  this._post = {\n    init: [],\n    retrieve: [],\n    save: [],\n    delete: [],\n    validate: []\n  };\n}\n_util.inherits(Model, EventEmitter);\n\nModel.new = function(name, schema, options, thinky) {\n\n  var proto = new Model(name, schema, options, thinky);\n  proto._initModel = options.init  !== undefined ? !!options.init : true;\n\n  var model = function model(doc, options) {\n    if (!util.isPlainObject(doc)) {\n      throw new Error(\"Cannot build a new instance of `\"+proto._name+\"` without an object\")\n    }\n    // We create a deepcopy only if doc was already used to create a document\n    if (doc instanceof Document) {\n      doc = util.deepCopy(doc);\n    }\n\n    util.changeProto(doc, new Document(model, options));\n\n    // Create joins document. We do it here because `options` are easily available\n    util.loopKeys(proto._joins, function(joins, key) {\n      if (doc[key] != null) {\n        if ((joins[key].type === 'hasOne') && (doc[key] instanceof Document === false)) {\n          doc[key] = new joins[key].model(doc[key], options);\n        }\n        else if ((joins[key].type === 'belongsTo') && (doc[key] instanceof Document === false)) {\n          doc[key] = new joins[key].model(doc[key], options);\n        }\n        else if (joins[key].type === 'hasMany') {\n          doc.__proto__._hasMany[key] = []\n\n          for(var i=0; i<doc[key].length; i++) {\n            if (doc[key][i] instanceof Document === false) {\n              doc[key][i] = new joins[key].model(doc[key][i], options);\n            }\n          }\n        }\n        else if (joins[key].type === 'hasAndBelongsToMany') {\n          for(var i=0; i<doc[key].length; i++) {\n            if (doc[key][i] instanceof Document === false) {\n              doc[key][i] = new joins[key].model(doc[key][i], options);\n            }\n          }\n        }\n      }\n    });\n    doc._getModel()._schema._setModel(doc._getModel());\n    if (proto.needToGenerateFields === true) {\n      doc._generateDefault();\n    }\n\n    var promises = [];\n    var promise;\n    if (proto._options.validate === 'oncreate') {\n      promise = doc.validate(options);\n      if (promise instanceof Promise) promises.push(promise);\n    }\n\n    if (proto._post.init.length > 0) {\n      promise = util.hook({\n        postHooks: doc._getModel()._post.init,\n        doc: doc,\n        async: doc._getModel()._async.init,\n        fn: function() {\n          return doc;\n        }\n      })\n      if (promise instanceof Promise) promises.push(promise);\n    }\n\n    if (promises.length > 0) {\n      return Promise.all(promises).then(function(docs) {\n        return docs[0];\n      });\n    }\n    return doc;\n  }\n\n  model.__proto__ = proto;\n\n  if (options.init !== false) {\n    // Setup the model's table.\n    model.tableReady().then();\n  }\n  else {\n    // We do not initialize the table and suppose that it already exists and\n    // is ready.\n    model.emit('created');\n    model.emit('ready');\n  }\n\n  // So people can directly call the EventEmitter from the constructor\n  // TOIMPROVE: We should emit everything from the constructor instead of emitting things from\n  // the constructor and the instance of Model\n  util.loopKeys(EventEmitter.prototype, function(emitter, key) {\n    (function(_key) {\n      model[_key] = function() {\n        model._getModel()[_key].apply(model._getModel(), arguments);\n      }\n    })(key)\n  });\n\n\n  return model\n}\n\n/**\n * Create the model's table.\n * @return {Promise=} Returns a promise which will resolve when the table is ready.\n */\nModel.prototype.tableReady = function() {\n  var self = this;\n  var model = this._getModel();\n  if (!this._initModel) return Promise.resolve();\n  if (this._tableReadyPromise) return this._tableReadyPromise;\n\n  // Create the table, or push the table name in the queue.\n  var r = model._thinky.r;\n  this._tableReadyPromise = model._thinky.dbReady()\n  .then(function() {\n    return r.tableCreate(model._name, model._table).run();\n  })\n  .error(function(error) {\n    if (error.message.match(/Table `.*` already exists/)) {\n      return;\n    }\n    model._error = error;\n    // Should we throw here?\n  });\n\n  return this._tableReadyPromise.then(function() {\n    self.emit('created');\n    if (!self._pendingPromises.length) {\n      self.emit('ready');\n    }\n  });\n};\n\n/**\n * Get a promise which resolves when the Model's table and\n * all indices have been created.\n */\nModel.prototype.ready = function() {\n  var requirements = [];\n\n  // Ensure the Model's table is ready\n  requirements.push(this.tableReady());\n\n  // Ensure all other pending promises have been resolved\n  requirements.push(this._promisesReady());\n\n  return Promise.all(requirements);\n};\n\nModel.prototype._promisesReady = function() {\n  var self = this;\n  if (this._promisesReadyPromise) return this._promisesReadyPromise;\n\n  var verifyAll = function() {\n    return Promise.all(self._pendingPromises)\n    .then(function() {\n      var i, allFullfilled = true;\n      for (i=0; i<self._pendingPromises.length; i++) {\n         if (!self._pendingPromises[i].isFulfilled()) {\n          allFullfilled = false;\n          break;\n         }\n      }\n      return allFullfilled ? Promise.resolve() : verifyAll();\n    });\n  };\n\n  this._promisesReadyPromise = verifyAll();\n  return this._promisesReadyPromise;\n};\n\nModel.prototype._waitFor = function(promise) {\n  var self = this;\n  this._pendingPromises.push(promise);\n\n  // Emit 'ready' when all pending promises have resolved\n  if (!this._pendingReady) {\n    this._pendingReady = this._promisesReady().then(function() {\n      delete self._pendingReady;\n      self.emit('ready', self);\n    });\n  }\n};\n\n\nModel.prototype._setError = function(error) {\n  this._getModel()._error = error;\n  this.emit('error', error);\n}\n\n\n/*\n * Return the options of the model -- call from an instance of Model\n */\nModel.prototype.getOptions = function() {\n  return this._options;\n}\n\n\n/*\n * Return the instance of Model **when called on the function**\n */\nModel.prototype._getModel = function() {\n  return this.__proto__;\n}\n\n/*\n * Return the instance of Model\n */\nModel.prototype.getTableName = function() {\n  return this._getModel()._name;\n}\n\n\nModel.prototype.ensureIndex = function(name, fn, opts) {\n  var self = this;\n\n  if ((opts === undefined) && (util.isPlainObject(fn))) {\n    opts = fn;\n    fn = undefined;\n  }\n\n  return self._createIndex(name, fn, opts)\n  .catch(function(error) {\n    self._getModel()._setError(error);\n    throw error;\n  });\n}\n\nModel.prototype._createIndex = function(name, fn, opts) {\n  var model = this._getModel();\n  var tableName = this.getTableName();\n  var r = model._thinky.r;\n\n  if (opts === undefined && util.isPlainObject(fn)) {\n    opts = fn;\n    fn = undefined;\n  }\n\n  var promise = this.tableReady().then(function() {\n    return new Promise(function(resolve, reject) {\n      return r.branch(\n        r.table(tableName).indexList().contains(name),\n        r.table(tableName).indexWait(name),\n        r.branch(\n          r.table(tableName).info()('primary_key').eq(name),\n          r.table(tableName).indexWait(name),\n          r.table(tableName).indexCreate(name, fn, opts).do(function() {\n            return r.table(tableName).indexWait(name);\n          })\n        )\n      )\n      .run()\n      .then(resolve)\n      .error(function(error) {\n        if (error.message.match(/^Index/)) {\n          // TODO: This regex seems a bit too generous since messages such\n          // as \"Index `id` was not found on table...\" will be accepted.\n          // Figure out if this is OK or not.\n          return resolve();\n        }\n        reject(error);\n      });\n    });\n  })\n  .then(function() {\n    model._indexes[name] = true;\n  });\n\n  this._waitFor(promise);\n  return promise;\n};\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * The foreign key is stores in the joinedModel\n *\n * Post.hasOne(Author, \"author\", \"id\", \"postId\"\n *                ^- post.id\n *\n * options can be:\n * - init: Boolean (create an index or not)\n * - timeFormat: 'raw'/'native'\n * - enforce_extra: 'strict'/'remove'/'none'\n * - enforce_missing: Boolean\n * - enforce_type: 'strict'/'loose'/'none'\n * - validate: 'oncreate'/'onsave'\n */\nModel.prototype.hasOne = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self  = this;\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `hasOne` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n  self._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasOne'\n  }\n  joinedModel._getModel()._localKeys[rightKey] = true;\n\n  options = options || {};\n  if (options.init !== false) {\n    var newIndex = joinedModel._createIndex(rightKey)\n    .catch(function(error) {\n      joinedModel._getModel()._setError(error);\n      self._getModel()._setError(error);\n    });\n    self._waitFor(newIndex);\n  }\n}\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * The foreign key is store in the model calling belongsTo\n *\n * Post.belongsTo(Author, \"author\", \"authorId\", \"id\"\n *                        ^- author.id\n */\nModel.prototype.belongsTo = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self  = this;\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `belongsTo` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n\n  self._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'belongsTo'\n  };\n  self._getModel()._localKeys[leftKey] = true;\n\n  joinedModel._getModel()._reverseJoins[fieldDoc] = {\n    model: self,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'belongsTo',\n  }\n\n  options = options || {};\n  if (options.init !== false) {\n    /*\n    var newIndex = self._createIndex(leftKey)\n    .catch(function(error) {\n      joinedModel._getModel()._setError(error);\n      self._getModel()._setError(error);\n    });\n    joinedModel._waitFor(newIndex);\n    */\n    var newIndex = joinedModel._createIndex(rightKey)\n    .catch(function(error) {\n      joinedModel._getModel()._setError(error);\n      self._getModel()._setError(error);\n    });\n    self._waitFor(newIndex);\n\n  }\n}\n\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * A post has one author, and an author can write multiple posts\n * Author.hasMany(Post, \"posts\", \"id\", \"authorId\"\n *                 ^- author.id\n */\nModel.prototype.hasMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self  = this;\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `hasMany` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n\n  this._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasMany'\n  };\n  joinedModel._getModel()._localKeys[rightKey] = true;\n\n  options = options || {};\n  if (options.init !== false) {\n    var newIndex = joinedModel._createIndex(rightKey)\n    .catch(function(error) {\n      self._getModel()._setError(error);\n      joinedModel._getModel()._setError(error);\n    });\n    self._waitFor(newIndex);\n  }\n}\n\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * Patient.hasAndBelongsToMany(Doctor, \"doctors\", \"id\", \"id\"\n *                     patient.id-^  ^-doctor.id\n *\n * It automatically creates a table <modelName>_<joinedModel> or <joinedModel>_<modelName> (alphabetic order)\n */\nModel.prototype.hasAndBelongsToMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self = this;\n  var link, query;\n  var thinky = this._getModel()._thinky;\n  options = options || {};\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `hasAndBelongsToMany` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n\n  if (this._getModel()._name < joinedModel._getModel()._name) {\n    link = this._getModel()._name+\"_\"+joinedModel._getModel()._name;\n  }\n  else {\n    link = joinedModel._getModel()._name+\"_\"+this._getModel()._name;\n  }\n  if (typeof options.type === 'string') {\n    link = link+\"_\"+options.type;\n  }\n  else if (typeof options.type !== 'undefined') {\n    throw new Error('options.type should be a string or undefined.')\n  }\n\n  var linkModel;\n  if (thinky.models[link] === undefined) {\n    // Create a model, claim the namespace and create the table\n    // passes table options to the underlying model (e.g. replicas, shards)\n    linkModel = thinky.createModel(link, {}, { table: options.table });\n  }\n  else {\n    linkModel = thinky.models[link];\n  }\n\n\n  this._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasAndBelongsToMany',\n    link: link,\n    linkModel: linkModel\n  }\n\n  joinedModel._getModel()._reverseJoins[self.getTableName()] = {\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasAndBelongsToMany',\n    link: link,\n    linkModel: linkModel\n  }\n\n  if (options.init !== false) {\n    var r = self._getModel()._thinky.r;\n\n    var query;\n    if ((this.getTableName() === joinedModel.getTableName())\n      && (leftKey === rightKey)) {\n      // The relation is built for the same model, using the same key\n      // Create a multi index\n      query = r.branch(\n        r.table(link).indexList().contains(leftKey+\"_\"+rightKey),\n        r.table(link).indexWait(leftKey+\"_\"+rightKey),\n        r.table(link).indexCreate(leftKey+\"_\"+rightKey, function(doc) {\n          return doc(leftKey+\"_\"+rightKey)\n        }, {multi: true}).do(function() {\n          return r.table(link).indexWait(leftKey+\"_\"+rightKey)\n        })\n      )\n    }\n    else {\n      query = r.branch(\n        r.table(link).indexList().contains(self.getTableName()+'_'+leftKey),\n        r.table(link).indexWait(self.getTableName()+'_'+leftKey),\n        r.table(link).indexCreate(self.getTableName()+'_'+leftKey).do(function() {\n          return r.table(link).indexWait(self.getTableName()+'_'+leftKey)\n        })\n      ).do(function() {\n        return r.branch(\n          r.table(link).indexList().contains(joinedModel.getTableName()+'_'+rightKey),\n          r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey),\n          r.table(link).indexCreate(joinedModel.getTableName()+'_'+rightKey).do(function() {\n            return r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey)\n          })\n        )\n      })\n\n    }\n\n    var linkPromise = linkModel.ready().then(function() {\n      return query.run()\n      .then(function() {\n        self._getModel()._indexes[leftKey] = true;\n        joinedModel._getModel()._indexes[rightKey] = true;\n      })\n      .error(function(error) {\n        if (error.message.match(/^Index `/)) {\n          return;\n        }\n        if (error.message.match(/^Table `.*` already exists/)) {\n          return;\n        }\n        self._getModel()._setError(error);\n        joinedModel._getModel()._setError(error);\n        throw error;\n      });\n    })\n    .then(function() {\n      self._createIndex(leftKey)\n      .catch(function(error) {\n        self._getModel()._setError(error);\n        joinedModel._getModel()._setError(error);\n      });\n\n      joinedModel._createIndex(rightKey)\n      .catch(function(error) {\n        self._getModel()._setError(error);\n        joinedModel._getModel()._setError(error);\n      });\n    });\n\n    joinedModel._waitFor(linkPromise);\n    self._waitFor(linkPromise);\n\n    return Promise.all([self.ready(), joinedModel.ready()]);\n  }\n};\n\n(function() {\n  // Import rethinkdbdash methods\n  var Term = __webpack_require__(/*! rethinkdbdash */ \"./node_modules/rethinkdbdash/lib/index.js\")({pool: false}).expr(1).__proto__;\n  util.loopKeys(Term, function(Term, key) {\n    if (!Term.hasOwnProperty(key)) return;\n    if (key === 'run' || key[0] === '_') return;\n\n    (function(key) {\n      switch (key) {\n        case 'orderBy':\n          Model.prototype[key] = function() {\n            var query = new Query(this);\n            if ((arguments.length === 1)\n              && (typeof arguments[0] === 'string')\n              && (this._getModel()._indexes[arguments[0]] === true)) {\n\n                query = query[key]({index: arguments[0]});\n                return query;\n            }\n            else {\n              query = query[key].apply(query, arguments);\n              return query;\n            }\n          }\n          break;\n        case 'filter':\n          Model.prototype[key] = function() {\n            var query = new Query(this);\n            if ((arguments.length === 1)\n              && (util.isPlainObject(arguments[0]))) {\n\n              // Optimize a filter with an object\n              // We replace the first key that match an index name\n              var filter = arguments[0];\n\n              var keys = Object.keys(filter).sort(); // Lexicographical order\n              for(var i=0 ; i<keys.length; i++) {\n                var index = keys[i];\n\n                if (this._getModel()._indexes[index] === true) { // Index found\n                  query = query.getAll(filter[index], {index: index});\n                  delete filter[index];\n                  break;\n                }\n              }\n            }\n\n            query = query[key].apply(query, arguments);\n            return query;\n          }\n          break;\n        case 'get':\n          // Make a copy of `get` into `_get`\n          Model.prototype['_get'] = function() {\n            var query = new Query(this);\n            query = query['_get'].apply(query, arguments);\n            return query;\n          }\n        default:\n          Model.prototype[key] = function() {\n            var query = new Query(this);\n            query = query[key].apply(query, arguments);\n            return query;\n          }\n      }\n\n    })(key);\n  });\n})();\n\nModel.prototype.getJoin = function() {\n  var query = new Query(this);\n  return query.getJoin.apply(query, arguments)\n}\n\nModel.prototype.removeRelations = function(relationsToRemove) {\n  var query = new Query(this);\n  return query.removeRelations(relationsToRemove);\n}\n\n\nModel.prototype.run = function(options) {\n  var query = new Query(this);\n  return query.run(options);\n}\nModel.prototype.execute = function(options) {\n  var query = new Query(this);\n  return query.execute(options);\n}\n\nModel.prototype.save = function(docs, options) {\n  var self = this;\n  var r = self._getModel()._thinky.r;\n  var isArray = Array.isArray(docs);\n\n  if (!isArray) {\n    docs = [docs];\n  }\n\n  var p = new Promise(function(mainResolve, mainReject) {\n    var toSave = docs.length;\n\n    var resolves = [];\n    var rejects = [];\n    var executeInsert = function (resolve, reject) {\n      toSave--;\n      resolves.push(resolve);\n      rejects.push(reject);\n\n      if (toSave === 0) {\n        var copies = [];\n        for(var i=0; i<docs.length; i++) {\n          copies.push(docs[i]._makeSavableCopy());\n        }\n        var _options;\n        if (util.isPlainObject(options)) {\n          _options = util.deepCopy(options);\n        }\n        else {\n          _options = {};\n        }\n        _options.returnChanges = 'always';\n        r.table(self.getTableName()).insert(copies, _options).run().then(function(results) {\n          if (results.errors === 0) {\n            // results.changes currently does not enforce the same order as docs\n            if (Array.isArray(results.changes)) {\n              for(var i=0; i<results.changes.length; i++) {\n                docs[i]._merge(results.changes[i].new_val);\n                if (docs[i]._getModel().needToGenerateFields === true) {\n                  docs[i]._generateDefault();\n                }\n                docs[i]._setOldValue(util.deepCopy(results.changes[i].old_val));\n                docs[i].setSaved();\n                docs[i].emit('saved', docs[i]);\n              }\n            }\n            for(i=0; i<resolves.length; i++) {\n              resolves[i]();\n            }\n          }\n          else {\n            //TODO Expand error with more information\n            for(var i=0; i<rejects.length; i++) {\n              rejects[i](new Error(\"An error occurred during the batch insert. Original results:\\n\"+JSON.stringify(results, null, 2)));\n            }\n          }\n        }).error(reject);\n      }\n    };\n\n    var promises = [];\n    var foundNonValidDoc = false;\n    for(var i=0; i<docs.length; i++) {\n      if (foundNonValidDoc === true) {\n        return;\n      }\n      if (docs[i] instanceof Document === false) {\n        docs[i] = new self(docs[i]);\n      }\n      var promise;\n      util.tryCatch(function() {\n        promise = docs[i].validate();\n        if (promise instanceof Promise) {\n          promises.push(promise)\n        }\n      }, function(error) {\n        foundNonValidDoc = true;\n        mainReject(new Errors.ValidationError(\"One of the documents is not valid. Original error:\\n\"+error.message))\n      });\n    }\n\n    if (foundNonValidDoc === false) {\n      Promise.all(promises).then(function() {\n        var promises = [];\n        for(var i=0; i<docs.length; i++) {\n          promises.push(docs[i]._batchSave(executeInsert));\n        }\n        Promise.all(promises).then(function() {\n          mainResolve(docs);\n        }).error(function(error) {\n          mainReject(error)\n        });\n      }).error(function(error) {\n        mainReject(new Errors.ValidationError(\"One of the documents is not valid. Original error:\\n\"+error.message))\n      });\n    }\n  })\n\n  if (!isArray) {\n    return p.get(0);\n  }\n\n  return p;\n}\n\n\nModel.prototype.define = function(key, fn) {\n  this._methods[key] = fn;\n}\nModel.prototype.defineStatic = function(key, fn) {\n  this._staticMethods[key] = fn;\n\n  this[key] = function() {\n    return fn.apply(this, arguments);\n  };\n}\n\n\n\nModel.prototype._parse = function(data, ungroup) {\n  var self = this;\n  var promises = [];\n  var promise;\n\n  var p = new Promise(function(resolve, reject) {\n    if (ungroup) {\n      for(var i=0; i<data.length; i++) {\n        for(var j=0; j<data[i].reduction.length; j++) {\n          util.tryCatch(function() {\n            var newDoc = new self(data[i].reduction[j]);\n            newDoc.setSaved(true);\n            newDoc._emitRetrieve();\n            data[i].reduction[j] = newDoc;\n          }, reject)\n        }\n      }\n      return resolve(data);\n    }\n    else if (Array.isArray(data)) {\n      util.tryCatch(function() {\n        for(var i=0; i<data.length; i++) {\n          data[i] = new self(data[i])\n          data[i].setSaved(true);\n\n          self.emit('retrieved', data[i]);\n\n          (function(i) {\n            // Order matters here, we want the hooks to be executed *before* calling validate\n            promise = util.hook({\n              postHooks: data[i]._getModel()._post.retrieve,\n              doc: data[i],\n              async: data[i]._getModel()._async.retrieve,\n              fn: function() {}\n            })\n            if (promise instanceof Promise) {\n              promise.then(function() {\n                var promise = data[i].validate();\n                if (promise instanceof Promise) {\n                  promise.then(function() {\n                    resolve(data)\n                  }).error(reject);\n                }\n                else {\n                  resolve(data);\n                }\n              }).error(reject);\n              promises.push(promise);\n            }\n            else {\n              promise = data[i].validate();\n              if (promise instanceof Promise) promises.push(promise);\n            }\n          })(i);\n        }\n      }, function(error) {\n        var newError = new Error(\"The results could not be converted to instances of `\"+self.getTableName()+\"`\\nDetailed error: \"+error.message);\n\n        return reject(newError);\n      });\n\n      if (promises.length > 0) {\n        Promise.all(promises).then(function() {\n          resolve(data);\n        }).error(reject);\n      }\n      else {\n        resolve(data);\n      }\n    }\n    else {\n      // If we get a GROUPED_DATA, we convert documents in each group\n      if (util.isPlainObject(data) && (data.$reql_type$ === \"GROUPED_DATA\")) {\n        var result = [];\n        util.tryCatch(function() {\n          var reduction, newDoc;\n          for(var i=0; i<data.data.length; i++) {\n            (function(i) {\n              reduction = [];\n              if (Array.isArray(data.data[i][1])) {\n                for(var j=0; j<data.data[i][1].length; j++) {\n                  (function(j) {\n                    newDoc = new self(data.data[i][1][j]);\n                    newDoc.setSaved(true);\n\n                    newDoc._emitRetrieve();\n\n                    promise = util.hook({\n                      postHooks: newDoc._getModel()._post.retrieve,\n                      doc: newDoc,\n                      async: newDoc._getModel()._async.retrieve,\n                      fn: function() {}\n                    })\n                    if (promise instanceof Promise) {\n                      promise.then(function() {\n                        var promise = newDoc.validate();\n                        if (promise instanceof Promise) {\n                          promise.then(function() {\n                            resolve(data)\n                          }).error(reject);\n                        }\n                        else {\n                          resolve(data);\n                        }\n                      }).error(reject);\n                      promises.push(promise);\n                    }\n                    else {\n                      promise = newDoc.validate();\n                      if (promise instanceof Promise) promises.push(promise);\n                    }\n\n                    reduction.push(newDoc)\n                  })(j);\n                }\n                result.push({\n                  group: data.data[i][0],\n                  reduction: reduction\n                })\n              }\n              else {\n                newDoc = new self(data.data[i][1]);\n                newDoc.setSaved(true);\n\n                newDoc._emitRetrieve();\n\n                promise = util.hook({\n                  postHooks: newDoc._getModel()._post.retrieve,\n                  doc: newDoc,\n                  async: newDoc._getModel()._async.retrieve,\n                  fn: function() {}\n                })\n                if (promise instanceof Promise) {\n                  promise.then(function() {\n                    var promise = newDoc.validate();\n                    if (promise instanceof Promise) {\n                      promise.then(function() {\n                        resolve(result)\n                      }).error(reject);\n                    }\n                    else {\n                      resolve(result);\n                    }\n                  }).error(reject);\n                  promises.push(promise);\n                }\n                else {\n                  promise = newDoc.validate();\n                  if (promise instanceof Promise) promises.push(promise);\n                }\n\n                result.push({\n                  group: data.data[i][0],\n                  reduction: newDoc\n                })\n              }\n            })(i);\n          }\n        }, reject);\n        if (promises.length > 0) {\n          Promise.all(promises).then(function() {\n            resolve(result)\n          }).error(reject);\n        }\n        else {\n          resolve(result);\n        }\n      }\n      else {\n        if (data === null) { // makeDocument is true, but we got `null`\n          reject(new Error(\"Cannot build a new instance of `\"+self.getTableName()+\"` with `null`.\"))\n        }\n        else {\n          util.tryCatch(function() {\n            var newDoc = new self(data);\n            newDoc.setSaved(true);\n\n            newDoc._emitRetrieve();\n\n            promise = util.hook({\n              postHooks: newDoc._getModel()._post.retrieve,\n              doc: newDoc,\n              async: newDoc._getModel()._async.retrieve,\n              fn: function() {}\n            })\n            if (promise instanceof Promise) {\n              promise.then(function() {\n                var promise = newDoc.validate();\n                if (promise instanceof Promise) {\n                  promise.then(function() {\n                    resolve(newDoc);\n                  }).error(reject);\n                }\n                else {\n                  resolve(newDoc);\n                }\n              }).error(reject);\n            }\n            else {\n              promise = newDoc.validate();\n            }\n\n            if (promise instanceof Promise) {\n              promise.then(function() {\n                resolve(newDoc)\n              }).error(function(err) {\n                reject(err)\n              });\n            }\n            else {\n              resolve(newDoc);\n            }\n          }, reject);\n        }\n      }\n    }\n  })\n  return p;\n}\n\n/*\n * Implement an interface similar to events.EventEmitter\n */\nModel.prototype.docAddListener = function(eventKey, listener) {\n  var listeners = this._getModel()._listeners;\n  if (listeners[eventKey] == null) {\n    listeners[eventKey] = [];\n  }\n  listeners[eventKey].push({\n    once: false,\n    listener: listener\n  });\n}\nModel.prototype.docOn = Model.prototype.docAddListener;\n\nModel.prototype.docOnce = function(eventKey, listener) {\n  var listeners = this._getModel()._listeners;\n  if (listeners[eventKey] == null) {\n    listeners[eventKey] = [];\n  }\n  listeners[eventKey].push({\n    once: true,\n    listener: listener\n  });\n}\n\nModel.prototype.docListeners = function(eventKey, raw) {\n  if (eventKey == null) {\n    return this._getModel()._listeners\n  }\n\n  raw = raw || true;\n  if (raw === true) {\n    return this._getModel()._listeners[eventKey];\n  }\n  else {\n    return this._getModel()._listeners[eventKey].map(function(fn) {\n      return fn.listener;\n    });\n  }\n}\n\nModel.prototype.docSetMaxListeners = function(n) {\n  this._getModel()._maxListeners = n;\n}\n\nModel.prototype.docRemoveListener = function(ev, listener) {\n  if (Array.isArray(this._getModel()._listeners[ev])) {\n    for(var i=0; i<this._getModel()._listeners[ev].length; i++) {\n      if (this._getModel()._listeners[ev][i] === listener) {\n        this._getModel()._listeners[ev].splice(i, 1);\n        break;\n      }\n    }\n  }\n}\n\nModel.prototype.docRemoveAllListeners = function(ev) {\n  if (ev === undefined) {\n    delete this._getModel()._listeners[ev]\n  }\n  else {\n    this._getModel()._listeners = {};\n  }\n}\n\nModel.prototype.pre = function(ev, fn) {\n  if (typeof fn !== \"function\") {\n    throw new Error(\"Second argument to `pre` must be a function\");\n  }\n  if (fn.length > 1) {\n    throw new Error(\"Second argument to `pre` must be a function with at most one argument.\");\n  }\n  if (Array.isArray(this._pre[ev]) === false) {\n    throw new Error(\"No pre-hook available for the event `\"+ev+\"`.\")\n  }\n  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)\n  this._getModel()._pre[ev].push(fn);\n}\n\nModel.prototype.post = function(ev, fn) {\n  if (typeof fn !== \"function\") {\n    throw new Error(\"Second argument to `pre` must be a function\");\n  }\n  if (fn.length > 1) {\n    throw new Error(\"Second argument to `pre` must be a function with at most one argument.\");\n  }\n  if (Array.isArray(this._post[ev]) === false) {\n    throw new Error(\"No post-hook available for the event `\"+ev+\"`.\")\n  }\n  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)\n  this._getModel()._post[ev].push(fn);\n}\n\nmodule.exports = Model;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/model.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/query.js":
/*!******************************************!*\
  !*** ./node_modules/thinky/lib/query.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/main/bluebird.js\");\nvar util = __webpack_require__(/*! ./node_modules/thinky/lib/util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/errors.js */ \"./node_modules/thinky/lib/errors.js\");\nvar schemaUtil = __webpack_require__(/*! ./node_modules/thinky/lib/schema.js */ \"./node_modules/thinky/lib/schema.js\");\nvar Feed = __webpack_require__(/*! ./node_modules/thinky/lib/feed.js */ \"./node_modules/thinky/lib/feed.js\");\n\n\n/**\n * Constructor for a Query. A Query basically wraps a ReQL queries to keep track\n * of the model returned and if a post-query validation is required.\n * @param {Function=} model Model of the documents returned\n * @param {ReQLQuery=} current ReQL query (rethinkdbdash)\n * @param {boolean=} postValidation whether post query validation should be performed\n */\nfunction Query(model, query, options, error) {\n  var self = this;\n\n  this._model = model; // constructor of the model we should use for the results.\n  if (model !== undefined) {\n    this._r = model._getModel()._thinky.r;\n    util.loopKeys(model._getModel()._staticMethods, function(staticMethods, key) {\n      (function(_key) {\n        self[_key] = function() {\n          return staticMethods[_key].apply(self, arguments);\n        };\n      })(key);\n    });\n  }\n\n  if (query !== undefined) {\n    this._query = query;\n   }\n  else if (model !== undefined) {\n    // By default, we initialize the query to `r.table(<tableName>)`.\n    this._query = this._r.table(model.getTableName());\n  }\n\n  if (util.isPlainObject(options)) {\n    if (options.postValidation) {\n      this._postValidation = options.postValidation === true;\n    }\n    if (options.ungroup) {\n      this._ungroup = options.ungroup === true;\n    }\n    else {\n      this._ungroup = false;\n    }\n  }\n  else { // let the user rework the result after ungroup\n    this._ungroup = false;\n  }\n  if (error) {\n    // Note `Query.prototype.error` is defined because of `r.error`, so we shouldn't\n    // defined this.error.\n    this._error = error;\n  }\n  this._pointWrite = false;\n}\n\nQuery.prototype.setPostValidation = function() {\n  this._postValidation = true;\n}\n\nQuery.prototype.setPointWrite = function() {\n  this._pointWrite = true;\n}\n\n/**\n * Execute a Query and expect the results to be object(s) that can be converted\n * to instances of the model.\n * @param {Object=} options The options passed to the driver's method `run`\n * @param {Function=} callback\n * @return {Promise} return a promise that will be resolved when the query and\n * the instances of the models will be created (include the potential\n * asynchronous hooks).\n */\nQuery.prototype.run = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._execute(options, true).nodeify(callback);\n}\n\n\n/**\n * Execute a Query\n * @param {Object=} options The options passed to the driver's method `run`\n * @param {Function=} callback\n * @return {Promise} return a promise that will be resolved with the results\n * of the query.\n */\nQuery.prototype.execute = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._execute(options, false).nodeify(callback);\n}\n\n/**\n* Bind Query.prototype.run() for later use\n* @param {Object=} options The options passed to the driver's method `run`\n* @param {Function=} callback\n* @return {Function} return a `this` bound Query.prototype.run()\n*/\n\nQuery.prototype.bindRun = function () {\n  var curriedArgs = Array.prototype.slice.call(arguments);\n  return Function.prototype.bind.apply( Query.prototype.run, [ this ].concat( curriedArgs ) );\n}\n\n/**\n * Bind Query.prototype.execute() for later use\n * @param {Object=} options The options passed to the driver's method `run`\n * @param {Function=} callback\n * @return {Function} return a `this` bound Query.prototype.execute()\n */\n\nQuery.prototype.bindExecute = function () {\n  var curriedArgs = Array.prototype.slice.call(arguments);\n  return Function.prototype.bind.apply( Query.prototype.execute, [ this ].concat( curriedArgs ) );\n}\n\n/**\n * Internal method to execute a query. Called by `run` and `execute`.\n * @param {Object} options The options passed to the driver's method `run`\n * @param {boolean} parse Whether the results should be converted as instance(s) of the model\n * @param {Function=} callback\n * @return {Promise} return a promise that will be resolved with the results\n * of the query.\n * @private\n */\nQuery.prototype._execute = function(options, parse) {\n  var self = this;\n  options = options || {};\n  var fullOptions = {groupFormat: 'raw'}\n  util.loopKeys(options, function(options, key) {\n    fullOptions[key] = options[key]\n  });\n  if (parse === true) {\n    fullOptions.cursor = false;\n  }\n\n  if (self._model._error !== null) {\n    return Promise.reject(self._model._error);\n  }\n  return self._model.ready().then(function() {\n    return self._executeCallback(fullOptions, parse, options.groupFormat);\n  });\n}\n\nQuery.prototype._executeCallback = function(fullOptions, parse, groupFormat) {\n  var self = this;\n  if (self._error !== undefined) {\n    return Promise.reject(new Error(\"The partial value is not valid, so the write was not executed. The original error was:\\n\"+self._error.message));\n  }\n\n  return self._query.run(fullOptions).then(function(result) {\n    if (result === null && parse) {\n      throw new Errors.DocumentNotFound();\n    }\n\n    // Expect a write result from RethinkDB\n    if (self._postValidation === true) {\n      return self._validateQueryResult(result);\n    }\n\n    if (result != null && typeof result.getType === 'function') {\n      var resultType = result.getType();\n      if (resultType === 'Feed' ||\n        resultType === 'OrderByLimitFeed' ||\n        resultType === 'UnionedFeed'\n      ) {\n        var feed = new Feed(result, self._model);\n        return feed;\n      }\n\n      if (resultType === 'AtomFeed') {\n        return result.next().then(function(initial) {\n          var value = initial.new_val || {};\n          return self._model._parse(value).then(function(doc) {\n            doc._setFeed(result);\n            return doc;\n          });\n        });\n      }\n    }\n\n    if (parse === true) {\n      return self._model._parse(result, self._ungroup);\n    }\n\n    if (groupFormat !== 'raw') {\n      return Query.prototype._convertGroupedData(result);\n    }\n\n    return result;\n  }).catch(function(err) {\n    return Promise.reject(Errors.create(err));\n  })\n};\n\nQuery.prototype._validateUngroupResult = function(result) {\n}\n\nQuery.prototype._validateQueryResult = function(result) {\n  var self = this;\n  if (result.errors > 0) {\n    console.log(result);\n    return Promise.reject(new Errors.InvalidWrite(\"An error occured during the write\", result));\n  }\n  if (!Array.isArray(result.changes)) {\n    if (self._isPointWrite()) {\n      return Promise.resolve();\n    }\n    return Promise.resolve([]);\n  }\n\n  var promises = [];\n  for(var i=0; i<result.changes.length; i++) {\n    (function(i) {\n      if (result.changes[i].new_val !== null) {\n        promises.push(self._model._parse(result.changes[i].new_val));\n      }\n    })(i)\n  }\n  return Promise.all(promises).then(function(result) {\n    if (self._isPointWrite()) {\n      if (result.length > 1) {\n        throw new Error('A point write returned multiple values')\n      }\n      return result[0];\n    }\n    return result;\n  }).catch(function(error) {\n    if (error instanceof Errors.DocumentNotFound) {\n      // Should we send back null?\n    }\n    else {\n      var revertPromises = [];\n      var primaryKeys = [];\n      var keysToValues = {};\n      var r = self._model._thinky.r;\n      for(var p=0; p<result.changes.length; p++) {\n        // Extract the primary key of the document saved in the database\n        var primaryKey = util.extractPrimaryKey(\n            result.changes[p].old_val,\n            result.changes[p].new_val,\n            self._model._pk)\n        if (primaryKey === undefined) {\n          continue;\n        }\n\n        if (typeof primaryKey === \"string\") {\n          keysToValues[primaryKey] = result.changes[p].old_val;\n          primaryKeys.push(primaryKey);\n        }\n        else {\n          // Replace documents with non-string type primary keys\n          // one by one.\n          revertPromises.push(r.table(self._model.getTableName())\n            .get(primaryKey)\n            .replace(result.changes[p].old_val)\n            .run());\n        }\n      }\n\n      // Replace all documents with string-type primary keys\n      // in a single replace() operation.\n      if (primaryKeys.length) {\n        revertPromises.push(\n          r.table(self._model.getTableName()).getAll(r.args(primaryKeys)).replace(function(doc) {\n            return r.expr(keysToValues)(doc(self._model._pk));\n          }).run()\n        );\n      }\n\n      return Promise.all(revertPromises).then(function(result) {\n        throw new Error(\"The write failed, and the changes were reverted.\");\n      }).error(function(error) {\n        throw new Error(\"The write failed, and the attempt to revert the changes failed with the error:\\n\"+error.message);\n      });\n    }\n  })\n};\n\n\n/**\n * Convert GROUPED_DATA results to [group: <group>, reduction: <reduction>]\n * This does the same as the driver. The reduction is not converted to\n * instances of the model.\n */\nQuery.prototype._convertGroupedData = function(data) {\n  if (util.isPlainObject(data) && (data.$reql_type$ === \"GROUPED_DATA\")) {\n    var result = [];\n    var reduction;\n    for(var i=0; i<data.data.length; i++) {\n      result.push({\n        group: data.data[i][0],\n        reduction: data.data[i][1]\n      });\n    }\n    return result;\n  }\n  else {\n    return data;\n  }\n}\n\n\n/**\n * Perform a join given the relations on this._model\n * @param {Object=} modelToGet explicit joined documents to retrieve\n * @param {boolean} getAll Internal argument, if `modelToGet` is undefined, `getAll` will\n * be set to `true` and `getJoin` will be greedy and keep recursing as long as it does not\n * hit a circular reference\n * @param {Object=} gotModel Internal argument, the model we are already fetching.\n * @return {Query}\n */\nQuery.prototype.getJoin = function(modelToGet, getAll, gotModel) {\n  var self = this;\n  var r = self._model._getModel()._thinky.r;\n\n  var model = this._model;\n  var joins = this._model._getModel()._joins;\n\n  var getAll = modelToGet === undefined;\n  if (util.isPlainObject(modelToGet) === false) {\n    modelToGet = {};\n  }\n  var innerQuery;\n\n  gotModel = gotModel || {};\n  gotModel[model.getTableName()] = true;\n\n  util.loopKeys(joins, function(joins, key) {\n    if (util.recurse(key, joins, modelToGet, getAll, gotModel)) {\n      switch (joins[key].type) {\n        case 'hasOne':\n        case 'belongsTo':\n          self._query = self._query.merge(function(doc) {\n            return r.branch(\n              doc.hasFields(joins[key].leftKey),\n              r.table(joins[key].model.getTableName()).getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}).coerceTo(\"ARRAY\").do(function(result) {\n                innerQuery = new Query(joins[key].model, result.nth(0));\n\n                if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n                  innerQuery = modelToGet[key]._apply(innerQuery);\n                }\n                innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel)._query;\n                return r.branch(\n                  result.count().eq(1),\n                  r.object(key, innerQuery),\n                  r.branch(\n                    result.count().eq(0),\n                    {},\n                    r.error(r.expr(\"More than one element found for \").add(doc.coerceTo(\"STRING\")).add(r.expr(\"for the field \").add(key)))\n                  )\n                )\n              }),\n              {}\n            )\n          });\n          break;\n\n        case 'hasMany':\n          self._query = self._query.merge(function(doc) {\n            innerQuery = new Query(joins[key].model,\n                       r.table(joins[key].model.getTableName())\n                      .getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}))\n\n            if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n              innerQuery = modelToGet[key]._apply(innerQuery);\n            }\n            innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel);\n            if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {\n              innerQuery = innerQuery.coerceTo(\"ARRAY\");\n            }\n            innerQuery = innerQuery._query;\n\n            return r.branch(\n              doc.hasFields(joins[key].leftKey),\n              r.object(key, innerQuery),\n              {}\n            )\n          });\n          break;\n\n        case 'hasAndBelongsToMany':\n          self._query = self._query.merge(function(doc) {\n            if ((model.getTableName() === joins[key].model.getTableName()) && (joins[key].leftKey === joins[key].rightKey)) {\n              // In case the model is linked with itself on the same key\n\n              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: joins[key].leftKey+\"_\"+joins[key].leftKey}).concatMap(function(link) {\n                return r.table(joins[key].model.getTableName()).getAll(\n                  r.branch(\n                    doc(joins[key].leftKey).eq(link(joins[key].leftKey+\"_\"+joins[key].leftKey).nth(0)),\n                    link(joins[key].leftKey+\"_\"+joins[key].leftKey).nth(1),\n                    link(joins[key].leftKey+\"_\"+joins[key].leftKey).nth(0)\n                  )\n                , {index: joins[key].rightKey})\n              });\n\n              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n                innerQuery = modelToGet[key]._apply(innerQuery);\n              }\n\n              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {\n                innerQuery = innerQuery.coerceTo(\"ARRAY\");\n              }\n\n              return r.branch(\n                doc.hasFields(joins[key].leftKey),\n                r.object(key, new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),\n                {}\n              )\n            }\n            else {\n              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: model.getTableName()+\"_\"+joins[key].leftKey}).concatMap(function(link) {\n                return r.table(joins[key].model.getTableName()).getAll(link(joins[key].model.getTableName()+\"_\"+joins[key].rightKey), {index: joins[key].rightKey})\n              });\n\n              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n                innerQuery = modelToGet[key]._apply(innerQuery)\n              }\n\n              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {\n                innerQuery = innerQuery.coerceTo(\"ARRAY\");\n              }\n\n              return r.branch(\n                doc.hasFields(joins[key].leftKey),\n                r.object(key,\n                  new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),\n                {}\n              )\n            }\n          });\n          break;\n      }\n    }\n  });\n\n  return self;\n};\n\n\n/**\n * Add a relation\n * @param {string} field The field of the joined document(s)\n * @param {Object} joinedDocument An object with the primary key defined or the related key\n * @return {Promise}\n *\n * hasOne, primary key required\n * User.get(1).addRelation(\"account\", {id: 2, sold: 2132})\n * The promise resolved the document on which addRelation is called\n *\n * hasMany, primary key required\n * User.get(1).addRelation(\"accounts\", {id: 2, sold: 2132})\n * The promise resolved the updated joined document\n *\n * belongsTo, right joined key OR primary key required\n * User.get(1).addRelation(\"account\", {id: 2, sold: 2132})\n * The promise resolved the document on which addRelation is called\n *\n * hasAndBelongsToMany, right joined key required\n * User.get(1).addRelation(\"accounts\", {id: 2, sold: 2132})\n * The promise resolved with true\n */\n\nQuery.prototype.addRelation = function(field, joinedDocument) {\n  var self = this;\n  var model = self._model;\n  var joins = self._model._getModel()._joins;\n  var joinedModel = joins[field].model;\n  var r = self._model._thinky.r;\n\n  switch (joins[field].type) {\n    case 'hasOne':\n    case 'hasMany':\n      if (joinedDocument[joinedModel._pk] === undefined) {\n        return new Query(model, self, {},\n            new Error('Primary key for the joined document not found for a `hasOne/hasMany` relation.')\n        );\n      }\n      var updateValue = {};\n      updateValue[joins[field].rightKey] = self._query(joins[field].leftKey);\n      return joinedModel.get(joinedDocument[joinedModel._pk]).update(updateValue, {nonAtomic: true}).run()\n    case 'belongsTo':\n      var updateValue = {};\n      if (joinedDocument[joins[field].rightKey] === undefined) {\n        if (joinedDocument[joinedModel._pk] === undefined) {\n          return new Query(model, self, {},\n              new Error('The primary key or the joined key must be defined in the joined document for a `belongsTo` relation.')\n          );\n        }\n        updateValue[joins[field].leftKey] = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query;\n      }\n      else {\n        updateValue[joins[field].leftKey] = joinedDocument[joins[field].rightKey];\n      }\n      return self.update(updateValue, {nonAtomic: true}).run();\n    case 'hasAndBelongsToMany':\n      var linkModel = joins[field].linkModel;\n      var linkValue;\n      var link;\n      if (joinedDocument[joins[field].rightKey] === undefined) {\n        if (joinedDocument[joinedModel._pk] === undefined) {\n          return new Query(model, self, {},\n              new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')\n          );\n        }\n        link = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query\n      }\n      else {\n        link = r.expr(joinedDocument[joins[field].rightKey]);\n      }\n\n      if ((model.getTableName() === joinedModel.getTableName())\n          && (joins[field].leftKey === joins[field].rightKey)) {\n        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {\n          return link.do(function(rightKey) {\n            return r.branch(\n                rightKey.lt(leftKey),\n                r.object(\n                  'id', rightKey.add('_').add(leftKey),\n                  joins[field].leftKey+\"_\"+joins[field].leftKey, [leftKey, rightKey]\n                ),\n                r.object(\n                  'id', leftKey.add('_').add(rightKey),\n                  joins[field].leftKey+\"_\"+joins[field].leftKey, [leftKey, rightKey]\n                )\n            )\n          });\n        });\n      }\n      else {\n        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {\n          return link.do(function(rightKey) {\n            if (model.getTableName() < joinedModel.getTableName()) {\n              return r.object(\n                'id', leftKey.add('_').add(rightKey),\n                model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n              )\n            }\n            else if (model.getTableName() > joinedModel.getTableName()) {\n              return r.object(\n                'id', rightKey.add('_').add(leftKey),\n                model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n              )\n            }\n            else {\n              return r.branch(\n                rightKey.lt(leftKey),\n                r.object(\n                  'id', leftKey.add('_').add(rightKey),\n                  model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                  joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n                ),\n                r.object(\n                  'id', rightKey.add('_').add(leftKey),\n                  model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                  joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n                )\n              )\n            }\n          });\n        });\n      }\n\n      return linkModel.insert(linkValue, {conflict: \"replace\", returnChanges: 'always'}).do(function(result) {\n        return r.branch(\n            result('errors').eq(0),\n            true, // not relevant value\n            r.error(result('errors'))\n        )\n      }).execute()\n    default:\n      return new Query(model, self, {},\n          new Error('The provided field `'+field+'` does not store joined documents.')\n      ).run()\n  }\n}\n\n/**\n * Remove the provided relation\n * @param {string} field The field of the joined document(s) to remove\n * @param {Array} joinedDocument The document with who the relation should be removed\n * @return {Promise}\n */\n//TODO Support an array of joinedDocuments?\nQuery.prototype.removeRelation = function(field, joinedDocument) {\n  var self = this;\n  var model = self._model;\n  var joins = self._model._getModel()._joins;\n  var joinedModel = joins[field].model;\n  var r = self._model._thinky.r;\n\n  var query;\n  switch (joins[field].type) {\n    case 'hasOne':\n      query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {\n        return row.without(joins[field].rightKey)\n      });\n      query.setPostValidation();\n      query.setPointWrite();\n      return query;\n    case 'hasMany':\n      if (joinedDocument === undefined) {\n        query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {\n          return row.without(joins[field].rightKey)\n        })\n      }\n      else {\n        query = joinedModel.getAll(r.expr(joinedDocument)(joinedModel._pk)).replace(function(row) {\n          return row.without(joins[field].rightKey)\n        })\n      }\n      query.setPostValidation();\n      return query;\n    case 'belongsTo':\n      query = self.replace(function(row) {\n        return row.without(joins[field].leftKey)\n      })\n      query.setPostValidation();\n      return query;\n    case 'hasAndBelongsToMany':\n      var linkModel = joins[field].linkModel;\n      if (joinedDocument === undefined) {\n        query = self._query(joins[field].leftKey).do(function(leftKey) {\n          // range are not supported at the moment, so keys is an object and we don't have to worry about empty sequences\n          if ((model.getTableName() === joinedModel.getTableName())\n              && (joins[field].leftKey === joins[field].rightKey)) {\n            return linkModel.getAll(leftKey, {index: joins[field].leftKey+'_'+joins[field].leftKey}).delete()._query\n          }\n          else {\n            return linkModel.getAll(leftKey, {index: model.getTableName()+'_'+joins[field].leftKey}).delete()._query\n          }\n        }).do(function(result) {\n          return r.branch(\n              result('errors').eq(0),\n              true, // not relevant value\n              r.error(result('errors'))\n           )\n        })\n      }\n      else {\n        if (joinedDocument[joins[field].rightKey] === undefined) {\n          if (joinedDocument[joinedModel._pk] === undefined) {\n            return new Query(model, self, {},\n                new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')\n            );\n          }\n\n          if ((model.getTableName() === joinedModel.getTableName())\n              && (joins[field].leftKey === joins[field].rightKey)) {\n            query = self._query(joins[field].leftKey).do(function(leftKey) {\n              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {\n                if (model.getTableName() < joinedModel.getTableName()) {\n                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query;\n                }\n                else if (model.getTableName() > joinedModel.getTableName()) {\n                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query;\n                }\n                else {\n                  return r.branch(\n                    leftKey.lt(rightKey),\n                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,\n                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n                  )\n                }\n              });\n            })\n          }\n          else {\n            query = self._query(joins[field].leftKey).do(function(leftKey) {\n              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {\n                if (model.getTableName() < joinedModel.getTableName()) {\n                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query\n                }\n                else if (model.getTableName() > joinedModel.getTableName()) {\n                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n                }\n                else {\n                  return r.branch(\n                    leftKey.lt(rightKey),\n                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,\n                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n                  )\n\n                }\n              });\n            })\n          }\n        }\n        else {\n          query = self._query(joins[field].leftKey).do(function(leftKey) {\n            var rightKey = r.expr(joinedDocument[joins[field].rightKey]);\n            if (model.getTableName() < joinedModel.getTableName()) {\n              return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query\n            }\n            else if (model.getTableName() > joinedModel.getTableName()) {\n              return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n            }\n            else {\n              return r.branch(\n                leftKey.lt(rightKey),\n                linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,\n                linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n              )\n\n            }\n          })\n        }\n      }\n      return query;\n    default:\n      return new Query(model, self, {},\n          new Error('The provided field `'+field+'` does not store joined documents.')\n      );\n  }\n};\n\n/**\n * Import all the methods from rethinkdbdash, expect the private one (the one\n * starting with an underscore).\n * Some method are slightly changed: `get`, `update`, `replace`.\n */\n(function() {\n  var Term = __webpack_require__(/*! rethinkdbdash */ \"./node_modules/rethinkdbdash/lib/index.js\")({pool: false}).expr(1).__proto__;\n  util.loopKeys(Term, function(Term, key) {\n    if (key === 'run' || key[0] === '_') return;\n    // Note: We suppose that no method has an empty name\n    switch (key) {\n      case 'get':\n        // `get` in thinky returns an error if the document is not found.\n        // The driver currently just returns `null`.\n        (function(key) {\n          Query.prototype[key] = function() {\n            return new Query(this._model, this._query[key].apply(this._query, arguments)).default(this._r.error(new Errors.DocumentNotFound().message));\n          }\n        })(key);\n        // Copy it in `_get` without `default`.\n        (function(key) {\n          Query.prototype['_get'] = function() {\n            // Create a new query to let people fork it\n            return new Query(this._model, this._query[key].apply(this._query, arguments));\n          }\n        })(key);\n        break;\n      case 'update':\n      case 'replace':\n        // `update` and `replace` can be used. A partial validation is performed before\n        // sending the query, and a full validation is performed after the query. If the\n        // validation fails, the document(s) will be reverted.\n        (function(key) {\n          Query.prototype[key] = function(value, options) {\n            options = options || {};\n            options.returnChanges = 'always';\n            var error = null;\n            var self = this;\n            util.tryCatch(function() {\n              if (util.isPlainObject(value)) {\n                schemaUtil.validate(value, self._model._schema, '', {enforce_missing: false});\n              }\n            }, function(err) {\n              error = err;\n            });\n            return new Query(this._model, this._query[key].call(this._query, value, options), {postValidation: true}, error);\n          }\n        })(key);\n        break;\n\n      case 'changes':\n        (function(key) {\n          Query.prototype[key] = function() {\n            // In case of `get().changes()` we want to remove the default(r.errror(...))\n            // TODO: Do not hardcode this?\n            if ((typeof this._query === 'function') && (this._query._query[0] === 92)) {\n              this._query._query = this._query._query[1][0];\n            }\n            return new Query(this._model, this._query[key].apply(this._query, arguments));\n          }\n        })(key);\n        break;\n\n      case 'then':\n      case 'error':\n      case 'catch':\n      case 'finally':\n        (function(key) {\n          Query.prototype[key] = function() {\n            var promise = this.run();\n            return promise[key].apply(promise, arguments);\n          }\n        })(key);\n        break;\n\n      case 'ungroup':\n        (function(key) {\n          Query.prototype[key] = function() {\n            return new Query(this._model, this._query[key].apply(this._query, arguments), {ungroup: true});\n          }\n        })(key);\n        break;\n\n      default:\n        (function(key) {\n          Query.prototype[key] = function() {\n            // Create a new query to let people fork it\n            return new Query(this._model, this._query[key].apply(this._query, arguments));\n          }\n        })(key);\n        break;\n      }\n  });\n})();\n\nQuery.prototype._isPointWrite = function() {\n  return this._pointWrite || (Array.isArray(this._query._query) &&\n      (this._query._query.length > 1) &&\n      Array.isArray(this._query._query[1]) &&\n      (this._query._query[1].length > 0) &&\n      Array.isArray(this._query._query[1][0]) &&\n      (this._query._query[1][0].length > 1) &&\n      Array.isArray(this._query._query[1][0][1]) &&\n      (this._query._query[1][0][1].length > 0) &&\n      Array.isArray(this._query._query[1][0][1][0]) &&\n      (this._query._query[1][0][1][0][0] === 16))\n}\n\n/**\n * Convert the query to its string representation.\n * @return {string}\n */\nQuery.prototype.toString = function() {\n  return this._query.toString();\n}\n\nmodule.exports = Query;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/query.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/schema.js":
/*!*******************************************!*\
  !*** ./node_modules/thinky/lib/schema.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayPrefix = \"__array\"\nmodule.exports.arrayPrefix = arrayPrefix;\n\nvar util = __webpack_require__(/*! ./node_modules/thinky/lib/util.js */ \"./node_modules/thinky/lib/util.js\");\nvar type = __webpack_require__(/*! ./node_modules/thinky/lib/type/index.js */ \"./node_modules/thinky/lib/type/index.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\n\nfunction generateVirtual(doc, defaultField, originalDoc, virtual) {\n  var path = defaultField.path;\n  var value = defaultField.value;\n  var field = doc;\n\n  var keepGoing = true;\n  var virtualValue = virtual;\n\n  for(var j=0; j<path.length-1; j++) {\n    if (util.isPlainObject(virtualValue)) {\n      virtualValue = virtualValue[path[j]];\n    }\n    else {\n      virtualValue = undefined;\n    }\n\n    if (path[j] === arrayPrefix) {\n      if (!Array.isArray(field)) {\n        // This is caught by validate, except if there is an `enforce_type: \"none\"`.\n        return;\n      }\n      else {\n        for(var k=0; k<field.length; k++) {\n          if (virtual != null) {\n            virtualValue = virtual[k];\n          }\n          generateVirtual(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this, virtualValue);\n        }\n      }\n      keepGoing = false;\n    }\n    else {\n      // field cannot be undefined (doc is not undefined on the first iteration, and we'll return if it becomes undefined\n      field = field[path[j]];\n      if (field === undefined) {\n        // We do not populate parent of default fields by default\n        return;\n      }\n    }\n  }\n  if (keepGoing) {\n    if (value === undefined) {\n      if (util.isPlainObject(virtualValue) && (virtualValue[[path[path.length-1]]] !== undefined)) {\n        field[path[path.length-1]] = virtualValue[[path[path.length-1]]];\n      }\n    }\n    else if ((typeof value === \"function\") && !Array.isArray(value._query)) {\n      field[path[path.length-1]] = value.call(doc);\n    }\n    else {\n      if (util.isPlainObject(value)) {\n        field[path[path.length-1]] = util.deepCopy(value);\n      }\n      else if (value !== undefined) {\n        field[path[path.length-1]] = value;\n      }\n    }\n  }\n  return doc;\n}\n\nmodule.exports.generateVirtual = generateVirtual;\n\nfunction generateDefault(doc, defaultField, originalDoc) {\n  var path = defaultField.path;\n  var value = defaultField.value;\n  var field = doc;\n\n  var keepGoing = true;\n  for(var j=0; j<path.length-1; j++) {\n    if (path[j] === arrayPrefix) {\n      if (!Array.isArray(field)) {\n        // This is caught by validate, except if there is an `enforce_type: \"none\"`.\n        return;\n      }\n      else {\n        for(var k=0; k<field.length; k++) {\n          generateDefault(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this);\n        }\n      }\n      keepGoing = false;\n    }\n    else {\n      field = field[path[j]];\n      if (field === undefined) {\n        // We do not populate parent of default fields by default\n        return;\n      }\n    }\n  }\n  if (keepGoing && util.isPlainObject(field) && field[path[path.length-1]] === undefined) {\n    if ((typeof value === \"function\") && !Array.isArray(value._query)) {\n      field[path[path.length-1]] = value.call(doc);\n    }\n    else {\n      if (util.isPlainObject(value) || Array.isArray(value)) {\n        field[path[path.length-1]] = util.deepCopy(value);\n      }\n      else {\n        field[path[path.length-1]] = value;\n      }\n    }\n  }\n  return doc;\n}\n\nmodule.exports.generateDefault = generateDefault;\n\nfunction parse(schema, prefix, options, model) {\n  var result;\n\n  if ((prefix === '') && (type.isObject(schema) === false) && (util.isPlainObject(schema) === false)) {\n    throw new Errors.ValidationError(\"The schema must be a plain object.\")\n  }\n\n  // Validate a schema and add the field _enum if needed\n  if (util.isPlainObject(schema)) {\n    if (schema._type !== undefined) {\n      options = util.mergeOptions(options, schema.options);\n      var result;\n      switch(schema._type) {\n        case String:\n          result = type.string().options(options).validator(schema.validator).enum(schema.enum);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (typeof schema.min === \"number\") { result.min(schema.min); }\n          if (typeof schema.max === \"number\") { result.max(schema.max); }\n          if (typeof schema.length === \"number\") { result.length(schema.length); }\n          if (schema.alphanum === true) { result.alphanum(); }\n          if (schema.lowercase === true) { result.lowercase(); }\n          if (schema.uppercase === true) { result.uppercase(); }\n          if (typeof schema.regex === \"string\") { result.regex(regex, schema.flags); }\n          return result;\n        case Number:\n          result = type.number().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (typeof schema.min === \"number\") { result.min(schema.min); }\n          if (typeof schema.max === \"number\") { result.max(schema.max); }\n          if (typeof schema.length === \"number\") { result.length(schema.length); }\n          if (schema.integer === true) { result.integer(); }\n          return result;\n        case Boolean:\n          result = type.boolean().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result;\n        case Date:\n          var result = type.date().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (schema.min instanceof Date) { result.min(schema.min); }\n          if (schema.max instanceof Date) { result.max(schema.max); }\n          return result;\n        case Buffer:\n          result = type.buffer().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result\n        case Object:\n          result = type.object().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          util.loopKeys(schema.schema, function(_schema, key) {\n            result.setKey(key, parse(_schema[key], prefix+\"[\"+key+\"]\", options));\n          })\n          if (prefix === '') {\n            result._setModel(model)\n          }\n          return result;\n        case Array:\n          var result = type.array().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (schema.schema !== undefined) {\n            result.schema(parse(schema.schema, prefix+\"[0]\", options));\n          }\n          if (typeof schema.min === \"number\") { result.min(schema.min); }\n          if (typeof schema.max === \"number\") { result.max(schema.max); }\n          if (typeof schema.length === \"number\") { result.length(schema.length); }\n          return result;\n        case 'Point':\n          result = type.point().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result;\n        case 'virtual':\n          result = type.virtual();\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result\n        default: // Unknown type\n          throw new Errors.ValidationError(\"The field `_type` must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for \"+prefix);\n      }\n    }\n    else if (type.isString(schema)\n        || type.isNumber(schema)\n        || type.isBoolean(schema)\n        || type.isDate(schema)\n        || type.isBuffer(schema)\n        || type.isPoint(schema)\n        || type.isObject(schema)\n        || type.isArray(schema)\n        || type.isAny(schema)\n        || type.isVirtual(schema)){ // Unknown type\n      // Nothing to do here\n      if (type.isObject(schema)) {\n        parse(schema._schema, prefix, options);\n      }\n      else if (type.isArray(schema)) {\n        if (schema._schema == undefined) {\n          schema._schema = parse(type.any(), prefix, options);\n        }\n        else {\n          schema._schema = parse(schema._schema, prefix, options);\n        }\n      }\n\n      // We want to copy the model object here\n      if (util.isPlainObject(schema._options) === false) {\n        schema.options(options);\n      }\n      else if ((schema._options.enforce_extra === undefined)\n          || (schema._options.enforce_missing === undefined)\n          || (schema._options.enforce_type === undefined)) {\n        var newOptions = {};\n        newOptions.enforce_missing = (schema._options.enforce_missing != null) ? schema._options.enforce_missing : options.enforce_missing;\n        newOptions.enforce_extra = (schema._options.enforce_extra != null) ? schema._options.enforce_extra : options.enforce_extra;\n        newOptions.enforce_type = (schema._options.enforce_type != null) ? schema._options.enforce_type : options.enforce_type;\n        schema.options(newOptions);\n      }\n      return schema;\n    }\n    else {\n      result = type.object().options(options);\n      util.loopKeys(schema, function(_schema, key) {\n        result.setKey(key, parse(_schema[key], prefix+\"[\"+key+\"]\", options));\n      })\n      if (prefix === '') {\n        result._setModel(model)\n      }\n      return result;\n    }\n  }\n  else if (Array.isArray(schema)) {\n    result = type.array().options(options);\n    if (schema.length > 1) {\n      throw new Errors.ValidationError(\"An array in a schema can have at most one element. Found \"+schema.length+\" elements in \"+prefix)\n    }\n\n    if (schema.length > 0) {\n      result.schema(parse(schema[0], prefix+\"[0]\", options));\n    }\n    return result;\n\n  }\n  else if (schema === String) {\n    return type.string().options(options);\n  }\n  else if (schema === Number) {\n    return type.number().options(options);\n  }\n  else if (schema === Boolean) {\n    return type.boolean().options(options);\n  }\n  else if (schema === Date) {\n    return type.date().options(options);\n  }\n  else if (schema === Buffer) {\n    return type.buffer().options(options);\n  }\n  else if (schema === Object) {\n    return type.object().options(options);\n  }\n  else if (schema === Array) {\n    return type.array().options(options);\n  }\n  else if (schema === 'Point') {\n    return type.point().options(options);\n  }\n  else if (schema === 'virtual') {\n    return type.virtual().options(options);\n  }\n  else {\n    throw new Errors.ValidationError(\"The value must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for \"+prefix);\n  }\n}\nmodule.exports.parse = parse;\n\n// The schema doesn't contain joined docs\nfunction validate(doc, schema, prefix, options) {\n  schema.validate(doc, prefix, options);\n}\nmodule.exports.validate = validate;\n\nfunction getType(schema) {\n  if (util.isPlainObject(schema) && (schema._type !== undefined)) {\n    return schema._type;\n  }\n  return schema;\n}\n\n\nfunction validateEnum(doc, schema, prefix) {\n  if (Array.isArray(schema.enum) && (schema._enum[doc] !== true)) {\n    var validValues = Object.keys(schema._enum);\n    var message = \"The field \"+prefix+\" must be one of these values: \"\n\n    for(var i=0; i<validValues.length; i++) {\n      if (i === 10) { break; }\n      if ((i === validValues.length-1) || (i === 9)) {\n        message = message+validValues[i]\n      }\n      else {\n        message = message+validValues[i]+\", \"\n      }\n    }\n    if (validValues.length > 10) {\n      message = message+\"...\"\n    }\n    else {\n      message = message+\".\"\n    }\n\n    throw new Errors.ValidationError(message);\n  }\n}\n// Check that schema is a valid object first\nfunction validateCustomizedValidator(doc, schema, prefix) {\n  if (typeof schema.validator === 'function') {\n    if (schema.validator(doc) === false) {\n      throw new Errors.ValidationErrors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n    }\n  }\n}\n\nfunction validateString(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"string\", options)) return;\n\n  if (typeof doc !== \"string\") { // doc is not null/undefined\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"string\");\n    }\n    else if (options.enforce_type === \"loose\") {\n      looseType(prefix, \"string\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n    validateEnum(doc, schema, prefix);\n  }\n}\n\nfunction validateNumber(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"number\", options)) return;\n\n  if (typeof doc !== \"number\") { // doc is not null/undefined\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"number\");\n    }\n    else if (options.enforce_type === \"loose\") {\n      looseType(prefix, \"number\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n    validateEnum(doc, schema, prefix);\n  }\n\n}\n\nfunction validateBoolean(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"boolean\", options)) return;\n\n  if (typeof doc !== \"boolean\") { // doc is not null/undefined\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"boolean\");\n    }\n    else if (options.enforce_type === \"loose\") {\n      looseType(prefix, \"boolean\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n    validateEnum(doc, schema, prefix);\n  }\n}\n\nfunction validateDate(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"date\", options)) return;\n\n  if (options.enforce_type !== \"none\") {\n    if (util.isPlainObject(doc) && (doc[\"$reql_type$\"] === \"TIME\")) {\n      if (doc.epoch_time === undefined) {\n        pseudoTypeError(\"date\", \"epoch_time\", prefix);\n      }\n      else if (doc.timezone === undefined) {\n        pseudoTypeError(\"date\", \"timezone\", prefix);\n      }\n    }\n    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {\n      // TOIMPROVE -- we currently just check if it's a term from the driver\n      // We suppose for now that this is enough and we don't throw an error\n    }\n    else if (typeof doc === 'string') {\n      var date = new Date(doc);\n      if (date.getTime() !== date.getTime()) {\n        if (options.enforce_type === \"strict\") {\n          strictType(prefix, \"date or a valid string\");\n        }\n        else if (options.enforce_type !== \"none\") {\n          looseType(prefix, \"date or a valid string\");\n        }\n      }\n    }\n    else if ((doc instanceof Date) === false)  {\n      if (options.enforce_type === \"strict\") {\n        strictType(prefix, \"date\");\n      }\n      else if (options.enforce_type !== \"none\") {\n        looseType(prefix, \"date\");\n      }\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n  }\n}\n\nfunction validatePoint(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"point\", options)) return;\n\n  if (options.enforce_type !== \"none\") {\n    if (util.isPlainObject(doc) && (doc[\"$reql_type$\"] === \"GEOMETRY\")) {\n      if (doc.type === undefined) {\n        pseudoTypeError(\"Point\", \"type\", prefix);\n      }\n      else if (doc.type !== \"Point\") {\n        throw new Errors.ValidationError(\"The field `type` for \"+prefix+\" must be `'Point'`.\")\n      }\n      else if (doc.coordinates === undefined) {\n        pseudoTypeError(\"date\", \"coordinates\", prefix);\n      }\n      else if ((!Array.isArray(doc.coordinates)) || (doc.coordinates.length !== 2)) {\n        throw new Errors.ValidationError(\"The field `coordinates` for \"+prefix+\" must be an Array of two numbers.\")\n      }\n    }\n    else if (util.isPlainObject(doc) && (doc.type === \"Point\") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson\n      // Geojson format\n    }\n    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {\n      // TOIMPROvE -- we currently just check if it's a term from the driver\n      // We suppose for now that this is enough and we don't throw an error\n    }\n    else if (util.isPlainObject(doc)) {\n      var keys = Object.keys(doc).sort();\n      if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof doc.latitude !== \"number\") || (typeof doc.longitude !== \"number\")) {\n        throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n      }\n      else if ((typeof doc.latitude !== 'number') || (typeof doc.latitude !== 'number')) {\n        throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n      }\n    }\n    else if (Array.isArray(doc)) {\n      if ((doc.length !== 2) || (typeof doc[0] !== \"number\") || (typeof doc[1] !== \"number\")) {\n        throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n      }\n    }\n  }\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n  }\n}\n\nfunction validateBuffer(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"buffer\", options)) return;\n\n  if (util.isPlainObject(doc) && (doc[\"$reql_type$\"] === \"BINARY\")) {\n    if (doc.data === undefined) {\n      pseudoTypeError(\"binary\", \"data\", prefix);\n    }\n  }\n  else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {\n    // TOIMPROvE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if ((doc instanceof Buffer) === false)  {\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"buffer\");\n    }\n    else if (options.enforce_type !== \"none\") {\n      looseType(prefix, \"buffer\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/schema.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/thinky.js":
/*!*******************************************!*\
  !*** ./node_modules/thinky/lib/thinky.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rethinkdbdash = __webpack_require__(/*! rethinkdbdash */ \"./node_modules/rethinkdbdash/lib/index.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/main/bluebird.js\");\nvar Model = __webpack_require__(/*! ./node_modules/thinky/lib/model.js */ \"./node_modules/thinky/lib/model.js\");\nvar util = __webpack_require__(/*! ./node_modules/thinky/lib/util.js */ \"./node_modules/thinky/lib/util.js\");\nvar type = __webpack_require__(/*! ./node_modules/thinky/lib/type/index.js */ \"./node_modules/thinky/lib/type/index.js\");\nvar Query = __webpack_require__(/*! ./node_modules/thinky/lib/query.js */ \"./node_modules/thinky/lib/query.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\n/**\n * Main method, create the default database.\n *\n * @param {Object} options the options for the driver and the future models created.\n *  - `max` {number} The maximum number of connections in the pool, default 1000\n *  - `buffer` {number} The minimum number of connections available in the pool, default 50\n *  - `timeoutError` {number} The wait time before reconnecting in case of an error (in ms), default 1000\n *  - `timeoutGb` {number} How long the pool keep a connection that hasn't been used (in ms), default 60*60*1000\n *  - `enforce_missing` {boolean}, default `false`\n *  - `enforce_extra` {\"strict\"|\"remove\"|\"none\"}, default `\"none\"`\n *  - `enforce_type` {\"strict\"|\"loose\"|\"none\"}, default `\"loose\"`\n *  - `timeFormat` {\"raw\"|\"native\"}\n *  - `createDatabase` {boolean} Whether thinky should create the database or not.\n */\nfunction Thinky(config) {\n  var self = this;\n\n  config = config || {};\n  config.db = config.db || 'test'; // We need the default db to create it.\n  self._config = config;\n\n  self._options = {};\n  // Option passed to each model we are going to create.\n  self._options.enforce_missing =\n    (config.enforce_missing != null) ? config.enforce_missing : false;\n  self._options.enforce_extra =\n    (config.enforce_extra != null) ? config.enforce_extra : \"none\";\n  self._options.enforce_type =\n    (config.enforce_type != null) ? config.enforce_type : 'loose';\n\n  // Format of time objects returned by the database, by default we convert\n  // them to JavaScript Dates.\n  self._options.timeFormat =\n    (config.timeFormat != null) ? config.timeFormat : 'native';\n  // Option passed to each model we are going to create.\n  self._options.validate =\n    (config.validate != null) ? config.validate : 'onsave';\n\n  if (config.r === undefined) {\n    self.r = rethinkdbdash(config);\n  }\n  else {\n    self.r = config.r;\n  }\n  self.type = type;\n  self.Query = Query;\n  self.models = {};\n\n  // Export errors\n  self.Errors = Errors;\n\n  // Initialize the database.\n  self.dbReady().then().error(function(error) {\n    throw error;\n  });\n}\n\n\n/**\n * Initialize our database.\n * @return {Promise=} Returns a promise which will resolve when the database is ready.\n */\nThinky.prototype.dbReady = function() {\n  var self = this;\n  if (this._dbReadyPromise) return this._dbReadyPromise;\n  var r = self.r;\n  if (self._config.createDatabase === false) {\n    return Promise.resolve();\n  }\n  this._dbReadyPromise = r.dbCreate(self._config.db)\n  .run()\n  .error(function(error) {\n    // The `do` is not atomic, we a concurrent query could create the database\n    // between the time `dbList` is ran and `dbCreate` is.\n    if (error.message.match(/^Database `.*` already exists in/)) {\n      return;\n    }\n\n    // In case something went wrong here, we do not recover and throw.\n    throw error;\n  });\n\n  return self._dbReadyPromise;\n};\n\n/**\n * Return the current option used.\n * @return {object} The global options of the library\n */\nThinky.prototype.getOptions = function() {\n  return this._options;\n}\n\n\n/**\n * Create a model\n *\n * @param {string} name The name of the table used behind this model.\n * @param {object|Type} schema The schema of this model.\n * @param {object=} options Options for this model. The fields can be:\n *  - `init` {boolean} Whether the table should be created or not. The value\n *  `false` is used to speed up testing, and should probably be `true` in\n *  other use cases.\n *  - `timeFormat` {\"raw\"|\"native\"} Format of ReQL dates.\n *  - `enforce_missing` {boolean}, default `false`.\n *  - `enforce_extra` {\"strict\"|\"remove\"|\"none\"}, default `\"none\"`.\n *  - `enforce_type` {\"strict\"|\"loose\"|\"none\"}, default `\"loose\"`.\n *  - `validate` {\"oncreate\"|\"onsave\"}, default \"onsave\".\n */\nThinky.prototype.createModel = function(name, schema, options) {\n  var self = this;\n\n  // Make a deep copy of the options as the model may overwrite them.\n  var fullOptions = util.deepCopy(this._options);\n  options = options || {};\n  util.loopKeys(options, function(options, key) {\n    fullOptions[key] = options[key];\n  });\n\n  // Two models cannot share the same name.\n  if (self.models[name] !== undefined) {\n    throw new Error(\"Cannot redefine a Model\");\n  }\n\n  // Create the constructor returned. This will also validate the schema.\n  var model = Model.new(name, schema, fullOptions, self);\n\n  // Keep a reference of this model.\n  self.models[name] = model;\n  return model;\n}\n\n\n/**\n * Method to clean all the references to the models. This is used to speed up\n * testing and should not be used in other use cases.\n */\nThinky.prototype._clean = function() {\n  this.models = {};\n}\n\n\n// Export the module.\nmodule.exports = function(config) {\n  return new Thinky(config);\n}\n\n// Expose thinky types directly from module\nmodule.exports.type = type;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/thinky.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/any.js":
/*!*********************************************!*\
  !*** ./node_modules/thinky/lib/type/any.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar schema =      __webpack_require__(/*! ./node_modules/thinky/lib/type/../schema.js */ \"./node_modules/thinky/lib/schema.js\");\n\nfunction TypeAny() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\nTypeAny.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n}\nTypeAny.prototype.validator = function(fn) {\n  this._validator = fn;\n}\nTypeAny.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n}\n\n// Dummy methods, just to allow users to easily switch from a valid type to any\nTypeAny.prototype.options = function(options) {\n  return this;\n}\nTypeAny.prototype.optional = function() {\n  return this;\n}\nTypeAny.prototype.required = function() {\n  return this;\n}\nTypeAny.prototype.allowNull = function() {\n  return this;\n}\nTypeAny.prototype.min = function() {\n  return this;\n}\nTypeAny.prototype.max = function() {\n  return this;\n}\nTypeAny.prototype.length = function() {\n  return this;\n}\nTypeAny.prototype.schema = function() {\n  return this;\n}\nTypeAny.prototype.validate = function() {\n  return this;\n}\n\nmodule.exports = TypeAny;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/any.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/array.js":
/*!***********************************************!*\
  !*** ./node_modules/thinky/lib/type/array.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar schema =      __webpack_require__(/*! ./node_modules/thinky/lib/type/../schema.js */ \"./node_modules/thinky/lib/schema.js\");\nvar arrayPrefix = schema.arrayPrefix;\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypeArray() {\n  this._min = -1;\n  this._max = -1;\n  this._length = -1;\n  this._schema = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeArray.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeArray.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeArray.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeArray.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeArray.prototype.min = function(min) {\n  if (min < 0) {\n    throw new Errors.ValidationError(\"The value for `min` must be a positive integer\");\n  }\n  this._min = min;\n  return this;\n}\n\n\nTypeArray.prototype.max = function(max) {\n  if (max < 0) {\n    throw new Errors.ValidationError(\"The value for `max` must be a positive integer\");\n  }\n  this._max = max;\n  return this;\n}\n\n\nTypeArray.prototype.length = function(length) {\n  if (length < 0) {\n    throw new Errors.ValidationError(\"The value for `length` must be a positive integer\");\n  }\n  this._length = length;\n  return this;\n}\n\n\nTypeArray.prototype.schema = function(schema) {\n  this._schema = schema;\n  return this;\n}\n\n\nTypeArray.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeArray.prototype.validator = function(fn) {\n  this._validator = fn;\n  return this;\n}\n\n\nTypeArray.prototype.validate = function(array, prefix, options) {\n  var self = this;\n  var localOptions = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(array, prefix, \"array\", localOptions)) return;\n\n  if ((typeof self._validator === \"function\") && (self._validator(array) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if ((typeof array === 'function') && (array._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if (Array.isArray(array) === false) {\n    if (localOptions.enforce_type === \"strict\") {\n      util.strictType(prefix, \"array\");\n    }\n    else if ((localOptions.enforce_type === \"loose\") && (array !== null)) {\n      util.looseType(prefix, \"array\");\n    }\n  }\n  else {\n    if ((this._min !== -1) && (this._min > array.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must have at least \"+this._min+\" elements.\")\n    }\n    if ((this._max !== -1) && (this._max < array.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must have at most \"+this._max+\" elements.\")\n    }\n    if ((this._length !== -1) && (this._length !== array.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an array with \"+this._length+\" elements.\")\n    }\n\n    for(var i=0; i<array.length; i++) {\n      if (array[i] === undefined) {\n        throw new Errors.ValidationError(\"The element in the array \"+prefix+\" (position \"+i+\") cannot be `undefined`.\");\n      }\n      if (this._schema !== undefined) {\n        this._schema.validate(array[i], prefix+\"[\"+i+\"]\", options);\n      }\n    }\n  }\n}\n\n\nTypeArray.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n  if (this._schema !== undefined) {\n    this._schema._getDefaultFields(prefix.concat(arrayPrefix), defaultFields, virtualFields);\n  }\n}\n\n\nmodule.exports = TypeArray;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/array.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/boolean.js":
/*!*************************************************!*\
  !*** ./node_modules/thinky/lib/type/boolean.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypeBoolean() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeBoolean.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeBoolean.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeBoolean.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeBoolean.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\n\nTypeBoolean.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeBoolean.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeBoolean.prototype.validate = function(bool, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(bool, prefix, \"boolean\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(bool) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if (typeof bool !== \"boolean\") {\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"boolean\");\n    }\n    else if ((options.enforce_type === \"loose\") && (bool !== null)) {\n      util.looseType(prefix, \"boolean\");\n    }\n  }\n}\n\n\nTypeBoolean.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeBoolean;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/boolean.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/thinky/lib/type/buffer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypeBuffer() {\n  this._default = undefined;\n  this._options = {};\n  this._validator = undefined;\n}\n\n\nTypeBuffer.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeBuffer.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeBuffer.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeBuffer.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeBuffer.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeBuffer.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeBuffer.prototype.validate = function(buffer, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(buffer, prefix, \"buffer\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(buffer) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if (util.isPlainObject(buffer) && (buffer[\"$reql_type$\"] === \"BINARY\")) {\n    if (buffer.data === undefined) {\n      util.pseudoTypeError(\"binary\", \"data\", prefix);\n    }\n  }\n  else if ((typeof buffer === 'function') && (buffer._query !== undefined)) {\n    // TOIMPROvE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if ((buffer instanceof Buffer) === false)  { // We don't have a buffer\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"buffer\");\n    }\n    else if ((options.enforce_type === \"loose\") && (buffer !== null)) {\n      util.looseType(prefix, \"buffer\");\n    }\n  }\n}\n\n\nTypeBuffer.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/buffer.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/date.js":
/*!**********************************************!*\
  !*** ./node_modules/thinky/lib/type/date.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypeDate() {\n  this._min = undefined;\n  this._max = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeDate.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeDate.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeDate.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeDate.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeDate.prototype.min = function(min) {\n  this._min = min;\n  return this;\n}\n\n\nTypeDate.prototype.max = function(max) {\n  this._max = max;\n  return this;\n}\n\n\nTypeDate.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeDate.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeDate.prototype.validate = function(date, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(date, prefix, \"date\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(date) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  var jsDate;\n  if (util.isPlainObject(date) && (date[\"$reql_type$\"] === \"TIME\")) {\n    if (date.epoch_time === undefined) {\n      util.pseudoTypeError(\"date\", \"epoch_time\", prefix);\n    }\n    else if (date.timezone === undefined) {\n      util.pseudoTypeError(\"date\", \"timezone\", prefix);\n    }\n\n    jsDate = new Date(0);\n    jsDate.setUTCSeconds(date.epoch_time)\n  }\n  else if ((typeof date === 'function') && (date._query !== undefined)) {\n    // TOIMPROVE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if (typeof date === 'string' || typeof date === 'number') {\n    var numericDate = parseInt(date, 10);\n    if(!isNaN(numericDate)){\n      date = numericDate;\n    }\n    jsDate = new Date(date);\n    if (jsDate.getTime() !== jsDate.getTime()) {\n      if (options.enforce_type === \"strict\") {\n        util.strictType(prefix, \"date or a valid string\");\n      }\n      else if (options.enforce_type !== \"none\") {\n        util.looseType(prefix, \"date or a valid string\");\n      }\n    }\n  }\n  else if ((date instanceof Date) === false) { // We have a non valid date\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"date\");\n    }\n    else if ((options.enforce_type === \"loose\") && (date !== null)) {\n      util.looseType(prefix, \"date\");\n    }\n  }\n  else {\n    jsDate = date;\n  }\n\n  // We check for min/max only if we could create a javascript date from the value\n  if (jsDate !== undefined) {\n    if ((this._min instanceof Date) && (this._min > jsDate)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be after \"+this._min+\".\")\n    }\n    if ((this._max instanceof Date) && (this._max < jsDate)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be before \"+this._max+\".\")\n    }\n  }\n}\n\n\nTypeDate.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeDate;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/date.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/index.js":
/*!***********************************************!*\
  !*** ./node_modules/thinky/lib/type/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var schema =      __webpack_require__(/*! ./node_modules/thinky/lib/type/../schema.js */ \"./node_modules/thinky/lib/schema.js\");\nvar util =        __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar TypeAny =     __webpack_require__(/*! ./node_modules/thinky/lib/type/any.js */ \"./node_modules/thinky/lib/type/any.js\");\nvar TypeArray =   __webpack_require__(/*! ./node_modules/thinky/lib/type/array.js */ \"./node_modules/thinky/lib/type/array.js\");\nvar TypeBoolean = __webpack_require__(/*! ./node_modules/thinky/lib/type/boolean.js */ \"./node_modules/thinky/lib/type/boolean.js\");\nvar TypeBuffer =  __webpack_require__(/*! ./node_modules/thinky/lib/type/buffer.js */ \"./node_modules/thinky/lib/type/buffer.js\");\nvar TypeDate =    __webpack_require__(/*! ./node_modules/thinky/lib/type/date.js */ \"./node_modules/thinky/lib/type/date.js\");\nvar TypeNumber =  __webpack_require__(/*! ./node_modules/thinky/lib/type/number.js */ \"./node_modules/thinky/lib/type/number.js\");\nvar TypeObject =  __webpack_require__(/*! ./node_modules/thinky/lib/type/object.js */ \"./node_modules/thinky/lib/type/object.js\");\nvar TypePoint =   __webpack_require__(/*! ./node_modules/thinky/lib/type/point.js */ \"./node_modules/thinky/lib/type/point.js\");\nvar TypeString =  __webpack_require__(/*! ./node_modules/thinky/lib/type/string.js */ \"./node_modules/thinky/lib/type/string.js\");\nvar TypeVirtual = __webpack_require__(/*! ./node_modules/thinky/lib/type/virtual.js */ \"./node_modules/thinky/lib/type/virtual.js\");\n\n\n/**\n * Create a new Type that let users create sub-types.\n * @return {Type}\n */\nfunction Type() { }\n\n\n/**\n * Create a new TypeAny object\n * @return {TypeAny}\n */\n\nType.prototype.any = function() {\n  return new TypeAny();\n}\n\n\n/**\n * Create a new TypeString object.\n * @return {TypeString}\n */\nType.prototype.string = function() {\n  return new TypeString();\n}\n\n\n/**\n * Create a new TypeNumber object.\n * @return {TypeNumber}\n */\nType.prototype.number = function() {\n  return new TypeNumber();\n}\n\n\n/**\n * Create a new TypeBoolean object.\n * @return {TypeBoolean}\n */\nType.prototype.boolean = function() {\n  return new TypeBoolean();\n}\n\n\n/**\n * Create a new TypeDate object.\n * @return {TypeDate}\n */\nType.prototype.date = function() {\n  return new TypeDate();\n}\n\n\n/**\n * Create a new TypeBuffer object.\n * @return {TypeBuffer}\n */\nType.prototype.buffer = function() {\n  return new TypeBuffer();\n}\n\n\n/**\n * Create a new TypePoint object.\n * @return {TypePoint}\n */\nType.prototype.point = function() {\n  return new TypePoint();\n}\n\n\n/**\n * Create a new TypeObject object.\n * @return {TypeObject}\n */\nType.prototype.object = function() {\n  return new TypeObject();\n}\n\n\n/**\n * Create a new TypeArray object.\n * @return {TypeArray}\n */\nType.prototype.array = function() {\n  return new TypeArray();\n}\n\n\n/**\n * Create a new TypeVirtual object.\n * @return {TypeVirtual}\n */\nType.prototype.virtual = function() {\n  return new TypeVirtual();\n}\n\n\n/**\n * Create a new TypeString object to use as an id.\n * @return {TypeString}\n */\nType.prototype.id = function() {\n  return new TypeString().optional();\n}\n\n\n/**\n * Check if the first argument is a TypeString object or not\n * @param {Object} obj The object to check against TypeString.\n * @return {boolean}\n */\nType.prototype.isString = function(obj) {\n  return obj instanceof TypeString;\n}\n\n\n/**\n * Check if the first argument is a TypeNumber object or not\n * @param {Object} obj The object to check against TypeNumber.\n * @return {boolean}\n */\nType.prototype.isNumber = function(obj) {\n  return obj instanceof TypeNumber;\n}\n\n\n/**\n * Check if the first argument is a TypeBoolean object or not\n * @param {Object} obj The object to check against TypeBoolean.\n * @return {boolean}\n */\nType.prototype.isBoolean = function(obj) {\n  return obj instanceof TypeBoolean;\n}\n\n\n/**\n * Check if the first argument is a TypeDate object or not\n * @param {Object} obj The object to check against TypeDate.\n * @return {boolean}\n */\nType.prototype.isDate = function(obj) {\n  return obj instanceof TypeDate;\n}\n\n\n/**\n * Check if the first argument is a TypeBuffer object or not\n * @param {Object} obj The object to check against TypeBuffer.\n * @return {boolean}\n */\nType.prototype.isBuffer = function(obj) {\n  return obj instanceof TypeBuffer;\n}\n\n\n/**\n * Check if the first argument is a TypePoint object or not\n * @param {Object} obj The object to check against TypePoint.\n * @return {boolean}\n */\nType.prototype.isPoint = function(obj) {\n  return obj instanceof TypePoint;\n}\n\n\n/**\n * Check if the first argument is a TypeObject object or not\n * @param {Object} obj The object to check against TypeObject.\n * @return {boolean}\n */\nType.prototype.isObject = function(obj) {\n  return obj instanceof TypeObject;\n}\n\n\n/**\n * Check if the first argument is a TypeArray object or not\n * @param {Object} obj The object to check against TypeArray.\n * @return {boolean}\n */\nType.prototype.isArray = function(obj) {\n  return obj instanceof TypeArray;\n}\n\n\n/**\n * Check if the first argument is a TypeVirtual object or not\n * @param {Object} obj The object to check against TypeVirtual.\n * @return {boolean}\n */\nType.prototype.isVirtual = function(obj) {\n  return obj instanceof TypeVirtual;\n}\n\n\n/**\n * Check if the first argument is a TypeAny object or not\n * @param {Object} obj The object to check against TypeAny.\n * @return {boolean}\n */\nType.prototype.isAny = function(obj) {\n  return obj instanceof TypeAny;\n}\n\n\nmodule.exports = new Type();\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/index.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/number.js":
/*!************************************************!*\
  !*** ./node_modules/thinky/lib/type/number.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypeNumber() {\n  this._min = undefined;\n  this._max = undefined;\n  this._integer = false;\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeNumber.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeNumber.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeNumber.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeNumber.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\n\nTypeNumber.prototype.min = function(min) {\n  if ((typeof(min) !== 'number') || (isFinite(min) == false)) {\n    throw new Errors.ValidationError(\"The value for `min` must be a finite number\");\n  }\n  this._min = min;\n  return this;\n}\n\n\nTypeNumber.prototype.max = function(max) {\n  if ((typeof(max) !== 'number') || (isFinite(max) == false)) {\n    throw new Errors.ValidationError(\"The value for `max` must be a finite number\");\n  }\n  this._max = max;\n  return this;\n}\n\n\nTypeNumber.prototype.integer = function() {\n  this._integer = true;\n  return this;\n}\n\n\nTypeNumber.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeNumber.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeNumber.prototype.validate = function(number, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(number, prefix, \"number\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(number) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if(typeof number === 'string'){\n    var numericString = parseFloat(number);\n    if(!isNaN(numericString)){\n      number = numericString;\n    }\n  }\n\n  if ((typeof number === 'function') && (number._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if ((typeof number !== \"number\") || (isFinite(number) === false)) {\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"finite number\");\n    }\n    else if ((options.enforce_type === \"loose\") && (number !== null)) {\n      util.looseType(prefix, \"finite number\");\n    }\n  }\n  else {\n    if ((this._min !== undefined) && (this._min > number)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be greater than or equal to \"+this._min+\".\")\n    }\n    if ((this._max !== undefined) && (this._max < number)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be less than or equal to \"+this._max+\".\")\n    }\n    if ((this._integer === true) && (number % 1 !== 0)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an integer.\")\n    }\n  }\n}\n\n\nTypeNumber.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeNumber;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/number.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/object.js":
/*!************************************************!*\
  !*** ./node_modules/thinky/lib/type/object.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypeObject() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n  this._schema = {};\n}\n\n\nTypeObject.prototype._setModel = function(model) {\n  this._model = model;\n  return this;\n}\n\n\nTypeObject.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeObject.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeObject.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeObject.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeObject.prototype.allowExtra = function(allowed) {\n  if (allowed === true) {\n    this._options.enforce_extra = 'none';\n  }\n  else if (allowed === false) {\n    this._options.enforce_extra = 'strict';\n  }\n  return this;\n}\n\n\nTypeObject.prototype.removeExtra = function() {\n  this._options.enforce_extra = 'remove';\n  return this;\n}\n\n\nTypeObject.prototype.schema = function(schema) {\n  // Users shouldn't use the deprecated syntax with the chainable one\n  // We do not parse the schema as we don't have the current prefix, options etc.\n  this._schema = schema;\n  return this;\n}\n\n\nTypeObject.prototype.setKey = function(key, schema) {\n  this._schema[key] = schema;\n  return this;\n}\n\n\nTypeObject.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeObject.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeObject.prototype.validate = function(object, prefix, options) {\n  var self = this;\n  var localOptions = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(object, prefix, \"object\", localOptions)) return;\n\n  if ((typeof self._validator === \"function\") && (self._validator(object) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if ((typeof object === 'function') && (object._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if (util.isPlainObject(object) === false) {\n    if (localOptions.enforce_type === \"strict\") {\n      util.strictType(prefix, \"object\");\n    }\n    else if ((localOptions.enforce_type === \"loose\") && (object !== null)) {\n      util.looseType(prefix, \"object\");\n    }\n  }\n  else {\n    util.loopKeys(self._schema, function(schema, key) {\n      schema[key].validate(object[key], prefix+\"[\"+key+\"]\", options);\n    });\n\n    // We clean extra fields in validate, for a use case, see:\n    // https://github.com/neumino/thinky/pull/123#issuecomment-56254682\n    if (localOptions.enforce_extra === \"remove\") {\n      util.loopKeys(object, function(object, key) {\n        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)\n            && (self._schema[key] === undefined)) {\n          delete object[key];\n        }\n      });\n    }\n    else if (localOptions.enforce_extra === \"strict\") {\n      util.loopKeys(object, function(object, key) {\n        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)\n            && (self._schema[key] === undefined)) {\n          util.extraField(prefix, key);\n        }\n      });\n    }\n  }\n}\n\n\nTypeObject.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n  if (this._schema !== undefined) {\n    util.loopKeys(this._schema, function(_schema, key) {\n      if (typeof _schema[key]._getDefaultFields !== 'function') {\n        console.log(_schema);\n        console.log(key);\n        console.log(_schema[key]);\n      }\n      _schema[key]._getDefaultFields(prefix.concat(key), defaultFields, virtualFields);\n    })\n  }\n}\n\n\nmodule.exports = TypeObject;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/object.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/point.js":
/*!***********************************************!*\
  !*** ./node_modules/thinky/lib/type/point.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\nfunction TypePoint() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypePoint.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypePoint.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypePoint.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypePoint.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypePoint.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypePoint.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n   this._validator = fn;\n  }\n  return this;\n}\n\n\nTypePoint.prototype.validate = function(point, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(point, prefix, \"point\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(point) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if (util.isPlainObject(point) && (point[\"$reql_type$\"] === \"GEOMETRY\")) {\n    if (point.type === undefined) {\n      util.pseudoTypeError(\"Point\", \"type\", prefix);\n    }\n    else if (point.type !== \"Point\") {\n      throw new Errors.ValidationError(\"The field `type` for \"+prefix+\" must be `'Point'`.\")\n    }\n    else if (point.coordinates === undefined) {\n      util.pseudoTypeError(\"date\", \"coordinates\", prefix);\n    }\n    else if ((!Array.isArray(point.coordinates)) || (point.coordinates.length !== 2)) {\n      throw new Errors.ValidationError(\"The field `coordinates` for \"+prefix+\" must be an Array of two numbers.\")\n    }\n  }\n  else if (util.isPlainObject(point) && (point.type === \"Point\") && (Array.isArray(point.coordinates)) && (point.coordinates.length === 2)) { // Geojson\n    // Geojson format\n  }\n  else if ((typeof point === 'function') && (point._query !== undefined)) {\n    // TOIMPROvE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if (util.isPlainObject(point)) {\n    var keys = Object.keys(point).sort();\n    if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof point.latitude !== \"number\") || (typeof point.longitude !== \"number\")) {\n      throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n    }\n    else if ((typeof point.latitude !== 'number') || (typeof point.latitude !== 'number')) {\n      throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n    }\n  }\n  else if (Array.isArray(point)) {\n    if ((point.length !== 2) || (typeof point[0] !== \"number\") || (typeof point[1] !== \"number\")) {\n      throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n    }\n  }\n  else { // We don't have a point\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"Point\");\n    }\n    else if ((options.enforce_type === \"loose\") && (point !== null)) {\n      util.looseType(prefix, \"Point\");\n    }\n  }\n}\n\n\nTypePoint.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\nmodule.exports = TypePoint;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/point.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/string.js":
/*!************************************************!*\
  !*** ./node_modules/thinky/lib/type/string.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util =       __webpack_require__(/*! ./node_modules/thinky/lib/type/../util.js */ \"./node_modules/thinky/lib/util.js\");\nvar validator =  __webpack_require__(/*! validator */ \"./node_modules/validator/validator.js\");\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/type/../errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\n/**\n * Create a new TypeString object\n */\nfunction TypeString() {\n  /**\n   * Minimum length of the string, negative if no minimum length is required.\n   * @type {number}\n   */\n  this._min = -1;\n  /**\n   * Maximum length of the string, negative if no maximum length is required.\n   * @type {number}\n   */\n  this._max = -1;\n  /**\n   * Length of the string, negative if no length is required.\n   * @type {number}\n   */\n  this._length = -1;\n  /**\n   * Whether the string must be alphanumeric or not. We used the npm validator\n   * package, and as 2014/12/14, it check against the regex [a-zA-Z0-9]\n   * @type {boolean}\n   */\n  this._alphanum = false;\n  /**\n   * Whether this string must be uppercase or not.\n   * @type {boolean}\n   */\n  this._uppercase = false;\n  /**\n   * Whether this string must be lowercase or not.\n   * @type {boolean}\n   */\n  this._lowercase = false;\n  /*\n   * The regex against which the string must conform. Undefined if the string\n   * does not have to conform to a RegExp.\n   * @type {RegExp=}\n   */\n  this._regex = undefined;\n  /**\n   * The validator called with the string must return {true} if the string is valid,\n   * {false} if the string is not.\n   * @type {function(string)=}\n   */\n  this._enum = undefined;\n  /**\n   * The default value for this field or a function to generate the default value.\n   * @type {function|string}\n   */\n  this._default = undefined;\n  /**\n   * Whether this string must be a uuid or not.\n   * @type {number}\n   */\n  this._uuid = undefined;\n  /**\n   * Options for this type \"enforce_missing\", \"enforce_type\", \"enforce_extra\"\n   * @type {Object=}\n   */\n  this._validator = undefined;\n  /**\n   * An object whose keys are the acceptable values for the string. Undefined if this\n   * is not a requirement.\n   * @type {Object=}\n   */\n  this._options = {};\n}\n\n\n/**\n * Set the options for this field.\n * @param {!object} options The options for this field. The valid fields are:\n *  - `enforce_missing` {boolean}, default `false`\n *  - `enforce_extra` {\"strict\"|\"remove\"|\"none\"}, default `\"none\"`\n *  - `enforce_type` {\"strict\"|\"loose\"|\"none\"}, default `\"loose\"`\n * @return {TypeString}\n */\nTypeString.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\n/**\n * Set the property as optional (enforce_missing = false).\n * Leaves other existing options unchanged.\n * @return {TypeString}\n */\nTypeString.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\n/**\n * Set the property as required (enforce_missing = true).\n * Leaves other existing options unchanged.\n * @return {TypeString}\n */\nTypeString.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\n/**\n * Set the property as not strict (null allowed, enforce_missing = true).\n * Leaves other existing options unchanged.\n * @return {TypeString}\n */\nTypeString.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\n/**\n * Set the minimum length allowed for a string.\n * @param {number} min Minimum length for the string\n * @return {TypeString}\n */\nTypeString.prototype.min = function(min) {\n  if (min < 0) {\n    throw new Errors.ValidationError(\"The value for `min` must be a positive integer\");\n  }\n  this._min = min;\n  return this;\n}\n\n\n/**\n * Set the maximum length allowed for a string.\n * @param {number} min Minimum length for the string\n * @return {TypeString}\n */\nTypeString.prototype.max = function(max) {\n  if (max < 0) {\n    throw new Errors.ValidationError(\"The value for `max` must be a positive integer\");\n  }\n  this._max = max;\n  return this;\n}\n\n\n/**\n * Set the length allowed for a string.\n * @param {number} min Minimum length for the string\n * @return {TypeString}\n */\nTypeString.prototype.length = function(length) {\n  if (length < 0) {\n    throw new Errors.ValidationError(\"The value for `length` must be a positive integer\");\n  }\n  this._length = length;\n  return this;\n}\n\n\n/**\n * Set the regex that the string must match.\n * @param {string} regex The string representation of the regex\n * @param {string} flags The flags used when calling new RegExp(...)\n * @return {TypeString}\n */\nTypeString.prototype.regex = function(regex, flags) {\n  if (typeof flags === \"string\") {\n    this._regex = new RegExp(regex, flags);\n  }\n  else {\n    this._regex = new RegExp(regex);\n  }\n  return this;\n}\n\n\n/**\n * Set the string to be alphanumeric.\n * @return {TypeString}\n */\nTypeString.prototype.alphanum = function() {\n  this._alphanum = true;\n  return this;\n}\n\n\n/**\n * Set the string to be an email.\n * @return {TypeString}\n */\nTypeString.prototype.email = function() {\n  this._email = true;\n  return this;\n}\n\n\n/**\n * Set the string to be lowercase.\n * @return {TypeString}\n */\nTypeString.prototype.lowercase = function() {\n  this._lowercase = true;\n  return this;\n}\n\n\n/**\n * Set the string to be uppercase.\n * @return {TypeString}\n */\nTypeString.prototype.uppercase = function() {\n  this._uppercase = true;\n  return this;\n}\n\n\n/**\n * Set the default value for this string, or the function that will generate\n * the default value\n * @param {string|function} fnOrValue\n * @return {TypeString}\n */\nTypeString.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n/**\n * Set the string to be a uuid.\n * @param {number} version\n * @return {TypeString}\n */\nTypeString.prototype.uuid = function(version) {\n  if (isNaN(version)) {\n    throw new Errors.ValidationError(\"The value for `version` must be a number.\");\n  }\n  if (version < 3 || version > 5) {\n    throw new Errors.ValidationError(\"The value for `version` must be either 3, 4 or 5\");\n  }\n  this._uuid = version;\n  return this;\n}\n\n\n/**\n * Set a custom validator that will be called with the string. The validator\n * should return a boolean whether the field is valid or not.\n * @param {function} fn\n * @return {TypeString}\n */\nTypeString.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\n/**\n * Set the valid values for this field. The arguments must be strings\n * or an array of strings.\n * @param {...string|Array.<string>} fn\n * @return {TypeString}\n */\nTypeString.prototype.enum = function() {\n  if ((arguments.length === 1) && (Array.isArray(arguments[0]))) {\n    this._enum = {};\n    for(var i=0; i<arguments[0].length; i++) {\n      this._enum[arguments[0][i]] = true;\n    }\n  }\n  else if ((arguments.length !== 1) || (arguments[0] !== undefined)) {\n    this._enum = {};\n    for(var i=0; i<arguments.length; i++) {\n      this._enum[arguments[i]] = true;\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate the string given optional options, and throw an error in case\n * the field is not valid.\n * @param {string} str The string to validate.\n * @param {string} prefix The prefix leading to `str`.\n * @param {object=} options Options to overwrite the one defined for the field.\n * @throws {Error}\n */\nTypeString.prototype.validate = function(str, prefix, options) {\n  var _options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(str, prefix, \"string\", _options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(str) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n\n  if ((typeof str === 'function') && (str._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if (typeof str !== \"string\") {\n    if (_options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"string\");\n    }\n    else if ((_options.enforce_type === \"loose\") && (str !== null)) {\n      util.looseType(prefix, \"string\");\n    }\n  }\n  else {\n    if ((this._min !== -1) && (this._min > str.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must not be shorter than \"+this._min+\".\")\n    }\n    if ((this._max !== -1) && (this._max < str.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must not be longer than \"+this._max+\".\")\n    }\n    if ((this._length !== -1) && (this._length !== str.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a string with \"+this._length+\" characters.\")\n    }\n    if ((this._regex instanceof RegExp) && (this._regex.test(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must match the regex.\")\n    }\n    if ((this._alphanum === true) && (validator.isAlphanumeric(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an alphanumeric string.\")\n    }\n    if ((this._email === true) && (validator.isEmail(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a valid email.\")\n    }\n    if ((this._lowercase === true) && (validator.isLowercase(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a lowercase string.\")\n    }\n    if ((this._uppercase === true) && (validator.isUppercase(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a uppercase string.\")\n    }\n    if ((this._uuid !== undefined) && (validator.isUUID(str, this._uuid) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a uuid string.\")\n    }\n    if ((this._enum !== undefined) && (this._enum[str] !== true)) {\n      var validValues = Object.keys(this._enum);\n      var message = \"The field \"+prefix+\" must be one of these values: \"\n\n      for(var i=0; i<validValues.length; i++) {\n        if (i === 10) { break; }\n        if ((i === validValues.length-1) || (i === 9)) {\n          message = message+validValues[i]\n        }\n        else {\n          message = message+validValues[i]+\", \"\n        }\n      }\n      if (validValues.length > 10) {\n        message = message+\"...\"\n      }\n      else {\n        message = message+\".\"\n      }\n\n      throw new Errors.ValidationError(message);\n    }\n  }\n}\n\n\n/**\n * Look for a default value or default function, and append an object to `defaultFields`.\n * @param {string} prefix The prefix leading to `str`.\n * @param {Array.<Object>} defaultFields The default fields to generate\n * @param {Array.<Object>} virtualFields The virtual fields to generate\n * @return {TypeString}\n */\nTypeString.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n  return this;\n}\n\n\nmodule.exports = TypeString;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/string.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/type/virtual.js":
/*!*************************************************!*\
  !*** ./node_modules/thinky/lib/type/virtual.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function TypeVirtual() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeVirtual.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\n// Dummy functions\nTypeVirtual.prototype.validate = function() {}\n\n\nTypeVirtual.prototype.options = function() {}\n\n\nTypeVirtual.prototype.optional = function() {}\n\n\nTypeVirtual.prototype.required = function() {}\n\n\nTypeVirtual.prototype.allowNull = function() {}\n\n\nTypeVirtual.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  // We keep track of virtual fields even if there is no default value\n  virtualFields.push({\n    path: prefix,\n    value: this._default,\n  });\n}\n\nmodule.exports = TypeVirtual;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/type/virtual.js?");

/***/ }),

/***/ "./node_modules/thinky/lib/util.js":
/*!*****************************************!*\
  !*** ./node_modules/thinky/lib/util.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = {};\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/main/bluebird.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Errors = __webpack_require__(/*! ./node_modules/thinky/lib/errors.js */ \"./node_modules/thinky/lib/errors.js\");\n\n/**\n * Random useful methods used everywhere.\n */\n\n\n/**\n * Is `obj` a plain object.\n * @return {boolean}\n */\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\nutil.isPlainObject = isPlainObject;\n\n\n/**\n * Make a \"deep copy\".\n * The prototype chain is not copied.\n */\nfunction deepCopy(value) {\n  var result;\n  if (value instanceof Buffer) {\n    // isPlainObject(buffer) returns true.\n    return new Buffer(value);\n  }\n\n  if (isPlainObject(value) === true) {\n    result = {};\n    loopKeys(value, function(_value, key) {\n      if (_value.hasOwnProperty(key)) {\n        result[key] = deepCopy(_value[key]);\n      }\n    });\n    return result;\n  }\n\n  if (Array.isArray(value)) {\n    result = []\n    for(var i=0; i<value.length; i++) {\n      result.push(deepCopy(value[i]));\n    }\n    return result;\n  }\n\n  return value;\n}\nutil.deepCopy = deepCopy;\n\n\n/**\n * Wrap try/catch for v8\n */\nfunction tryCatch(toTry, handleError) {\n  try{\n    toTry()\n  }\n  catch(err) {\n    handleError(err)\n  }\n}\nutil.tryCatch = tryCatch;\n\n\n/**\n * Return a promise if a hook is asynchronous\n * Note: If no hook is asynchronous, `fn` can still be asynchronous in which\n * case we return a promise or undefined\n * @param {Object} options, the arguments are:\n * - preHooks {Array} the methods to execute before the main one\n * - postHooks {Array} the methods to execute after the main one\n * - async {boolean} whether this this hook is asynchronous or not\n * - doc {Document} the document that triggered the hooks\n * - fn {Function} the main function\n * - fnArgs {Array} arguments for `fn`\n * @return {Promise=}\n */\nfunction hook(options) {\n  var preHooks = options.preHooks;\n  if (Array.isArray(preHooks) === false) {\n    preHooks = [];\n  }\n  var postHooks = options.postHooks;\n  if (Array.isArray(postHooks) === false) {\n    postHooks = [];\n  }\n  var doc = options.doc; // We need the doc to set the context of the hooks\n  var async = options.async || false;\n  var fn = options.fn; // The function that we are hook\n  var fnArgs = options.fnArgs;\n\n  if (async === true) {\n    return new Promise(function(resolve, reject) {\n      _asyncHook({\n        resolve: resolve,\n        reject: reject,\n        preHooks: preHooks,\n        postHooks: postHooks,\n        doc: doc,\n        fn: fn,\n        fnArgs: fnArgs\n      });\n    });\n  }\n\n  return _syncHook({\n    preHooks: preHooks,\n    postHooks: postHooks,\n    doc: doc,\n    fn: fn,\n    fnArgs: fnArgs\n  });\n}\nfunction _syncHook(args) {\n  var preHooks = args.preHooks;\n  var postHooks = args.postHooks;\n  var fn = args.fn;\n  var doc = args.doc;\n  var fnArgs = args.fnArgs;\n\n  for(var i=0; i<preHooks.length; i++) {\n    preHooks[i].call(doc);\n  }\n  var result = fn.apply(doc, fnArgs);\n  for(var j=0; j<postHooks.length; j++) {\n    postHooks[j].call(doc);\n  }\n  return result;\n}\nfunction _asyncHook(args) {\n  // One of the hook, or the function is asynchronous, so we will\n  // always return a promise\n  // We only need to keep track of the result return/resolved for fn\n\n  var preHooks = args.preHooks;\n  var postHooks = args.postHooks;\n  var fn = args.fn;\n  var fnArgs = args.fnArgs;\n  var doc = args.doc;\n  var resolve = args.resolve;\n  var reject = args.reject;\n  var args = args.args;\n\n  var result;\n\n  var nextPost = function() {\n    if (typeof resolve === \"function\") {\n      resolve(result);\n    }\n    return result;\n  }\n\n  var executeMain = function() {\n    result = fn.apply(doc, fnArgs);\n    if (result instanceof Promise) {\n      return result.then(function(res) {\n        result = res;\n        executeHooks(0, postHooks, doc, reject, nextPost);\n      }).error(reject);\n    }\n    return executeHooks(0, postHooks, doc, reject, nextPost);\n  }\n\n  var nextPre = function() {\n    tryCatch(executeMain, function (err) {\n      return reject(err);\n    });\n  }\n  return executeHooks(0, preHooks, doc, reject, nextPre);\n}\nutil.hook = hook;\n\nfunction executeHooks(hookIndex, hooks, doc, reject, next) {\n  if (hookIndex < hooks.length) {\n    if (hooks[hookIndex].length === 1) {\n      hooks[hookIndex].call(doc, function(err) {\n        if (err) return reject(err);\n        executeHooks(hookIndex+1, hooks, doc, reject, next)\n      });\n    }\n    else {\n      hooks[hookIndex].call(doc);\n      executeHooks(hookIndex+1, hooks, doc, reject, next)\n    }\n  }\n  else {\n    next();\n  }\n}\n\nfunction loopKeys(obj, fn) {\n  if (isPlainObject(obj)) {\n    var keys = Object.keys(obj);\n    var result;\n    for(var i=0; i<keys.length; i++) {\n      result = fn(obj, keys[i]);\n      if (result === false) return;\n    }\n  }\n}\nutil.loopKeys = loopKeys;\n\nfunction changeProto(object, newProto) {\n  object.__proto__ = newProto;\n}\nutil.changeProto = changeProto;\n\nfunction recurse(key, joins, modelTo, all, done) {\n  return (util.isPlainObject(modelTo) && modelTo.hasOwnProperty(key))\n    || ((all === true) && (done[joins[key].model.getTableName()] !== true))\n}\nutil.recurse = recurse;\n\nfunction bindEmitter(self) {\n  util.loopKeys(EventEmitter.prototype, function(emitter, key) {\n    var fn = emitter[key];\n    if (typeof fn === 'function') {\n      self[key] = function() {\n        var args = new Array(arguments.length);\n        for(var i = 0; i < arguments.length; i++) {\n          args[i] = arguments[i];\n        }\n        fn.apply(self, args);\n      }\n    }\n  });\n}\nutil.bindEmitter = bindEmitter;\n\nfunction mergeOptions(options, newOptions) {\n  if (util.isPlainObject(newOptions)) {\n    if (!options) {\n      options = {};\n    }\n    var localOptions = {};\n    localOptions.enforce_missing = (newOptions.enforce_missing != null) ? newOptions.enforce_missing : options.enforce_missing;\n    localOptions.enforce_type = (newOptions.enforce_type != null) ? newOptions.enforce_type : options.enforce_type;\n    localOptions.enforce_extra = (newOptions.enforce_extra != null) ? newOptions.enforce_extra : options.enforce_extra;\n    return localOptions;\n  }\n  return options;\n}\nutil.mergeOptions = mergeOptions;\n\nfunction extractPrimaryKey(oldValue, newValue, primaryKey) {\n  var primaryKey;\n  if (oldValue !== null) {\n    return oldValue[primaryKey];\n  }\n  if (newValue !== null) {\n    return newValue[primaryKey];\n  }\n  return undefined;\n}\nutil.extractPrimaryKey = extractPrimaryKey;\n\n\nfunction undefinedField(prefix) {\n  throw new Errors.ValidationError(\"Value for \"+prefix+\" must be defined.\")\n}\nutil.undefinedField = undefinedField;\n\n\nvar vowels = {a: true, e: true, i: true, o: true, u: true};\nfunction strictType(prefix, expected) {\n  if ((expected.length > 0) && (vowels[expected[0]])) {\n    throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an \"+expected+\".\")\n  }\n  throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a \"+expected+\".\")\n}\nutil.strictType = strictType;\n\n\nfunction extraField(prefix, key) {\n  if (prefix === '') {\n    throw new Errors.ValidationError(\"Extra field `\"+key+\"` not allowed.\")\n  }\n  throw new Errors.ValidationError(\"Extra field `\"+key+\"` in \"+prefix+\" not allowed.\")\n}\nutil.extraField = extraField;\n\n\nfunction looseType(prefix, expected) {\n  if ((expected.length > 0) && (vowels[expected[0]])) {\n    throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an \"+expected+\" or null.\")\n  }\n  throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a \"+expected+\" or null.\")\n}\nutil.looseType = looseType;\n\n\nfunction pseudoTypeError(type, missingField, prefix) {\n  throw new Errors.ValidationError(\"The raw \"+type+\" object for \"+prefix+\" is missing the required field \"+missingField+\".\")\n}\nutil.pseudoTypeError = pseudoTypeError;\n\n\n// Return true if doc is undefined, else false\nfunction validateIfUndefined(value, prefix, type, options) {\n  if (value === undefined) {\n    if (options.enforce_missing === true) {\n      undefinedField(prefix);\n    }\n    return true;\n  }\n  return false;\n}\nutil.validateIfUndefined = validateIfUndefined;\n\nfunction toArray(args) {\n    return Array.prototype.slice.call(args);\n}\nutil.toArray = toArray;\n\nmodule.exports = util;\n\n\n//# sourceURL=webpack:///./node_modules/thinky/lib/util.js?");

/***/ }),

/***/ "./node_modules/validator/validator.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/validator.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Copyright (c) 2014 Chris O'Hara <cohara87@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n(function (name, definition) {\n    if (true) {\n        module.exports = definition();\n    } else {}\n})('validator', function (validator) {\n\n    'use strict';\n\n    validator = { version: '3.34.0' };\n\n    var emailAddress = /((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))/;\n    var displayName = /([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\.]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\.]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|\\s)*/;\n\n    var email = new RegExp('^' + emailAddress.source + '$', 'i');\n    var emailWithDisplayName = new RegExp('^' + displayName.source + '<' + emailAddress.source + '>$', 'i');\n\n    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/;\n\n    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;\n\n    var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/\n      , isbn13Maybe = /^(?:[0-9]{13})$/;\n\n    var ipv4Maybe = /^(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)$/\n      , ipv6Block = /^[0-9A-F]{1,4}$/i;\n\n    var uuid = {\n        '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i\n      , '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i\n      , '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i\n      , all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i\n    };\n\n    var alpha = /^[a-zA-Z]+$/\n      , alphanumeric = /^[a-zA-Z0-9]+$/\n      , numeric = /^[-+]?[0-9]+$/\n      , int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/\n      , float = /^(?:[-+]?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$/\n      , hexadecimal = /^[0-9a-fA-F]+$/\n      , hexcolor = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;\n\n    var ascii = /^[\\x00-\\x7F]+$/\n      , multibyte = /[^\\x00-\\x7F]/\n      , fullWidth = /[^\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/\n      , halfWidth = /[\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\n\n    var surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n\n    var base64 = /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=|[A-Za-z0-9+\\/]{4})$/;\n\n    var phones = {\n      'zh-CN': /^(\\+?0?86\\-?)?1[345789]\\d{9}$/,\n      'en-ZA': /^(\\+?27|0)\\d{9}$/,\n      'en-AU': /^(\\+?61|0)4\\d{8}$/,\n      'en-HK': /^(\\+?852\\-?)?[569]\\d{3}\\-?\\d{4}$/,\n      'fr-FR': /^(\\+?33|0)[67]\\d{8}$/,\n      'pt-PT': /^(\\+351)?9[1236]\\d{7}$/,\n      'el-GR' : /^(\\+30)?((2\\d{9})|(69\\d{8}))$/\n    };\n\n    validator.extend = function (name, fn) {\n        validator[name] = function () {\n            var args = Array.prototype.slice.call(arguments);\n            args[0] = validator.toString(args[0]);\n            return fn.apply(validator, args);\n        };\n    };\n\n    //Right before exporting the validator object, pass each of the builtins\n    //through extend() so that their first argument is coerced to a string\n    validator.init = function () {\n        for (var name in validator) {\n            if (typeof validator[name] !== 'function' || name === 'toString' ||\n                    name === 'toDate' || name === 'extend' || name === 'init') {\n                continue;\n            }\n            validator.extend(name, validator[name]);\n        }\n    };\n\n    validator.toString = function (input) {\n        if (typeof input === 'object' && input !== null && input.toString) {\n            input = input.toString();\n        } else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {\n            input = '';\n        } else if (typeof input !== 'string') {\n            input += '';\n        }\n        return input;\n    };\n\n    validator.toDate = function (date) {\n        if (Object.prototype.toString.call(date) === '[object Date]') {\n            return date;\n        }\n        date = Date.parse(date);\n        return !isNaN(date) ? new Date(date) : null;\n    };\n\n    validator.toFloat = function (str) {\n        return parseFloat(str);\n    };\n\n    validator.toInt = function (str, radix) {\n        return parseInt(str, radix || 10);\n    };\n\n    validator.toBoolean = function (str, strict) {\n        if (strict) {\n            return str === '1' || str === 'true';\n        }\n        return str !== '0' && str !== 'false' && str !== '';\n    };\n\n    validator.equals = function (str, comparison) {\n        return str === validator.toString(comparison);\n    };\n\n    validator.contains = function (str, elem) {\n        return str.indexOf(validator.toString(elem)) >= 0;\n    };\n\n    validator.matches = function (str, pattern, modifiers) {\n        if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {\n            pattern = new RegExp(pattern, modifiers);\n        }\n        return pattern.test(str);\n    };\n\n    var default_email_options = {\n        allow_display_name: false\n    };\n\n    validator.isEmail = function (str, options) {\n        options = merge(options, default_email_options);\n\n        return email.test(str) || (options.allow_display_name === true && emailWithDisplayName.test(str));\n    };\n\n    var default_url_options = {\n        protocols: [ 'http', 'https', 'ftp' ]\n      , require_tld: true\n      , require_protocol: false\n      , allow_underscores: false\n      , allow_trailing_dot: false\n      , allow_protocol_relative_urls: false\n    };\n\n    validator.isURL = function (url, options) {\n        if (!url || url.length >= 2083) {\n            return false;\n        }\n        if (url.indexOf('mailto:') === 0) {\n            return false;\n        }\n        options = merge(options, default_url_options);\n        var protocol, user, pass, auth, host, hostname, port,\n            port_str, path, query, hash, split;\n        split = url.split('://');\n        if (split.length > 1) {\n            protocol = split.shift();\n            if (options.protocols.indexOf(protocol) === -1) {\n                return false;\n            }\n        } else if (options.require_protocol) {\n            return false;\n        }  else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {\n            split[0] = url.substr(2);\n        }\n        url = split.join('://');\n        split = url.split('#');\n        url = split.shift();\n        hash = split.join('#');\n        if (hash && /\\s/.test(hash)) {\n            return false;\n        }\n        split = url.split('?');\n        url = split.shift();\n        query = split.join('?');\n        if (query && /\\s/.test(query)) {\n            return false;\n        }\n\n        split = url.split('/');\n        url = split.shift();\n        path = split.join('/');\n        if (path && /\\s/.test(path)) {\n            return false;\n        }\n        split = url.split('@');\n        if (split.length > 1) {\n            auth = split.shift();\n            if (auth.indexOf(':') >= 0) {\n                auth = auth.split(':');\n                user = auth.shift();\n                if (!/^\\S+$/.test(user)) {\n                    return false;\n                }\n                pass = auth.join(':');\n                if (!/^\\S*$/.test(user)) {\n                    return false;\n                }\n            }\n        }\n        hostname = split.join('@');\n        split = hostname.split(':');\n        host = split.shift();\n        if (split.length) {\n            port_str = split.join(':');\n            port = parseInt(port_str, 10);\n            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n                return false;\n            }\n        }\n        if (!validator.isIP(host) && !validator.isFQDN(host, options) &&\n                host !== 'localhost') {\n            return false;\n        }\n        if (options.host_whitelist &&\n                options.host_whitelist.indexOf(host) === -1) {\n            return false;\n        }\n        if (options.host_blacklist &&\n                options.host_blacklist.indexOf(host) !== -1) {\n            return false;\n        }\n        return true;\n    };\n\n    validator.isIP = function (str, version) {\n        version = validator.toString(version);\n        if (!version) {\n            return validator.isIP(str, 4) || validator.isIP(str, 6);\n        } else if (version === '4') {\n            if (!ipv4Maybe.test(str)) {\n                return false;\n            }\n            var parts = str.split('.').sort(function (a, b) {\n                return a - b;\n            });\n            return parts[3] <= 255;\n        } else if (version === '6') {\n            var blocks = str.split(':');\n            var foundOmissionBlock = false; // marker to indicate ::\n\n            if (blocks.length > 8)\n                return false;\n\n            // initial or final ::\n            if (str === '::') {\n                return true;\n            } else if (str.substr(0, 2) === '::') {\n                blocks.shift();\n                blocks.shift();\n                foundOmissionBlock = true;\n            } else if (str.substr(str.length - 2) === '::') {\n                blocks.pop();\n                blocks.pop();\n                foundOmissionBlock = true;\n            }\n\n            for (var i = 0; i < blocks.length; ++i) {\n                // test for a :: which can not be at the string start/end\n                // since those cases have been handled above\n                if (blocks[i] === '' && i > 0 && i < blocks.length -1) {\n                    if (foundOmissionBlock)\n                        return false; // multiple :: in address\n                    foundOmissionBlock = true;\n                } else if (!ipv6Block.test(blocks[i])) {\n                    return false;\n                }\n            }\n\n            if (foundOmissionBlock) {\n                return blocks.length >= 1;\n            } else {\n                return blocks.length === 8;\n            }\n        }\n        return false;\n    };\n\n    var default_fqdn_options = {\n        require_tld: true\n      , allow_underscores: false\n      , allow_trailing_dot: false\n    };\n\n    validator.isFQDN = function (str, options) {\n        options = merge(options, default_fqdn_options);\n\n        /* Remove the optional trailing dot before checking validity */\n        if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n            str = str.substring(0, str.length - 1);\n        }\n        var parts = str.split('.');\n        if (options.require_tld) {\n            var tld = parts.pop();\n            if (!parts.length || !/^([a-z\\u00a1-\\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n                return false;\n            }\n        }\n        for (var part, i = 0; i < parts.length; i++) {\n            part = parts[i];\n            if (options.allow_underscores) {\n                if (part.indexOf('__') >= 0) {\n                    return false;\n                }\n                part = part.replace(/_/g, '');\n            }\n            if (!/^[a-z\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n                return false;\n            }\n            if (part[0] === '-' || part[part.length - 1] === '-' ||\n                    part.indexOf('---') >= 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    validator.isAlpha = function (str) {\n        return alpha.test(str);\n    };\n\n    validator.isAlphanumeric = function (str) {\n        return alphanumeric.test(str);\n    };\n\n    validator.isNumeric = function (str) {\n        return numeric.test(str);\n    };\n\n    validator.isHexadecimal = function (str) {\n        return hexadecimal.test(str);\n    };\n\n    validator.isHexColor = function (str) {\n        return hexcolor.test(str);\n    };\n\n    validator.isLowercase = function (str) {\n        return str === str.toLowerCase();\n    };\n\n    validator.isUppercase = function (str) {\n        return str === str.toUpperCase();\n    };\n\n    validator.isInt = function (str) {\n        return int.test(str);\n    };\n\n    validator.isFloat = function (str) {\n        return str !== '' && float.test(str);\n    };\n\n    validator.isDivisibleBy = function (str, num) {\n        return validator.toFloat(str) % validator.toInt(num) === 0;\n    };\n\n    validator.isNull = function (str) {\n        return str.length === 0;\n    };\n\n    validator.isLength = function (str, min, max) {\n        var surrogatePairs = str.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g) || [];\n        var len = str.length - surrogatePairs.length;\n        return len >= min && (typeof max === 'undefined' || len <= max);\n    };\n\n    validator.isByteLength = function (str, min, max) {\n        return str.length >= min && (typeof max === 'undefined' || str.length <= max);\n    };\n\n    validator.isUUID = function (str, version) {\n        var pattern = uuid[version ? version : 'all'];\n        return pattern && pattern.test(str);\n    };\n\n    validator.isDate = function (str) {\n        return !isNaN(Date.parse(str));\n    };\n\n    validator.isAfter = function (str, date) {\n        var comparison = validator.toDate(date || new Date())\n          , original = validator.toDate(str);\n        return !!(original && comparison && original > comparison);\n    };\n\n    validator.isBefore = function (str, date) {\n        var comparison = validator.toDate(date || new Date())\n          , original = validator.toDate(str);\n        return original && comparison && original < comparison;\n    };\n\n    validator.isIn = function (str, options) {\n        var i;\n        if (Object.prototype.toString.call(options) === '[object Array]') {\n            var array = [];\n            for (i in options) {\n                array[i] = validator.toString(options[i]);\n            }\n            return array.indexOf(str) >= 0;\n        } else if (typeof options === 'object') {\n            return options.hasOwnProperty(str);\n        } else if (options && typeof options.indexOf === 'function') {\n            return options.indexOf(str) >= 0;\n        }\n        return false;\n    };\n\n    validator.isCreditCard = function (str) {\n        var sanitized = str.replace(/[^0-9]+/g, '');\n        if (!creditCard.test(sanitized)) {\n            return false;\n        }\n        var sum = 0, digit, tmpNum, shouldDouble;\n        for (var i = sanitized.length - 1; i >= 0; i--) {\n            digit = sanitized.substring(i, (i + 1));\n            tmpNum = parseInt(digit, 10);\n            if (shouldDouble) {\n                tmpNum *= 2;\n                if (tmpNum >= 10) {\n                    sum += ((tmpNum % 10) + 1);\n                } else {\n                    sum += tmpNum;\n                }\n            } else {\n                sum += tmpNum;\n            }\n            shouldDouble = !shouldDouble;\n        }\n        return !!((sum % 10) === 0 ? sanitized : false);\n    };\n\n    validator.isISIN = function (str) {\n        if (!isin.test(str)) {\n            return false;\n        }\n        \n        var checksumStr = str.replace(/[A-Z]/g, function(character) {\n            return parseInt(character, 36);\n        });\n        \n        var sum = 0, digit, tmpNum, shouldDouble = true;\n        for (var i = checksumStr.length - 2; i >= 0; i--) {\n            digit = checksumStr.substring(i, (i + 1));\n            tmpNum = parseInt(digit, 10);\n            if (shouldDouble) {\n                tmpNum *= 2;\n                if (tmpNum >= 10) {\n                    sum += tmpNum + 1;\n                } else {\n                    sum += tmpNum;\n                }\n            } else {\n                \n                sum += tmpNum;\n            }\n            shouldDouble = !shouldDouble;\n        }\n        \n        return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;\n    };\n\n    validator.isISBN = function (str, version) {\n        version = validator.toString(version);\n        if (!version) {\n            return validator.isISBN(str, 10) || validator.isISBN(str, 13);\n        }\n        var sanitized = str.replace(/[\\s-]+/g, '')\n          , checksum = 0, i;\n        if (version === '10') {\n            if (!isbn10Maybe.test(sanitized)) {\n                return false;\n            }\n            for (i = 0; i < 9; i++) {\n                checksum += (i + 1) * sanitized.charAt(i);\n            }\n            if (sanitized.charAt(9) === 'X') {\n                checksum += 10 * 10;\n            } else {\n                checksum += 10 * sanitized.charAt(9);\n            }\n            if ((checksum % 11) === 0) {\n                return !!sanitized;\n            }\n        } else  if (version === '13') {\n            if (!isbn13Maybe.test(sanitized)) {\n                return false;\n            }\n            var factor = [ 1, 3 ];\n            for (i = 0; i < 12; i++) {\n                checksum += factor[i % 2] * sanitized.charAt(i);\n            }\n            if (sanitized.charAt(12) - ((10 - (checksum % 10)) % 10) === 0) {\n                return !!sanitized;\n            }\n        }\n        return false;\n    };\n\n    validator.isMobilePhone = function(str, locale) {\n        if (locale in phones) {\n            return phones[locale].test(str);\n        }\n        return false;\n    };\n\n    var default_currency_options = {\n        symbol: '$'\n      , require_symbol: false\n      , allow_space_after_symbol: false\n      , symbol_after_digits: false\n      , allow_negatives: true\n      , parens_for_negatives: false\n      , negative_sign_before_digits: false\n      , negative_sign_after_digits: false\n      , allow_negative_sign_placeholder: false\n      , thousands_separator: ','\n      , decimal_separator: '.'\n      , allow_space_after_digits: false\n    };\n\n    validator.isCurrency = function (str, options) {\n        options = merge(options, default_currency_options);\n\n        return currencyRegex(options).test(str);\n    };\n\n    validator.isJSON = function (str) {\n        try {\n            JSON.parse(str);\n        } catch (e) {\n            return false;\n        }\n        return true;\n    };\n\n    validator.isMultibyte = function (str) {\n        return multibyte.test(str);\n    };\n\n    validator.isAscii = function (str) {\n        return ascii.test(str);\n    };\n\n    validator.isFullWidth = function (str) {\n        return fullWidth.test(str);\n    };\n\n    validator.isHalfWidth = function (str) {\n        return halfWidth.test(str);\n    };\n\n    validator.isVariableWidth = function (str) {\n        return fullWidth.test(str) && halfWidth.test(str);\n    };\n\n    validator.isSurrogatePair = function (str) {\n        return surrogatePair.test(str);\n    };\n\n    validator.isBase64 = function (str) {\n        return base64.test(str);\n    };\n\n    validator.isMongoId = function (str) {\n        return validator.isHexadecimal(str) && str.length === 24;\n    };\n\n    validator.ltrim = function (str, chars) {\n        var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\\s+/g;\n        return str.replace(pattern, '');\n    };\n\n    validator.rtrim = function (str, chars) {\n        var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\\s+$/g;\n        return str.replace(pattern, '');\n    };\n\n    validator.trim = function (str, chars) {\n        var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\\s+|\\s+$/g;\n        return str.replace(pattern, '');\n    };\n\n    validator.escape = function (str) {\n        return (str.replace(/&/g, '&amp;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#x27;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\\//g, '&#x2F;')\n            .replace(/\\`/g, '&#96;'));\n    };\n\n    validator.stripLow = function (str, keep_new_lines) {\n        var chars = keep_new_lines ? '\\\\x00-\\\\x09\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F' : '\\\\x00-\\\\x1F\\\\x7F';\n        return validator.blacklist(str, chars);\n    };\n\n    validator.whitelist = function (str, chars) {\n        return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');\n    };\n\n    validator.blacklist = function (str, chars) {\n        return str.replace(new RegExp('[' + chars + ']+', 'g'), '');\n    };\n\n    var default_normalize_email_options = {\n        lowercase: true\n    };\n\n    validator.normalizeEmail = function (email, options) {\n        options = merge(options, default_normalize_email_options);\n        if (!validator.isEmail(email)) {\n            return false;\n        }\n        var parts = email.split('@', 2);\n        parts[1] = parts[1].toLowerCase();\n        if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {\n            parts[0] = parts[0].toLowerCase().replace(/\\./g, '');\n            if (parts[0][0] === '+') {\n                return false;\n            }\n            parts[0] = parts[0].split('+')[0];\n            parts[1] = 'gmail.com';\n        } else if (options.lowercase) {\n            parts[0] = parts[0].toLowerCase();\n        }\n        return parts.join('@');\n    };\n\n    function merge(obj, defaults) {\n        obj = obj || {};\n        for (var key in defaults) {\n            if (typeof obj[key] === 'undefined') {\n                obj[key] = defaults[key];\n            }\n        }\n        return obj;\n    }\n\n    function currencyRegex(options) {\n        var symbol = '(\\\\' + options.symbol.replace(/\\./g, '\\\\.') + ')' + (options.require_symbol ? '' : '?')\n            , negative = '-?'\n            , whole_dollar_amount_without_sep = '[1-9]\\\\d*'\n            , whole_dollar_amount_with_sep = '[1-9]\\\\d{0,2}(\\\\' + options.thousands_separator + '\\\\d{3})*'\n            , valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep]\n            , whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?'\n            , decimal_amount = '(\\\\' + options.decimal_separator + '\\\\d{2})?';\n        var pattern = whole_dollar_amount + decimal_amount;\n        // default is negative sign before symbol, but there are two other options (besides parens)\n        if (options.allow_negatives && !options.parens_for_negatives) {\n            if (options.negative_sign_after_digits) {\n                pattern += negative;\n            }\n            else if (options.negative_sign_before_digits) {\n                pattern = negative + pattern;\n            }\n        }\n        // South African Rand, for example, uses R 123 (space) and R-123 (no space)\n        if (options.allow_negative_sign_placeholder) {\n            pattern = '( (?!\\\\-))?' + pattern;\n        }\n        else if (options.allow_space_after_symbol) {\n            pattern = ' ?' + pattern;\n        }\n        else if (options.allow_space_after_digits) {\n            pattern += '( (?!$))?';\n        }\n        if (options.symbol_after_digits) {\n            pattern += symbol;\n        } else {\n            pattern = symbol + pattern;\n        }\n        if (options.allow_negatives) {\n            if (options.parens_for_negatives) {\n                pattern = '(\\\\(' + pattern + '\\\\)|' + pattern + ')';\n            }\n            else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {\n                pattern = negative + pattern;\n            }\n        }\n        return new RegExp(\n            '^' +\n            // ensure there's a dollar and/or decimal amount, and that it doesn't start with a space or a negative sign followed by a space\n            '(?!-? )(?=.*\\\\d)' +\n            pattern +\n            '$'\n        );\n    }\n\n    validator.init();\n\n    return validator;\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/validator/validator.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.__esModule = true;\nvar Thinky = __webpack_require__(/*! thinky */ \"./node_modules/thinky/lib/thinky.js\");\nvar thinky = Thinky({ db: 'hostel' });\nvar r = thinky.r, type = thinky.type;\nvar Libro = thinky.createModel(\"Libro\", {\n    id: type.string(),\n    name: type.string(),\n    idAutor: type.string()\n});\nvar Autor = thinky.createModel(\"Autor\", {\n    id: type.string(),\n    name: type.string()\n});\nLibro.belongsTo(Autor, \"autor\", \"idAutor\", \"id\");\n// let libro = new Libro({\n//     name: \"cien aos de soledad\"\n// });\n// let autor = new Autor({\n//     name: \"Gabriel Garcia Marquez\"\n// });\n// libro.autor = autor;\n// libro.saveAll({autor: true}).then((e: any) => {\n//     console.log( e );\n// });\n// Model.save({ name: \"Michel\" })\n//     .then((result: any) => {});\n// Model.run()\n//     .then((e: any) => {\n//         console.log( e );\n//     });\n// Libro.run()\n//     .then((e: any) => {\n//         console.log( e );\n//     });\n// Autor.run()\n//     .then((e: any) => {\n//         console.log( e );\n//     });\n// Libro.get('1a35f990-7928-4691-851c-b8f8e39699ca')\n//     .getJoin({autor: true}).then((libro: any) => {\n//         console.log( libro );\n//     });\n// r.table('Modelo').run()\n//     .then((e: any) => {\n//         console.log('select ~> ', e );\n//     });\n// r.tableList().run()\n//     .then((e: any) => {\n//         console.log('tables ~> ', e );\n//     });\n// r.dbList().run()\n//     .then((e: any) => {\n//         console.log('dbs ~> ', e );\n//     });\n// r.tableDrop('Libro').run();\n// r.tableDrop('Autor').run();\n// r.dbDrop('inter').run();\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack:///external_%22net%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");\n\n//# sourceURL=webpack:///external_%22tls%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ })

/******/ });